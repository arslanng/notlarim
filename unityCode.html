<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Development</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">Unity Learn Codes</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          <li><a class="dropdown-item" href="GraphQL.html" target="_blank">GraphQL</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#basicCarController">Basit Araç Kontroller</a>
                  <a class="nav-link" href="#animalFeeding">Proje 2: Hayvan Besleme</a>
                  <a class="nav-link" href="#colorChange">Renk Değiştirme</a>
                  <a class="nav-link" href="#runnerGame">Proje 3: Koşu Oyunu</a>
                  <a class="nav-link" href="#physicsGameController">Physics Game Controller</a>
                  <a class="nav-link" href="#sumoGame">Proje 4: Sumo Game</a>
                  <a class="nav-link" href="#extraChallenges4">Proje 4 için Daha Fazla Mücadele</a>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div id="1">
              <div id="basicCarController">
                <h1>Basit Araç Kontrolleri</h1>
                <p>
                  Bu bölümde basit araç kontrolü ve basit kamera kontrolü yazıldı.
                </p>
                <p>
                  Araç kontrolü için:
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour // Bu scripti araca ekledik. Aracın hareketini yönetmek için kullanıyoruz.
{
    private float speed = 15f;
    private float turnSpeed = 50f;
    private float horizontalInput;
    private float verticalInput;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        //Kullanıcıdan alınan veri
        horizontalInput = Input.GetAxis("Horizontal"); // Unitynin yerleşik Input sisteminden sağ ve sol ok tuşlarından gelen veriyi 1 ve -1 olarak alır.
        verticalInput = Input.GetAxis("Vertical"); // Unitynin yerleşik Input sisteminden ileri ve ger ok tuşlarından gelen veriyi 1 ve -1 olarak alır.

        // Aracı ileri götüren kod:
        transform.Translate(Vector3.forward * Time.deltaTime * speed * verticalInput); // Vector3.forward = 0,0,1 | Time.deltaTime = 1/saniyedeki frame sayısı
  
        // Aracı yanlara götüren kod:
        // transform.Translate(Vector3.right * Time.deltaTime * horizontalInput * turnSpeed); // bu kodda araç dönmez. yanlara doğru kayma hareketi yapar.

        // Aracı dönderen kod:
        transform.Rotate(Vector3.up, horizontalInput * Time.deltaTime * turnSpeed);
    }
}

                  </pre>
                </p>
                <p>
                  Kamera kontrolü için:
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class FollowPlayer : MonoBehaviour // Kameranın nesneyi takip etmesi için kullanılan script. kameraya ekliyoruz. 
{
    public GameObject player; // takip edilecek nesne
    private Vector3 offset = new Vector3(0, 5, -7); // nesneye göre kameranın konumu
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void LateUpdate() // LateUpdate(), Update() metodunun tamamlanmasını beklemesi gereken işlemler için kullanılır. Kamera takibi vs. LateUpdate() yerine Update() kullanılırsa kullanıcının konumu henüz güncellenmediğinden karakterin bir önceki karedeki konumunu kullanabileceği için küçük gecikmeler veya titremeler olabilir.
    {
        transform.position = player.transform.position + offset;
    }
}

                  </pre>
              </div>
            </div>
            <div id="2">
              <div id="animalFeeding">
                <h1>Proje 2: Hayvan Besleme</h1>
                <h2>Oyuncu kontrolleri</h2>
                <p>
                  Bu komut dosyası player GameObject'ine eklenir ve oyuncunun yatay hareketini ve yemek atmasını kontrol eder.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    [Header("Player Movement")] //Kullanıcı hareketi için gerekli değişkenler
    public float horizontalInput;
    public float speed = 10.0f;
    public float xRange = 10.0f;

    [Header("Player Bullet")] // Kullanıcı mermisi için gerekli değişkenler
    public GameObject projectilePrefab;

    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        //Yatay input alındı
        horizontalInput = Input.GetAxis("Horizontal");

        //Yatay sınırlara gelindiğinde pozisyonun sabitlenip değişmemesi sağlandı
        if(transform.position.x &lt; -xRange)
        {
            transform.position = new Vector3(-xRange, transform.position.y, transform.position.z);
        }

        if (transform.position.x > xRange)
        {
            transform.position = new Vector3(xRange, transform.position.y, transform.position.z);
        }

        //Yatay hareket
        transform.Translate(Vector3.right * horizontalInput * Time.deltaTime * speed);

        if (Input.GetKeyDown(KeyCode.Space)) //Space tuşuna basıldığında projectilePrefab oluşturur.
        {
            Instantiate(projectilePrefab, transform.position, projectilePrefab.transform.rotation);
        }
    }
}

                  </pre>
                </p>
                <h2>İleri Doğru Hareket</h2>
                <p>
                  Bu komut dosyası hayvan GameObject'ine ve atılacak gıda GameObject'ine eklenir ve GameObject'in ileri doğru hareketini kontrol eder.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class MoveForward : MonoBehaviour
{
    public float speed = 40.0f; // başlangıç hız değeri. public olduğundan unity içinde düzenlenir.
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(Vector3.forward * Time.deltaTime * speed);
    }
}

                  </pre>
                </p>
                <h2>Oyun Alanı Sınırını Aşanları Yok Et</h2>
                <p>
                  Bu komut dosyası hayvan GameObject'ine ve atılacak gıda GameObject'ine eklenir ve GameObject'in alan sınırını aşınca yok olmasını sağlar.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class DestroyOutOfBounds : MonoBehaviour
{
    public float topBound = 30.0f; // nesne için üst sınır değeri
    public float lowerBound = -10.0f; // nesne için alt sınır değeri
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        if (transform.position.z > topBound) // nesnenin z pozisyonu sınır değerinden büyükse 
        {
            Destroy(gameObject); //nesneyi yok et
        }
        else if (transform.position.z &lt; lowerBound) // nesnenin z pozisyonu sınır değerinden küçükse 
        {
            Destroy(gameObject); //nesneyi yok et
            Debug.Log("Game Over"); // konsola gameover yaz
        }
    }
}
                  </pre>
                </p>
                <h2>Çarpışmaları Tespit Et</h2>
                <p>
                  Bu komut dosyası hayvan GameObject'ine ve atılacak gıda GameObject'ine eklenir ve GameObject'lerin çarpışmasını kontrol eder. Çarpışanların yok olmasını sağlar
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class DetectCollisions : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
    private void OnTriggerEnter(Collider other)
    {
        Destroy(gameObject); // mevcut gameObject'i yok eder
        Destroy(other.gameObject); // Çarpışılan diğer gameObject'i yok eder.
    }
}
                  </pre>
                </p>
                <h2>Rasgele Hayvan Üret</h2>
                <p>
                  Adından da anlaşıldığı gibi.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour
{
    public GameObject[] animalPrefabs; // animal Prefableri tutan dizi

    private float spawnDelay = 2;
    private float spawnInterval = 1.5f;
    void Start()
    {
        InvokeRepeating("SpawnRandomAnimal", spawnDelay, spawnInterval); // başlanıçtan sonra bir fonksiyonu uyandırmak için kullanılır. ilk parametre fonksiyon adı. ikincisi başlangıştan itibaren kaç saniyede başlatılacağı. üçüncüsü ise hangi aralıkla tekrar edeceği.
    }

    void Update()
    {
        
    }
    void SpawnRandomAnimal() //Random Animal üreten fonksiyon
    {
        int animalIndex = Random.Range(0, animalPrefabs.Length); // animalPrefabs dizisinin uzunluğu arasında rastgele bir sayı oluştur
        Vector3 spawnPos = new Vector3(Random.Range(-15, 15), 0, 20); // x eksenlerinde rastgele bir konum oluştur
        Instantiate(animalPrefabs[animalIndex], spawnPos, animalPrefabs[animalIndex].transform.rotation); // rastgele bir hayvanı rastgele bir konumda oluştur
    }
}
                  </pre>
                </p>
              </div>
              <div id="colorChange">
                <h1>Renk Değiştirme</h1>
                <p>
                  Atandığı nesneye random renk atayan kod:
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using JetBrains.Annotations;
using UnityEngine;

public class Cube : MonoBehaviour
{
    public MeshRenderer Renderer; // MeshRenderer component tanımlandı

    void Start()
    {        
        Material material = Renderer.material; // Renderer component'ine erişildi ve material değişkenine atandı

        material.color = new Color(Random.Range(0.1f, 1f), Random.Range(0.1f, 1f), Random.Range(0.1f, 1f), Random.Range(0.5f, 1f)); // material değişkeninin rengi rastgele olarak değiştirildi
    }
}
                  </pre>
                </p>
              </div>
            </div>
            <div id="3">
              <div id="runnerGame">
                <h1>Proje 3: Koşu Oyunu</h1>
                <p>
                  Bu projede engellerin üzerinden atlayan ve durmadan koşan bir karakter yapacağız. Karakter konumunda sabitken arkaplan ve engeller karaktere doğru gelecek. Karakter engelle çarpışana kadar bu döngü sonsuz devam edecek.
                </p>
                <h2>PlayerController.cs</h2>
                <p>
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    private Rigidbody playerRb; // bir nesneye kuvvet uygulayacaksak rigitbody kompanentine ihtiyacımız var

    // Animasyolar:
    private Animator playerAnim; // objenin animasyonlarını kontrol eder

    // VFX
    public ParticleSystem explosionParticle;
    public ParticleSystem dirtParticle;

    // SFX
    public AudioClip jumpSound;
    public AudioClip crashSound;
    private AudioSource playerAudio;

    // Zıplama
    public float jumpForce = 10; // objenin zıplama kuvveti
    public float gravityModifier; // objenin düşme hızını ayarlar
    bool isGrounded = true; // objenin yere değip değmediğini kontrol eder

    // Oyun devam durumu
    public bool gameOver = false; // oyunun bitip bitmediğini kontrol eder

    void Start()
    {
        // Zıplama
        playerRb = GetComponent&lt;Rigidbody>(); // objenin rigidbody bileşenini alır
        Physics.gravity *= gravityModifier; // fizik motorunun yerçekimini ayarlar

        // Animasyon
        playerAnim = GetComponent&lt;Animator>(); // objenin animator bileşenini alır

        // SFX
        playerAudio = GetComponent&lt;AudioSource>();
    }

    void Update()
    {
        // Space ile zıplama:
        if(Input.GetKeyDown(KeyCode.Space) && isGrounded && !gameOver) // space tuşuna basıldığında, obje yere değdiğinde ve oyun bitmediyse
        {
            playerRb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse); // objenye yukarı doğru bir kuvvet uygular (birinci parametre yön, ikinci parametre kuvvet)
            isGrounded = false; // objenin yere değmediğini belirtir
            playerAnim.SetTrigger("Jump_trig"); // objenin zıplama animasyonunu çalıştırır
            dirtParticle.Stop(); // Ayaktan çıkan toz efektini durdur
            playerAudio.PlayOneShot(jumpSound, 1.0f); // Zıplama sesini çal
        }
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Ground")) // obje yere değdiğinde
        {
            isGrounded = true; // objenin yere değdiğini belirtir
            dirtParticle.Play(); // ayaktan çıkan toz efektini başlat
        }
        else if (collision.gameObject.CompareTag("Obstacle")) // obje engelle çarpıştığında (Oyun bittiğinde)
        {
            gameOver = true; // oyunun bittiğini belirtir
            Debug.Log("Game Over!"); // konsola "Game Over!" yazar
            playerAnim.SetBool("Death_b", true); // objenin ölüm animasyonunu çalıştırır
            playerAnim.SetInteger("DeathType_int", 1); // objenin ölüm animasyonunu çalıştırır
            explosionParticle.Play(); // patlama VFX
            dirtParticle.Stop(); // Ayaktan çıkan toz efektini durdur
            playerAudio.PlayOneShot(crashSound, 1.0f); // oyun sonu SFX
        }
    }
}


                  </pre>
                </p>
                <h2>MoveLeft.cs</h2>
                <p>
                  engellerin ve backgroundun sola doğru hareket etmesini sağlayan kod
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class MoveLeft : MonoBehaviour
{
    public float speed = 30;
    private PlayerController playerControllerScript; // PlayerController scripti
    private float leftBound = -15; // objenin hareket edebileceği en sol sınır

    void Start()
    {
        playerControllerScript = GameObject.Find("Player").GetComponent&lt;PlayerController>(); // PlayerController scriptini alır
    }
    void Update()
    {
        if(playerControllerScript.gameOver == false) // PlayerController scriptindeki gameOver değişkeni false olduğu sürece 
        {
            transform.Translate(Vector3.left * Time.deltaTime * speed); // hareket ettirir
        }
        if(transform.position.x &lt; leftBound && gameObject.CompareTag("Obstacle")) // obje sınıra ulaştığında ve engelse
        {
            Destroy(gameObject); // objeyi yok eder
        }
    }
}

                  </pre>
                </p>
                <h2>RepeatBackground</h2>
                <p>
                  Yarısı hareket ettiğinde backgroundu başlangıç konumuna tekrar çeken kod.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class RepeatBackground : MonoBehaviour
{
    private Vector3 startPos;
    private float repeatWidth;
    void Start()
    {
        startPos = transform.position;
        repeatWidth = GetComponent&lt;BoxCollider>().size.x / 2; // BoxCollider'ın yarısını alır. Bunun için nesneye box collider eklendi.
    }

    void Update()
    {
        if(transform.position.x &lt; startPos.x - repeatWidth)
        {
            transform.position = startPos;
        }
    }
}

                  </pre> 
                </p>
                <h2>SpawnManager.cs</h2>
                <p>
                  Prefab olarak atanan engelleri belirlenen zaman aralıklarında oluşturan kod
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour
{
    public GameObject obstaclePrefab;
    private Vector3 spawnPos = new Vector3(25, 0, 0); // engellerin oluşturulacağı konum
    private float startDelay = 2;
    private float repeatRate = 2;
    PlayerController playerControllerScript; // PlayerController scripti
    void Start()
    {
        playerControllerScript = GameObject.Find("Player").GetComponent&lt;PlayerController>(); // PlayerController scriptini alır
        InvokeRepeating("SpawnObstacle", startDelay, repeatRate); // belirli aralıklarla SpawnObstacle fonksiyonunu çağırır
    }

    void Update()
    {
        
    }
    void SpawnObstacle() // engel oluşturur
    {
        if(playerControllerScript.gameOver == false) // PlayerController scriptindeki gameOver değişkeni false olduğu sürece
        {
            Instantiate(obstaclePrefab, spawnPos, obstaclePrefab.transform.rotation);
        }
    }
}

                  </pre>
                </p>
              </div>
              <div id="physicsGameController">
                <h1>Physics Game Controller</h1>
                <p>
                  Bu bölümde fizik tabanlı bir oyun kontrolcüsü anlatılmıştır.
                </p>
                <h2>PlayerController.cs</h2>
                <p>
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public float speed = 10.0f;
    // inputları almak için değişkenler
    private float verticalInput;
    private float horizontalInput;
    // sınırlar için değişkenler
    private float bottomBound = -2.0f;
    private float zxBound = 24.0f;
    // zıplama ve yerde olup olmadığını kontrol etmek için değişkenler
    private bool isGrounded;
    private bool jumpInput;
    // Rigidbody ve konum değişkenleri
    private Rigidbody playerRb;
    private Vector3 playerPos;
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>();
        playerPos = transform.position; // Oyuncunun başlangıç konumunu alıyoruz. Aşağı düşerse konum sıfırlama için kullanacağız.
    }

    void Update() // Kullanıcıdan gelen inputları almak için Update fonksiyonunu kullanıyoruz. FixedUpdate Inputları almak için uygun değil.
    {
        // Inputları alıyoruz.
        verticalInput = Input.GetAxis("Vertical");
        horizontalInput = Input.GetAxis("Horizontal");

        if (Input.GetKeyDown(KeyCode.Space) && isGrounded) // Zıplama inputu
        {
            jumpInput = true;
        }
    }
    void FixedUpdate() // Fiziksel işlemleri yapmak için FixedUpdate fonksiyonunu kullanıyoruz.
    {

        MovePLayer(); // Oyuncuyu hareket ettiriyoruz.
        Jump();     // Zıplama işlemini yapıyoruz.
        ConstainPlayerPosition();   // Oyuncunun sınırlarını belirliyoruz.
    }
    private void OnCollisionEnter(Collision collision)      // Yerde olup olmadığını kontrol etmek için OnCollisionEnter fonksiyonunu kullanıyoruz.
    {
        if (collision != null)
        {
            isGrounded = true;
        }
    }

    void MovePLayer()
    {
        // Fizik temelli hareket ettirme işlemi. Uyguladığımız gücün yönüne göre hareket eder.
        playerRb.AddForce(verticalInput * speed * Vector3.forward);
        playerRb.AddForce(horizontalInput * speed * Vector3.right);
    }

    void Jump()
    {
        if (jumpInput) // Zıplama
        {
            playerRb.AddForce(Vector3.up * speed, ForceMode.Impulse);
            isGrounded = false;
            jumpInput = false;
        }
    }

    void ConstainPlayerPosition()
    {
        // Aşağı düşerse konum sıfırlama
        if (transform.position.y &lt; bottomBound)
        {
            transform.position = playerPos;
        }

        // Görünmez sınırlar
        if (transform.position.x > zxBound)
        {
            transform.position = new Vector3(zxBound, transform.position.y, transform.position.z);
        }
        if (transform.position.x &lt; -zxBound)
        {
            transform.position = new Vector3(-zxBound, transform.position.y, transform.position.z);
        }
        if (transform.position.z > zxBound)
        {
            transform.position = new Vector3(transform.position.x, transform.position.y, zxBound);
        }
        if (transform.position.z &lt; -zxBound)
        {
            transform.position = new Vector3(transform.position.x, transform.position.y, -zxBound);
        }
    }
}

                  </pre>
              </div>
            </div>
            <div id="4">
                <div id="sumoGame">
                    <h1>Proje 4: Sumo Gam</h1>
                    <p>
                        Oyunumuzda sınırlı bir alanda küresel bir karakteri yönetiyoruz. Her dalgada o dalga sayısı kadar düşman küre bizi alanın dışına atmaya çalışıyor. Player kontrol mantığı rigidbody üzerinden addforce fonksiyonu ile bakış açısına göre ileri - geri ile yapılıyor. horizontalInput ile de bakış açısı değiştiriliyor.
                    </p>
                    <h2>PlayerController</h2>
                    <pre class="prettyprint ms-0">
using System.Collections; // IEnumerator kullanabilmek için gerekli
using UnityEngine;

public class PlayerController : MonoBehaviour // Player gameobjetine atanan script
{
    public float speed = 5f;
    private Rigidbody playerRb; // player bileşenine güç uygulamak için kullanılır
    private GameObject focalPoint; // ana kameranın parenti olarak atanan gameobject. Kamera bakış açısını ayarlamak için kullanılır
    private float powerUpStrength = 15f;
    public bool hasPowerUp = false; // oyuncunun güçlendirme alıp almadığını kontrol etmek için kullanılır
    public GameObject powerupIndicator; // güçlendirme alındığında gösterilecek olan gameobject
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>(); // Rigidbody bileşenini alır
        focalPoint = GameObject.Find("Focal Point"); // sahnedeki "Focal Point" isimli gameobjecti bulur
    }

    void Update()
    {
        float forwardInput = Input.GetAxis("Vertical"); // W ve S tuşları ile ileri geri hareket için kullanılır
        playerRb.AddForce(forwardInput * speed * focalPoint.transform.forward); // oyuncunun bakış açısına göre hareket ettirir

        powerupIndicator.transform.position = transform.position + new Vector3(0, -0.5f, 0); // güçlendirme göstergesinin oyuncunun altında görünmesini sağlar  
    }

    private void OnTriggerEnter(Collider other)    // oyuncunun bir nesneye çarpması durumunda tetiklenir
    {
        if (other.CompareTag("Powerup")) // "Powerup" tagine sahip bir nesneye çarparsa
        {
            hasPowerUp = true; // güçlendirme alındı
            powerupIndicator.gameObject.SetActive(true); // güçlendirme göstergesini aktif eder
            Destroy(other.gameObject); //  güçlendirme nesnesini yok eder
            StartCoroutine(PowerUpCooldownRoutine()); // güçlendirme süresini başlatır
        }
    }

    IEnumerator PowerUpCooldownRoutine() // güçlendirme süresini başlatan coroutine
    {
        yield return new WaitForSeconds(7); // 7 saniye bekler
        hasPowerUp = false; // güçlendirme süresi doldu
        powerupIndicator.gameObject.SetActive(false); // güçlendirme göstergesini kapatır
    }
    
    private void OnCollisionEnter(Collision collision) // oyuncunun bir nesneye çarpması durumunda tetiklenir
    {
        if (collision.gameObject.CompareTag("Enemy") && hasPowerUp) // "Enemy" tagine sahip bir nesneye çarparsa ve güçlendirme almışsa
        {
            Rigidbody enemyRb = collision.gameObject.GetComponent&lt;Rigidbody>(); // çarpılan nesnenin Rigidbody bileşenini alır
            Vector3 awayFromPlayer = collision.transform.position - transform.position; // oyuncunun pozisyonundan çarpılan nesnenin pozisyonunu çıkararak oyuncudan uzak bir vektör oluşturur

            enemyRb.AddForce(awayFromPlayer * powerUpStrength, ForceMode.Impulse); // çarpılan nesneye güç uygular
        }
    }
}

                    </pre>
                    <h2>RotateCamera</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class RotateCamera : MonoBehaviour // Kamerayı döndürmek için kullanılan ve focal point gameobjectine atanan script
{
    public float rotationSpeed = 50f;

    void Update()
    {
        float horizontalInput = Input.GetAxis("Horizontal");
        transform.Rotate(Vector3.up, horizontalInput * rotationSpeed * Time.deltaTime);
    }
}
                    </pre>
                    <h2>Enemy</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class Enemy : MonoBehaviour // Düşman gameobjectine atanan script
{
    public float speed = 3f;
    private Rigidbody enemyRb;
    private GameObject player;
    void Start()
    { 
        enemyRb = GetComponent&lt;Rigidbody>(); // Rigidbody bileşenini alır
        player = GameObject.Find("Player"); // sahnedeki "Player" isimli gameobjecti bulur
    }

    void Update()
    {
        Vector3 lookDirection = (player.transform.position - transform.position).normalized; // Düşmanın bakış açısını oyuncunun pozisyonuna göre ayarlar
        enemyRb.AddForce(lookDirection * speed); // Düşmanı oyuncuya doğru hareket ettirir

        if (transform.position.y &lt; -10) // Düşman y ekseninde -10'un altına düşerse
        {
            Destroy(gameObject); // Düşmanı yok eder
        }
    }
}
                    </pre>
                    <h2>SpawnManager</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour // SpawnManager gameobjectine atanan script. 
{
    public GameObject enemyPrefab; // düşman prefabı
    public GameObject powerupPrefab; // güçlendirme prefabı
    private float spawnRange = 9f; // düşmanların spawn olacağı alanın boyutu
    public int enemyCount; // düşman sayısı
    public int waveNumber = 1; // dalga numarası
    void Start()
    {
        SpawnEnemyWave(waveNumber); // ilk dalga düşmanları spawn edilir
        Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); // ilk güçlendirme spawn edilir
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; // sahnedeki düşman sayısını alır

        if (enemyCount == 0) // sahnedeki düşman sayısı 0 ise
        {
            waveNumber++; // dalga numarasını artırır
            SpawnEnemyWave(waveNumber); // yeni dalga düşmanları spawn edilir
            Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); // yeni güçlendirme spawn edilir
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) // düşman dalgasını spawn eden fonksiyon
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) // düşman sayısı kadar döngü oluşturur
        {
            Instantiate(enemyPrefab, GenerateSpawnPosition(), enemyPrefab.transform.rotation); // düşman prefabını rastgele bir pozisyonda spawn eder
        }
    }

    private Vector3 GenerateSpawnPosition() // rastgele spawn pozisyonu oluşturan fonksiyon. void fonksiyonu yerine Vector3 döndürür.
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; // rastgele pozisyonu döndürür
    }
}

                    </pre>
                </div>
                <div id="extraChallenges4">
                    <h1>Proje 4 için Daha Fazla Mücadele</h1>
                    <h2>Yeni Düşman</h2>
                    <p>
                        Enemy prefabını kopyalandı. Hız değeri değiştirildi. Her iki prefabı da eklemek ve birini random çağırabilmek için SpawnManager aşağıdaki şekilde güncellendi.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour  
{
    public GameObject[] enemyPrefabs; // Enemy prefabs array halinde alındı 
    public GameObject powerupPrefab; 
    private float spawnRange = 9f; 
    public int enemyCount; 
    public int waveNumber = 1; 
    void Start()
    {
        SpawnEnemyWave(waveNumber); 
        Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); 
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; 

        if (enemyCount == 0) 
        {
            waveNumber++; 
            SpawnEnemyWave(waveNumber); 
            Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); 
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) 
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) 
        {
            Instantiate(enemyPrefabs[Random.Range(0, enemyPrefabs.Length)], GenerateSpawnPosition(), enemyPrefabs[0].transform.rotation); //Enemy prefabini rastgele seçip spawn ettik
        }
    }

    private Vector3 GenerateSpawnPosition() 
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; 
    }
}

                        </pre>
                    </p>

                    <h2>Güdümlü Roketler</h2>
                    <p>
                        Bir tane rocket prefabı oluşturdum ve ona RocketBehaviour scriptini yerleştirdik. PowerUp prefabına PowerUp scriptini oluşturup yerleştirdik.
                    </p>
                    <h3>PowerUp</h3>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public enum PowerUpType { None, Pushback, Rockets } // Enum türü tanımladık. Bu türde olan değişken yanlızca bu değerleri alabilir.
public class PowerUp : MonoBehaviour
{
    public PowerUpType powerUpType; // Enum türünde bir değişken tanımladık. Inspector ekranından bizim prefabımıza uygun olanı seçeceğiz.
}

                    </pre>
                    <h3>RocketBehaviour</h3>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class RocketBehaviour : MonoBehaviour // roket başka bir fonksiyonda üretildi. Burada yapacağı hareketi ve çarpışma durumunu tanımladık.
{
    private Transform target;
    private float speed = 15f;
    private bool homing; // hedefe doğru hareket edip etmeyeceğini kontrol etmek için

    private float rocketStrength = 15f;
    private float aliveTime = 5f;
    
    public void Fire(Transform newTarget)
    {
        target = newTarget;
        homing = true;
        Destroy(gameObject, aliveTime); // aliveTime süresi dolunca roketi yok et
    }

    void Update()
    {
        if(homing && target != null)
        {
            Vector3 moveDirection = (target.position - transform.position).normalized;
            transform.position += moveDirection * speed * Time.deltaTime;
            transform.LookAt(target); // roketin yönünü hedefe doğru döndür
        }
    }

    private void OnCollisionEnter(Collision col)
    {
        if(target != null)
        {
            if(col.gameObject.CompareTag(target.tag))
            {
                Rigidbody targetRigitBody = col.gameObject.GetComponent&lt;Rigidbody>();
                Vector3 away = -col.contacts[0].normal;
                targetRigitBody.AddForce(away * rocketStrength, ForceMode.Impulse);
                Destroy(gameObject);
            }
        }
    }
}

                    </pre>
                    <p>
                        Birden fazla powerup prefabını alıp random yerleştirmesi için <strong>SpawnManager</strong> modifiye edildi.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour  
{
    public GameObject[] enemyPrefabs; 
    public GameObject[] powerupPrefabs; // birden fazla powerup eklenebilmesi için array tanımladık 
    private float spawnRange = 9f; 
    public int enemyCount; 
    public int waveNumber = 1; 
    void Start()
    {
        int randomPowerup = Random.Range(0, powerupPrefabs.Length); // rastgele powerup seçimi
        SpawnEnemyWave(waveNumber);
        Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); //Başlangıçta rasgele bir powerup oluşması sağlandı. 
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; 

        if (enemyCount == 0) 
        {
            waveNumber++; 
            SpawnEnemyWave(waveNumber);
            int randomPowerup = Random.Range(0, powerupPrefabs.Length); // rastgele powerup seçimi
            Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); // Rasgele bir powerup oluşması sağlandı. 
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) 
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) 
        {
            Instantiate(enemyPrefabs[Random.Range(0, enemyPrefabs.Length)], GenerateSpawnPosition(), enemyPrefabs[0].transform.rotation); 
        }
    }

    private Vector3 GenerateSpawnPosition() 
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; 
    }
}

                        </pre>
                    </p>
                    <p>
                        Powerup tipleri arasındaki farkı anlaması ve "F" tuşuyla roket ateşlemesi için <strong>PlayerController</strong> modifiye edildi.
                        <pre class="prettyprint ms-0">
using System.Collections; 
using UnityEngine;

public class PlayerController : MonoBehaviour 
{
    public float speed = 5f;
    private Rigidbody playerRb; 
    private GameObject focalPoint; 
    private float powerUpStrength = 15f;
    public bool hasPowerUp = false; 
    public GameObject powerupIndicator;

    // güdümlü füze için gerekli olan değişkenler
    public PowerUpType currentPowerUp = PowerUpType.None; // mevcup powerup türü

    public GameObject rocketPrefab; // füze prefabı
    private GameObject tmpRocket; // prefabdan oluşan her bir füze için geçici değişken
    private Coroutine powerupCountdown; // powerup süresi için coroutine
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>(); 
        focalPoint = GameObject.Find("Focal Point"); 
    }

    void Update()
    {
        float forwardInput = Input.GetAxis("Vertical"); 
        playerRb.AddForce(forwardInput * speed * focalPoint.transform.forward); 

        powerupIndicator.transform.position = transform.position + new Vector3(0, -0.5f, 0);
        
        if(currentPowerUp == PowerUpType.Rockets && Input.GetKeyDown(KeyCode.F)) // powerUp rockets ise ve f tuşuna basılırsa
        {
            LaunchRockets(); // füze fırlatma fonksiyonu çağrıldı
        }
    }

    private void OnTriggerEnter(Collider other)  // rocket powerUpı için güncellendi.  
    {
        if (other.CompareTag("Powerup")) 
        {
            hasPowerUp = true;
            currentPowerUp = other.GetComponent&lt;PowerUp>().powerUpType; // powerup türünü al
            powerupIndicator.gameObject.SetActive(true); 
            Destroy(other.gameObject); 
            if(powerupCountdown != null) // Sayım var ise
            {
                StopCoroutine(powerupCountdown); // var olan sayımı durdur
            }
            powerupCountdown = StartCoroutine(PowerUpCooldownRoutine()); // sayımı durdurabilmek için değişkene atadık
        }
    }

    IEnumerator PowerUpCooldownRoutine() 
    {
        yield return new WaitForSeconds(7); 
        hasPowerUp = false;
        currentPowerUp = PowerUpType.None; // powerup türünü sıfırla
        powerupIndicator.gameObject.SetActive(false); 
    }
    
    private void OnCollisionEnter(Collision collision) 
    {
        if (collision.gameObject.CompareTag("Enemy") && currentPowerUp == PowerUpType.Pushback) // çarpışmada mevcut powerupı sorgulaması için güncelleme yapıldı.
        {
            Rigidbody enemyRb = collision.gameObject.GetComponent&lt;Rigidbody>(); 
            Vector3 awayFromPlayer = collision.transform.position - transform.position; 

            enemyRb.AddForce(awayFromPlayer * powerUpStrength, ForceMode.Impulse); 
        }
    }

    void LaunchRockets() // füze fırlatma fonksiyonu
    {
        foreach (var enemy in FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None)) // düşmanları bul ve her bir düşman için...
        {
            tmpRocket = Instantiate(rocketPrefab, transform.position + Vector3.up, Quaternion.identity);
            tmpRocket.GetComponent&lt;RocketBehaviour>().Fire(enemy.transform); // füzeleri fırlatacak fonksiyona enemy transform iletildi ve fonksiyon çağırıldı. 
        }
    }
}

                        </pre>
                    </p>
                    <h2>Smash PowerUp</h2>
                    <p>
                        Smash <strong>PowerUp</strong> içindeki listeye "Smash" eklendi. 
                    </p>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public enum PowerUpType { None, Pushback, Rockets, Smash } // Enum türüne ekleme yapıldı "Smash"
public class PowerUp : MonoBehaviour
{
    public PowerUpType powerUpType; 
}

                    </pre>
                    <p>Yeni bir PowerUp prefabı oluşturuldu ve inspectorde türü Smash seçilldi. Bu prefab SpawnManager'e eklendi</p>
                    <p>
                        <strong>PlayerController</strong> altında smash hareketinin fonksiyonu yazıldı.
                        <pre class="prettyprint ms-0">
using System.Collections; 
using UnityEngine;

public class PlayerController : MonoBehaviour 
{
    public float speed = 5f;
    private Rigidbody playerRb; 
    private GameObject focalPoint; 
    private float powerUpStrength = 15f;
    public bool hasPowerUp = false; 
    public GameObject powerupIndicator;

    // güdümlü füze için gerekli olan değişkenler
    public PowerUpType currentPowerUp = PowerUpType.None; // mevcup powerup türü
    public GameObject rocketPrefab; 
    private GameObject tmpRocket; 
    private Coroutine powerupCountdown;

    // smash powerupı için gerekli olan değişkenler
    [Header("Smash Powerup")]
    public float hangTime; // zıplama süresi
    public float smashSpeed; // zıplama hızı
    public float explosionForce; // patlama kuvveti
    public float explosionRadius; // patlama yarıçapı

    bool smashing = false;
    float floorY;

    IEnumerator Smash() // hareket içeren ve sıralı fonksiyonlar için void yerine IEnumerator kullanıldı. void ile yapsaydık hepsi bir anda olurdu. IEnumerator ile frmame by frame ilerlendi.
    {
        var enemies = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None); // tüm düşmaları bul

        floorY = transform.position.y; // zıplama anındaki yüksekliği değişkene kaydet.

        float jumpTime = Time.time + hangTime; // zıplama zamanının biteceği zamanı hesapla

        while (Time.time &lt; jumpTime) // mevcut zaman zıplama zamanından küçükse (zıplama bitmediyse)
        {
            playerRb.linearVelocity = new Vector2(playerRb.linearVelocity.x, smashSpeed); // yukarı doğru hareket et
            yield return null; // bir sonraki frame'e geç
        }

        while(transform.position.y > floorY) // nesne başlangıç konumundan yüksekse ve üstteki şart sağlanmıyorsa
        {
            playerRb.linearVelocity = new Vector2(playerRb.linearVelocity.x, -smashSpeed); // aşağı doğru hareket et
            yield return null; // bir sonraki frame'e geç
        }

        for(int i = 0; i &lt; enemies.Length; i++) // enemies listesini döngüye al
        {
            if(enemies[i] != null) // enemies[i] null 
            {
                enemies[i].GetComponent&lt;Rigidbody>().AddExplosionForce(explosionForce, transform.position, explosionRadius, 0.0f, ForceMode.Impulse); // düşmanın rigidbody'sine patlama kuvveti uygula
            }

            smashing = false; // zıplama işlemi bitti
        }
    }
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>(); 
        focalPoint = GameObject.Find("Focal Point"); 
    }

    void Update()
    {
        float forwardInput = Input.GetAxis("Vertical"); 
        playerRb.AddForce(forwardInput * speed * focalPoint.transform.forward); 

        powerupIndicator.transform.position = transform.position + new Vector3(0, -0.5f, 0);
        
        if(currentPowerUp == PowerUpType.Rockets && Input.GetKeyDown(KeyCode.F)) 
        {
            LaunchRockets(); 
        }

        if(currentPowerUp == PowerUpType.Smash && Input.GetKeyDown(KeyCode.Space) && !smashing) // smash powerupı aktifse ve F tuşuna basıldıysa ve player zıplamış değilse
        {
            smashing = true; // zıplamayı true yap
            StartCoroutine(Smash()); // zıplama işlemini başlat
        }
    }

    private void OnTriggerEnter(Collider other)    
    {
        if (other.CompareTag("Powerup")) 
        {
            hasPowerUp = true;
            currentPowerUp = other.GetComponent&lt;PowerUp>().powerUpType; 
            powerupIndicator.gameObject.SetActive(true); 
            Destroy(other.gameObject); 
            if(powerupCountdown != null) 
            {
                StopCoroutine(powerupCountdown); 
            }
            powerupCountdown = StartCoroutine(PowerUpCooldownRoutine()); 
        }
    }

    IEnumerator PowerUpCooldownRoutine() 
    {
        yield return new WaitForSeconds(7); 
        hasPowerUp = false;
        currentPowerUp = PowerUpType.None; 
        powerupIndicator.gameObject.SetActive(false); 
    }
    
    private void OnCollisionEnter(Collision collision) 
    {
        if (collision.gameObject.CompareTag("Enemy") && currentPowerUp == PowerUpType.Pushback) 
        {
            Rigidbody enemyRb = collision.gameObject.GetComponent&lt;Rigidbody>(); 
            Vector3 awayFromPlayer = collision.transform.position - transform.position; 

            enemyRb.AddForce(awayFromPlayer * powerUpStrength, ForceMode.Impulse); 
        }
    }

    void LaunchRockets() 
    {
        foreach (var enemy in FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None)) 
        {
            tmpRocket = Instantiate(rocketPrefab, transform.position + Vector3.up, Quaternion.identity);
            tmpRocket.GetComponent&lt;RocketBehaviour>().Fire(enemy.transform); 
        }
    }
}

                        </pre>
                    </p>
                    <h2>Boss Fight</h2>
                    <p>
                        Boss'umuzun hangi koşulda spawn edileceği <strong>SpawnManager</strong> güncellenerek belirtildi.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour  
{
    public GameObject[] enemyPrefabs; 
    public GameObject[] powerupPrefabs; // birden fazla powerup eklenebilmesi için array tanımladık 
    private float spawnRange = 9f; 
    public int enemyCount; 
    public int waveNumber = 1;

    // Boss Fight için gereken değişkenler
    [Header("Boss Fight")]
    public GameObject bossPrefab; // Boss prefab'ı
    public GameObject[] miniEnemyPrefabs; // Mini düşman prefab'ı
    public int bossRound; // kaç turda 1 boss spawn edileceği
    void Start()
    {
        int randomPowerup = Random.Range(0, powerupPrefabs.Length); 
        SpawnEnemyWave(waveNumber);
        Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); 
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; 

        if (enemyCount == 0) 
        {
            waveNumber++; 
            if(waveNumber % bossRound == 0) // Boss spawn etme koşulu
            {
                SpawnBossWave(waveNumber);
            }
            else
            {
                SpawnEnemyWave(waveNumber);
            }
            int randomPowerup = Random.Range(0, powerupPrefabs.Length); 
            Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); 
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) 
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) 
        {
            Instantiate(enemyPrefabs[Random.Range(0, enemyPrefabs.Length)], GenerateSpawnPosition(), enemyPrefabs[0].transform.rotation); 
        }
    }

    private Vector3 GenerateSpawnPosition() 
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; 
    }

    void SpawnBossWave(int currentRound)
    {
        int miniEnemysToSpawn;

        if(bossRound != 0) // her boss savaşında belirli aralıklarla boss levelinin yarısı kadar mini düşman spawn edilecek.
        {
            miniEnemysToSpawn = currentRound / bossRound;
        }
        else
        {
            miniEnemysToSpawn = 1;
        }

        var boss = Instantiate(bossPrefab, GenerateSpawnPosition(), bossPrefab.transform.rotation); // Boss'u spawn et
        boss.GetComponent&lt;Enemy>().miniEnemySpawnCount = miniEnemysToSpawn; // Boss'un mini düşman spawn etme sayısını ayarla
    }

    public void SpawnMiniEnemy(int amount)
    {
        for(int i = 0; i &lt; amount; i++)
        {
            int randomMini = Random.Range(0, miniEnemyPrefabs.Length); // Mini düşman prefab'ını rastgele seç
            Instantiate(miniEnemyPrefabs[randomMini], GenerateSpawnPosition(), miniEnemyPrefabs[randomMini].transform.rotation); // Mini düşmanı spawn et
        }
    }
}

                        </pre>
                    </p>
                    <p>
                        Boss spawn edildiğinde nasıl davranacağı <strong>Enemy</strong> içinde yazıldı.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class Enemy : MonoBehaviour 
{
    public float speed = 3f;
    private Rigidbody enemyRb;
    private GameObject player;

    // Boss Fight için gereken değişkenler
    public bool isBoss = false; // Boss olup olmadığını kontrol etmek için

    public float spawnInterval;
    private float nextSpawn;

    public int miniEnemySpawnCount; // Boss'un spawn edeceği mini düşman sayısı. Bu sayı SpawnManager'dan ayarlanacak.

    private SpawnManager spawnManager;
    void Start()
    { 
        enemyRb = GetComponent&lt;Rigidbody>(); 
        player = GameObject.Find("Player"); 

        if(isBoss)
        {
            spawnManager = FindAnyObjectByType&lt;SpawnManager>();
        }
    }

    void Update()
    {
        Vector3 lookDirection = (player.transform.position - transform.position).normalized; 
        enemyRb.AddForce(lookDirection * speed); 

        if(isBoss) // spawn edilen boss ise
        {
            if(Time.time > nextSpawn)
            {
                nextSpawn = Time.time + spawnInterval; // Spawn aralığını ayarlıyoruz
                spawnManager.SpawnMiniEnemy(miniEnemySpawnCount); // Mini düşmanları spawn et. Fonksiyon spawnManager'da tanımlı.
            }
        }

        if (transform.position.y &lt; -10) 
        {
            Destroy(gameObject); 
        }
    }
}

                        </pre>
                    </p>
                </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>