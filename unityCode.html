<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Development</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">Unity Learn Codes</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          <li><a class="dropdown-item" href="GraphQL.html" target="_blank">GraphQL</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#basicCarController">Basit Araç Kontroller</a>
                  <a class="nav-link" href="#animalFeeding">Proje 2: Hayvan Besleme</a>
                  <a class="nav-link" href="#colorChange">Renk Değiştirme</a>
                  <a class="nav-link" href="#runnerGame">Proje 3: Koşu Oyunu</a>
                  <a class="nav-link" href="#physicsGameController">Physics Game Controller</a>
                  <a class="nav-link" href="#sumoGame">Proje 4: Sumo Game</a>
                  <a class="nav-link" href="#extraChallenges4">Proje 4 için Daha Fazla Mücadele</a>
                  <a class="nav-link" href="#userInterface">Proje 5: Clicky Crates</a>
                  <a class="nav-link" href="#extraChallenges5">Proje 5 için Daha Fazla Mücadele</a>
                  <a class="nav-link" href="#optimization">Proje Optimizasyonu</a>
                  <a class="nav-link" href="#dataManage">Data Kalıcılığı</a>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div id="1">
              <div id="basicCarController">
                <h1>Basit Araç Kontrolleri</h1>
                <p>
                  Bu bölümde basit araç kontrolü ve basit kamera kontrolü yazıldı.
                </p>
                <p>
                  Araç kontrolü için:
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour // Bu scripti araca ekledik. Aracın hareketini yönetmek için kullanıyoruz.
{
    private float speed = 15f;
    private float turnSpeed = 50f;
    private float horizontalInput;
    private float verticalInput;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        //Kullanıcıdan alınan veri
        horizontalInput = Input.GetAxis("Horizontal"); // Unitynin yerleşik Input sisteminden sağ ve sol ok tuşlarından gelen veriyi 1 ve -1 olarak alır.
        verticalInput = Input.GetAxis("Vertical"); // Unitynin yerleşik Input sisteminden ileri ve ger ok tuşlarından gelen veriyi 1 ve -1 olarak alır.

        // Aracı ileri götüren kod:
        transform.Translate(Vector3.forward * Time.deltaTime * speed * verticalInput); // Vector3.forward = 0,0,1 | Time.deltaTime = 1/saniyedeki frame sayısı
  
        // Aracı yanlara götüren kod:
        // transform.Translate(Vector3.right * Time.deltaTime * horizontalInput * turnSpeed); // bu kodda araç dönmez. yanlara doğru kayma hareketi yapar.

        // Aracı dönderen kod:
        transform.Rotate(Vector3.up, horizontalInput * Time.deltaTime * turnSpeed);
    }
}

                  </pre>
                </p>
                <p>
                  Kamera kontrolü için:
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class FollowPlayer : MonoBehaviour // Kameranın nesneyi takip etmesi için kullanılan script. kameraya ekliyoruz. 
{
    public GameObject player; // takip edilecek nesne
    private Vector3 offset = new Vector3(0, 5, -7); // nesneye göre kameranın konumu
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void LateUpdate() // LateUpdate(), Update() metodunun tamamlanmasını beklemesi gereken işlemler için kullanılır. Kamera takibi vs. LateUpdate() yerine Update() kullanılırsa kullanıcının konumu henüz güncellenmediğinden karakterin bir önceki karedeki konumunu kullanabileceği için küçük gecikmeler veya titremeler olabilir.
    {
        transform.position = player.transform.position + offset;
    }
}

                  </pre>
              </div>
            </div>
            <div id="2">
              <div id="animalFeeding">
                <h1>Proje 2: Hayvan Besleme</h1>
                <h2>Oyuncu kontrolleri</h2>
                <p>
                  Bu komut dosyası player GameObject'ine eklenir ve oyuncunun yatay hareketini ve yemek atmasını kontrol eder.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    [Header("Player Movement")] //Kullanıcı hareketi için gerekli değişkenler
    public float horizontalInput;
    public float speed = 10.0f;
    public float xRange = 10.0f;

    [Header("Player Bullet")] // Kullanıcı mermisi için gerekli değişkenler
    public GameObject projectilePrefab;

    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        //Yatay input alındı
        horizontalInput = Input.GetAxis("Horizontal");

        //Yatay sınırlara gelindiğinde pozisyonun sabitlenip değişmemesi sağlandı
        if(transform.position.x &lt; -xRange)
        {
            transform.position = new Vector3(-xRange, transform.position.y, transform.position.z);
        }

        if (transform.position.x > xRange)
        {
            transform.position = new Vector3(xRange, transform.position.y, transform.position.z);
        }

        //Yatay hareket
        transform.Translate(Vector3.right * horizontalInput * Time.deltaTime * speed);

        if (Input.GetKeyDown(KeyCode.Space)) //Space tuşuna basıldığında projectilePrefab oluşturur.
        {
            Instantiate(projectilePrefab, transform.position, projectilePrefab.transform.rotation);
        }
    }
}

                  </pre>
                </p>
                <h2>İleri Doğru Hareket</h2>
                <p>
                  Bu komut dosyası hayvan GameObject'ine ve atılacak gıda GameObject'ine eklenir ve GameObject'in ileri doğru hareketini kontrol eder.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class MoveForward : MonoBehaviour
{
    public float speed = 40.0f; // başlangıç hız değeri. public olduğundan unity içinde düzenlenir.
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(Vector3.forward * Time.deltaTime * speed);
    }
}

                  </pre>
                </p>
                <h2>Oyun Alanı Sınırını Aşanları Yok Et</h2>
                <p>
                  Bu komut dosyası hayvan GameObject'ine ve atılacak gıda GameObject'ine eklenir ve GameObject'in alan sınırını aşınca yok olmasını sağlar.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class DestroyOutOfBounds : MonoBehaviour
{
    public float topBound = 30.0f; // nesne için üst sınır değeri
    public float lowerBound = -10.0f; // nesne için alt sınır değeri
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        if (transform.position.z > topBound) // nesnenin z pozisyonu sınır değerinden büyükse 
        {
            Destroy(gameObject); //nesneyi yok et
        }
        else if (transform.position.z &lt; lowerBound) // nesnenin z pozisyonu sınır değerinden küçükse 
        {
            Destroy(gameObject); //nesneyi yok et
            Debug.Log("Game Over"); // konsola gameover yaz
        }
    }
}
                  </pre>
                </p>
                <h2>Çarpışmaları Tespit Et</h2>
                <p>
                  Bu komut dosyası hayvan GameObject'ine ve atılacak gıda GameObject'ine eklenir ve GameObject'lerin çarpışmasını kontrol eder. Çarpışanların yok olmasını sağlar
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class DetectCollisions : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
    private void OnTriggerEnter(Collider other)
    {
        Destroy(gameObject); // mevcut gameObject'i yok eder
        Destroy(other.gameObject); // Çarpışılan diğer gameObject'i yok eder.
    }
}
                  </pre>
                </p>
                <h2>Rasgele Hayvan Üret</h2>
                <p>
                  Adından da anlaşıldığı gibi.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour
{
    public GameObject[] animalPrefabs; // animal Prefableri tutan dizi

    private float spawnDelay = 2;
    private float spawnInterval = 1.5f;
    void Start()
    {
        InvokeRepeating("SpawnRandomAnimal", spawnDelay, spawnInterval); // başlanıçtan sonra bir fonksiyonu uyandırmak için kullanılır. ilk parametre fonksiyon adı. ikincisi başlangıştan itibaren kaç saniyede başlatılacağı. üçüncüsü ise hangi aralıkla tekrar edeceği.
    }

    void Update()
    {
        
    }
    void SpawnRandomAnimal() //Random Animal üreten fonksiyon
    {
        int animalIndex = Random.Range(0, animalPrefabs.Length); // animalPrefabs dizisinin uzunluğu arasında rastgele bir sayı oluştur
        Vector3 spawnPos = new Vector3(Random.Range(-15, 15), 0, 20); // x eksenlerinde rastgele bir konum oluştur
        Instantiate(animalPrefabs[animalIndex], spawnPos, animalPrefabs[animalIndex].transform.rotation); // rastgele bir hayvanı rastgele bir konumda oluştur
    }
}
                  </pre>
                </p>
              </div>
              <div id="colorChange">
                <h1>Renk Değiştirme</h1>
                <p>
                  Atandığı nesneye random renk atayan kod:
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using JetBrains.Annotations;
using UnityEngine;

public class Cube : MonoBehaviour
{
    public MeshRenderer Renderer; // MeshRenderer component tanımlandı

    void Start()
    {        
        Material material = Renderer.material; // Renderer component'ine erişildi ve material değişkenine atandı

        material.color = new Color(Random.Range(0.1f, 1f), Random.Range(0.1f, 1f), Random.Range(0.1f, 1f), Random.Range(0.5f, 1f)); // material değişkeninin rengi rastgele olarak değiştirildi
    }
}
                  </pre>
                </p>
              </div>
            </div>
            <div id="3">
              <div id="runnerGame">
                <h1>Proje 3: Koşu Oyunu</h1>
                <p>
                  Bu projede engellerin üzerinden atlayan ve durmadan koşan bir karakter yapacağız. Karakter konumunda sabitken arkaplan ve engeller karaktere doğru gelecek. Karakter engelle çarpışana kadar bu döngü sonsuz devam edecek.
                </p>
                <h2>PlayerController.cs</h2>
                <p>
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    private Rigidbody playerRb; // bir nesneye kuvvet uygulayacaksak rigitbody kompanentine ihtiyacımız var

    // Animasyolar:
    private Animator playerAnim; // objenin animasyonlarını kontrol eder

    // VFX
    public ParticleSystem explosionParticle;
    public ParticleSystem dirtParticle;

    // SFX
    public AudioClip jumpSound;
    public AudioClip crashSound;
    private AudioSource playerAudio;

    // Zıplama
    public float jumpForce = 10; // objenin zıplama kuvveti
    public float gravityModifier; // objenin düşme hızını ayarlar
    bool isGrounded = true; // objenin yere değip değmediğini kontrol eder

    // Oyun devam durumu
    public bool gameOver = false; // oyunun bitip bitmediğini kontrol eder

    void Start()
    {
        // Zıplama
        playerRb = GetComponent&lt;Rigidbody>(); // objenin rigidbody bileşenini alır
        Physics.gravity *= gravityModifier; // fizik motorunun yerçekimini ayarlar

        // Animasyon
        playerAnim = GetComponent&lt;Animator>(); // objenin animator bileşenini alır

        // SFX
        playerAudio = GetComponent&lt;AudioSource>();
    }

    void Update()
    {
        // Space ile zıplama:
        if(Input.GetKeyDown(KeyCode.Space) && isGrounded && !gameOver) // space tuşuna basıldığında, obje yere değdiğinde ve oyun bitmediyse
        {
            playerRb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse); // objenye yukarı doğru bir kuvvet uygular (birinci parametre yön, ikinci parametre kuvvet)
            isGrounded = false; // objenin yere değmediğini belirtir
            playerAnim.SetTrigger("Jump_trig"); // objenin zıplama animasyonunu çalıştırır
            dirtParticle.Stop(); // Ayaktan çıkan toz efektini durdur
            playerAudio.PlayOneShot(jumpSound, 1.0f); // Zıplama sesini çal
        }
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Ground")) // obje yere değdiğinde
        {
            isGrounded = true; // objenin yere değdiğini belirtir
            dirtParticle.Play(); // ayaktan çıkan toz efektini başlat
        }
        else if (collision.gameObject.CompareTag("Obstacle")) // obje engelle çarpıştığında (Oyun bittiğinde)
        {
            gameOver = true; // oyunun bittiğini belirtir
            Debug.Log("Game Over!"); // konsola "Game Over!" yazar
            playerAnim.SetBool("Death_b", true); // objenin ölüm animasyonunu çalıştırır
            playerAnim.SetInteger("DeathType_int", 1); // objenin ölüm animasyonunu çalıştırır
            explosionParticle.Play(); // patlama VFX
            dirtParticle.Stop(); // Ayaktan çıkan toz efektini durdur
            playerAudio.PlayOneShot(crashSound, 1.0f); // oyun sonu SFX
        }
    }
}


                  </pre>
                </p>
                <h2>MoveLeft.cs</h2>
                <p>
                  engellerin ve backgroundun sola doğru hareket etmesini sağlayan kod
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class MoveLeft : MonoBehaviour
{
    public float speed = 30;
    private PlayerController playerControllerScript; // PlayerController scripti
    private float leftBound = -15; // objenin hareket edebileceği en sol sınır

    void Start()
    {
        playerControllerScript = GameObject.Find("Player").GetComponent&lt;PlayerController>(); // PlayerController scriptini alır
    }
    void Update()
    {
        if(playerControllerScript.gameOver == false) // PlayerController scriptindeki gameOver değişkeni false olduğu sürece 
        {
            transform.Translate(Vector3.left * Time.deltaTime * speed); // hareket ettirir
        }
        if(transform.position.x &lt; leftBound && gameObject.CompareTag("Obstacle")) // obje sınıra ulaştığında ve engelse
        {
            Destroy(gameObject); // objeyi yok eder
        }
    }
}

                  </pre>
                </p>
                <h2>RepeatBackground</h2>
                <p>
                  Yarısı hareket ettiğinde backgroundu başlangıç konumuna tekrar çeken kod.
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class RepeatBackground : MonoBehaviour
{
    private Vector3 startPos;
    private float repeatWidth;
    void Start()
    {
        startPos = transform.position;
        repeatWidth = GetComponent&lt;BoxCollider>().size.x / 2; // BoxCollider'ın yarısını alır. Bunun için nesneye box collider eklendi.
    }

    void Update()
    {
        if(transform.position.x &lt; startPos.x - repeatWidth)
        {
            transform.position = startPos;
        }
    }
}

                  </pre> 
                </p>
                <h2>SpawnManager.cs</h2>
                <p>
                  Prefab olarak atanan engelleri belirlenen zaman aralıklarında oluşturan kod
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour
{
    public GameObject obstaclePrefab;
    private Vector3 spawnPos = new Vector3(25, 0, 0); // engellerin oluşturulacağı konum
    private float startDelay = 2;
    private float repeatRate = 2;
    PlayerController playerControllerScript; // PlayerController scripti
    void Start()
    {
        playerControllerScript = GameObject.Find("Player").GetComponent&lt;PlayerController>(); // PlayerController scriptini alır
        InvokeRepeating("SpawnObstacle", startDelay, repeatRate); // belirli aralıklarla SpawnObstacle fonksiyonunu çağırır
    }

    void Update()
    {
        
    }
    void SpawnObstacle() // engel oluşturur
    {
        if(playerControllerScript.gameOver == false) // PlayerController scriptindeki gameOver değişkeni false olduğu sürece
        {
            Instantiate(obstaclePrefab, spawnPos, obstaclePrefab.transform.rotation);
        }
    }
}

                  </pre>
                </p>
              </div>
              <div id="physicsGameController">
                <h1>Physics Game Controller</h1>
                <p>
                  Bu bölümde fizik tabanlı bir oyun kontrolcüsü anlatılmıştır.
                </p>
                <h2>PlayerController.cs</h2>
                <p>
                  <pre class="prettyprint ms-0">
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public float speed = 10.0f;
    // inputları almak için değişkenler
    private float verticalInput;
    private float horizontalInput;
    // sınırlar için değişkenler
    private float bottomBound = -2.0f;
    private float zxBound = 24.0f;
    // zıplama ve yerde olup olmadığını kontrol etmek için değişkenler
    private bool isGrounded;
    private bool jumpInput;
    // Rigidbody ve konum değişkenleri
    private Rigidbody playerRb;
    private Vector3 playerPos;
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>();
        playerPos = transform.position; // Oyuncunun başlangıç konumunu alıyoruz. Aşağı düşerse konum sıfırlama için kullanacağız.
    }

    void Update() // Kullanıcıdan gelen inputları almak için Update fonksiyonunu kullanıyoruz. FixedUpdate Inputları almak için uygun değil.
    {
        // Inputları alıyoruz.
        verticalInput = Input.GetAxis("Vertical");
        horizontalInput = Input.GetAxis("Horizontal");

        if (Input.GetKeyDown(KeyCode.Space) && isGrounded) // Zıplama inputu
        {
            jumpInput = true;
        }
    }
    void FixedUpdate() // Fiziksel işlemleri yapmak için FixedUpdate fonksiyonunu kullanıyoruz.
    {

        MovePLayer(); // Oyuncuyu hareket ettiriyoruz.
        Jump();     // Zıplama işlemini yapıyoruz.
        ConstainPlayerPosition();   // Oyuncunun sınırlarını belirliyoruz.
    }
    private void OnCollisionEnter(Collision collision)      // Yerde olup olmadığını kontrol etmek için OnCollisionEnter fonksiyonunu kullanıyoruz.
    {
        if (collision != null)
        {
            isGrounded = true;
        }
    }

    void MovePLayer()
    {
        // Fizik temelli hareket ettirme işlemi. Uyguladığımız gücün yönüne göre hareket eder.
        playerRb.AddForce(verticalInput * speed * Vector3.forward);
        playerRb.AddForce(horizontalInput * speed * Vector3.right);
    }

    void Jump()
    {
        if (jumpInput) // Zıplama
        {
            playerRb.AddForce(Vector3.up * speed, ForceMode.Impulse);
            isGrounded = false;
            jumpInput = false;
        }
    }

    void ConstainPlayerPosition()
    {
        // Aşağı düşerse konum sıfırlama
        if (transform.position.y &lt; bottomBound)
        {
            transform.position = playerPos;
        }

        // Görünmez sınırlar
        if (transform.position.x > zxBound)
        {
            transform.position = new Vector3(zxBound, transform.position.y, transform.position.z);
        }
        if (transform.position.x &lt; -zxBound)
        {
            transform.position = new Vector3(-zxBound, transform.position.y, transform.position.z);
        }
        if (transform.position.z > zxBound)
        {
            transform.position = new Vector3(transform.position.x, transform.position.y, zxBound);
        }
        if (transform.position.z &lt; -zxBound)
        {
            transform.position = new Vector3(transform.position.x, transform.position.y, -zxBound);
        }
    }
}

                  </pre>
              </div>
            </div>
            <div id="4">
                <div id="sumoGame">
                    <h1>Proje 4: Sumo Gam</h1>
                    <p>
                        Oyunumuzda sınırlı bir alanda küresel bir karakteri yönetiyoruz. Her dalgada o dalga sayısı kadar düşman küre bizi alanın dışına atmaya çalışıyor. Player kontrol mantığı rigidbody üzerinden addforce fonksiyonu ile bakış açısına göre ileri - geri ile yapılıyor. horizontalInput ile de bakış açısı değiştiriliyor.
                    </p>
                    <h2>PlayerController</h2>
                    <pre class="prettyprint ms-0">
using System.Collections; // IEnumerator kullanabilmek için gerekli
using UnityEngine;

public class PlayerController : MonoBehaviour // Player gameobjetine atanan script
{
    public float speed = 5f;
    private Rigidbody playerRb; // player bileşenine güç uygulamak için kullanılır
    private GameObject focalPoint; // ana kameranın parenti olarak atanan gameobject. Kamera bakış açısını ayarlamak için kullanılır
    private float powerUpStrength = 15f;
    public bool hasPowerUp = false; // oyuncunun güçlendirme alıp almadığını kontrol etmek için kullanılır
    public GameObject powerupIndicator; // güçlendirme alındığında gösterilecek olan gameobject
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>(); // Rigidbody bileşenini alır
        focalPoint = GameObject.Find("Focal Point"); // sahnedeki "Focal Point" isimli gameobjecti bulur
    }

    void Update()
    {
        float forwardInput = Input.GetAxis("Vertical"); // W ve S tuşları ile ileri geri hareket için kullanılır
        playerRb.AddForce(forwardInput * speed * focalPoint.transform.forward); // oyuncunun bakış açısına göre hareket ettirir

        powerupIndicator.transform.position = transform.position + new Vector3(0, -0.5f, 0); // güçlendirme göstergesinin oyuncunun altında görünmesini sağlar  
    }

    private void OnTriggerEnter(Collider other)    // oyuncunun bir nesneye çarpması durumunda tetiklenir
    {
        if (other.CompareTag("Powerup")) // "Powerup" tagine sahip bir nesneye çarparsa
        {
            hasPowerUp = true; // güçlendirme alındı
            powerupIndicator.gameObject.SetActive(true); // güçlendirme göstergesini aktif eder
            Destroy(other.gameObject); //  güçlendirme nesnesini yok eder
            StartCoroutine(PowerUpCooldownRoutine()); // güçlendirme süresini başlatır
        }
    }

    IEnumerator PowerUpCooldownRoutine() // güçlendirme süresini başlatan coroutine
    {
        yield return new WaitForSeconds(7); // 7 saniye bekler
        hasPowerUp = false; // güçlendirme süresi doldu
        powerupIndicator.gameObject.SetActive(false); // güçlendirme göstergesini kapatır
    }
    
    private void OnCollisionEnter(Collision collision) // oyuncunun bir nesneye çarpması durumunda tetiklenir
    {
        if (collision.gameObject.CompareTag("Enemy") && hasPowerUp) // "Enemy" tagine sahip bir nesneye çarparsa ve güçlendirme almışsa
        {
            Rigidbody enemyRb = collision.gameObject.GetComponent&lt;Rigidbody>(); // çarpılan nesnenin Rigidbody bileşenini alır
            Vector3 awayFromPlayer = collision.transform.position - transform.position; // oyuncunun pozisyonundan çarpılan nesnenin pozisyonunu çıkararak oyuncudan uzak bir vektör oluşturur

            enemyRb.AddForce(awayFromPlayer * powerUpStrength, ForceMode.Impulse); // çarpılan nesneye güç uygular
        }
    }
}

                    </pre>
                    <h2>RotateCamera</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class RotateCamera : MonoBehaviour // Kamerayı döndürmek için kullanılan ve focal point gameobjectine atanan script
{
    public float rotationSpeed = 50f;

    void Update()
    {
        float horizontalInput = Input.GetAxis("Horizontal");
        transform.Rotate(Vector3.up, horizontalInput * rotationSpeed * Time.deltaTime);
    }
}
                    </pre>
                    <h2>Enemy</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class Enemy : MonoBehaviour // Düşman gameobjectine atanan script
{
    public float speed = 3f;
    private Rigidbody enemyRb;
    private GameObject player;
    void Start()
    { 
        enemyRb = GetComponent&lt;Rigidbody>(); // Rigidbody bileşenini alır
        player = GameObject.Find("Player"); // sahnedeki "Player" isimli gameobjecti bulur
    }

    void Update()
    {
        Vector3 lookDirection = (player.transform.position - transform.position).normalized; // Düşmanın bakış açısını oyuncunun pozisyonuna göre ayarlar
        enemyRb.AddForce(lookDirection * speed); // Düşmanı oyuncuya doğru hareket ettirir

        if (transform.position.y &lt; -10) // Düşman y ekseninde -10'un altına düşerse
        {
            Destroy(gameObject); // Düşmanı yok eder
        }
    }
}
                    </pre>
                    <h2>SpawnManager</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour // SpawnManager gameobjectine atanan script. 
{
    public GameObject enemyPrefab; // düşman prefabı
    public GameObject powerupPrefab; // güçlendirme prefabı
    private float spawnRange = 9f; // düşmanların spawn olacağı alanın boyutu
    public int enemyCount; // düşman sayısı
    public int waveNumber = 1; // dalga numarası
    void Start()
    {
        SpawnEnemyWave(waveNumber); // ilk dalga düşmanları spawn edilir
        Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); // ilk güçlendirme spawn edilir
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; // sahnedeki düşman sayısını alır

        if (enemyCount == 0) // sahnedeki düşman sayısı 0 ise
        {
            waveNumber++; // dalga numarasını artırır
            SpawnEnemyWave(waveNumber); // yeni dalga düşmanları spawn edilir
            Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); // yeni güçlendirme spawn edilir
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) // düşman dalgasını spawn eden fonksiyon
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) // düşman sayısı kadar döngü oluşturur
        {
            Instantiate(enemyPrefab, GenerateSpawnPosition(), enemyPrefab.transform.rotation); // düşman prefabını rastgele bir pozisyonda spawn eder
        }
    }

    private Vector3 GenerateSpawnPosition() // rastgele spawn pozisyonu oluşturan fonksiyon. void fonksiyonu yerine Vector3 döndürür.
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; // rastgele pozisyonu döndürür
    }
}

                    </pre>
                </div>
                <div id="extraChallenges4">
                    <h1>Proje 4 için Daha Fazla Mücadele</h1>
                    <h2>Yeni Düşman</h2>
                    <p>
                        Enemy prefabını kopyalandı. Hız değeri değiştirildi. Her iki prefabı da eklemek ve birini random çağırabilmek için SpawnManager aşağıdaki şekilde güncellendi.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour  
{
    public GameObject[] enemyPrefabs; // Enemy prefabs array halinde alındı 
    public GameObject powerupPrefab; 
    private float spawnRange = 9f; 
    public int enemyCount; 
    public int waveNumber = 1; 
    void Start()
    {
        SpawnEnemyWave(waveNumber); 
        Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); 
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; 

        if (enemyCount == 0) 
        {
            waveNumber++; 
            SpawnEnemyWave(waveNumber); 
            Instantiate(powerupPrefab, GenerateSpawnPosition(), powerupPrefab.transform.rotation); 
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) 
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) 
        {
            Instantiate(enemyPrefabs[Random.Range(0, enemyPrefabs.Length)], GenerateSpawnPosition(), enemyPrefabs[0].transform.rotation); //Enemy prefabini rastgele seçip spawn ettik
        }
    }

    private Vector3 GenerateSpawnPosition() 
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; 
    }
}

                        </pre>
                    </p>

                    <h2>Güdümlü Roketler</h2>
                    <p>
                        Bir tane rocket prefabı oluşturdum ve ona RocketBehaviour scriptini yerleştirdik. PowerUp prefabına PowerUp scriptini oluşturup yerleştirdik.
                    </p>
                    <h3>PowerUp</h3>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public enum PowerUpType { None, Pushback, Rockets } // Enum türü tanımladık. Bu türde olan değişken yanlızca bu değerleri alabilir.
public class PowerUp : MonoBehaviour
{
    public PowerUpType powerUpType; // Enum türünde bir değişken tanımladık. Inspector ekranından bizim prefabımıza uygun olanı seçeceğiz.
}

                    </pre>
                    <h3>RocketBehaviour</h3>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class RocketBehaviour : MonoBehaviour // roket başka bir fonksiyonda üretildi. Burada yapacağı hareketi ve çarpışma durumunu tanımladık.
{
    private Transform target;
    private float speed = 15f;
    private bool homing; // hedefe doğru hareket edip etmeyeceğini kontrol etmek için

    private float rocketStrength = 15f;
    private float aliveTime = 5f;
    
    public void Fire(Transform newTarget)
    {
        target = newTarget;
        homing = true;
        Destroy(gameObject, aliveTime); // aliveTime süresi dolunca roketi yok et
    }

    void Update()
    {
        if(homing && target != null)
        {
            Vector3 moveDirection = (target.position - transform.position).normalized;
            transform.position += moveDirection * speed * Time.deltaTime;
            transform.LookAt(target); // roketin yönünü hedefe doğru döndür
        }
    }

    private void OnCollisionEnter(Collision col)
    {
        if(target != null)
        {
            if(col.gameObject.CompareTag(target.tag))
            {
                Rigidbody targetRigitBody = col.gameObject.GetComponent&lt;Rigidbody>();
                Vector3 away = -col.contacts[0].normal;
                targetRigitBody.AddForce(away * rocketStrength, ForceMode.Impulse);
                Destroy(gameObject);
            }
        }
    }
}

                    </pre>
                    <p>
                        Birden fazla powerup prefabını alıp random yerleştirmesi için <strong>SpawnManager</strong> modifiye edildi.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour  
{
    public GameObject[] enemyPrefabs; 
    public GameObject[] powerupPrefabs; // birden fazla powerup eklenebilmesi için array tanımladık 
    private float spawnRange = 9f; 
    public int enemyCount; 
    public int waveNumber = 1; 
    void Start()
    {
        int randomPowerup = Random.Range(0, powerupPrefabs.Length); // rastgele powerup seçimi
        SpawnEnemyWave(waveNumber);
        Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); //Başlangıçta rasgele bir powerup oluşması sağlandı. 
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; 

        if (enemyCount == 0) 
        {
            waveNumber++; 
            SpawnEnemyWave(waveNumber);
            int randomPowerup = Random.Range(0, powerupPrefabs.Length); // rastgele powerup seçimi
            Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); // Rasgele bir powerup oluşması sağlandı. 
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) 
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) 
        {
            Instantiate(enemyPrefabs[Random.Range(0, enemyPrefabs.Length)], GenerateSpawnPosition(), enemyPrefabs[0].transform.rotation); 
        }
    }

    private Vector3 GenerateSpawnPosition() 
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; 
    }
}

                        </pre>
                    </p>
                    <p>
                        Powerup tipleri arasındaki farkı anlaması ve "F" tuşuyla roket ateşlemesi için <strong>PlayerController</strong> modifiye edildi.
                        <pre class="prettyprint ms-0">
using System.Collections; 
using UnityEngine;

public class PlayerController : MonoBehaviour 
{
    public float speed = 5f;
    private Rigidbody playerRb; 
    private GameObject focalPoint; 
    private float powerUpStrength = 15f;
    public bool hasPowerUp = false; 
    public GameObject powerupIndicator;

    // güdümlü füze için gerekli olan değişkenler
    public PowerUpType currentPowerUp = PowerUpType.None; // mevcup powerup türü

    public GameObject rocketPrefab; // füze prefabı
    private GameObject tmpRocket; // prefabdan oluşan her bir füze için geçici değişken
    private Coroutine powerupCountdown; // powerup süresi için coroutine
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>(); 
        focalPoint = GameObject.Find("Focal Point"); 
    }

    void Update()
    {
        float forwardInput = Input.GetAxis("Vertical"); 
        playerRb.AddForce(forwardInput * speed * focalPoint.transform.forward); 

        powerupIndicator.transform.position = transform.position + new Vector3(0, -0.5f, 0);
        
        if(currentPowerUp == PowerUpType.Rockets && Input.GetKeyDown(KeyCode.F)) // powerUp rockets ise ve f tuşuna basılırsa
        {
            LaunchRockets(); // füze fırlatma fonksiyonu çağrıldı
        }
    }

    private void OnTriggerEnter(Collider other)  // rocket powerUpı için güncellendi.  
    {
        if (other.CompareTag("Powerup")) 
        {
            hasPowerUp = true;
            currentPowerUp = other.GetComponent&lt;PowerUp>().powerUpType; // powerup türünü al
            powerupIndicator.gameObject.SetActive(true); 
            Destroy(other.gameObject); 
            if(powerupCountdown != null) // Sayım var ise
            {
                StopCoroutine(powerupCountdown); // var olan sayımı durdur
            }
            powerupCountdown = StartCoroutine(PowerUpCooldownRoutine()); // sayımı durdurabilmek için değişkene atadık
        }
    }

    IEnumerator PowerUpCooldownRoutine() 
    {
        yield return new WaitForSeconds(7); 
        hasPowerUp = false;
        currentPowerUp = PowerUpType.None; // powerup türünü sıfırla
        powerupIndicator.gameObject.SetActive(false); 
    }
    
    private void OnCollisionEnter(Collision collision) 
    {
        if (collision.gameObject.CompareTag("Enemy") && currentPowerUp == PowerUpType.Pushback) // çarpışmada mevcut powerupı sorgulaması için güncelleme yapıldı.
        {
            Rigidbody enemyRb = collision.gameObject.GetComponent&lt;Rigidbody>(); 
            Vector3 awayFromPlayer = collision.transform.position - transform.position; 

            enemyRb.AddForce(awayFromPlayer * powerUpStrength, ForceMode.Impulse); 
        }
    }

    void LaunchRockets() // füze fırlatma fonksiyonu
    {
        foreach (var enemy in FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None)) // düşmanları bul ve her bir düşman için...
        {
            tmpRocket = Instantiate(rocketPrefab, transform.position + Vector3.up, Quaternion.identity);
            tmpRocket.GetComponent&lt;RocketBehaviour>().Fire(enemy.transform); // füzeleri fırlatacak fonksiyona enemy transform iletildi ve fonksiyon çağırıldı. 
        }
    }
}

                        </pre>
                    </p>
                    <h2>Smash PowerUp</h2>
                    <p>
                        Smash <strong>PowerUp</strong> içindeki listeye "Smash" eklendi. 
                    </p>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public enum PowerUpType { None, Pushback, Rockets, Smash } // Enum türüne ekleme yapıldı "Smash"
public class PowerUp : MonoBehaviour
{
    public PowerUpType powerUpType; 
}

                    </pre>
                    <p>Yeni bir PowerUp prefabı oluşturuldu ve inspectorde türü Smash seçilldi. Bu prefab SpawnManager'e eklendi</p>
                    <p>
                        <strong>PlayerController</strong> altında smash hareketinin fonksiyonu yazıldı.
                        <pre class="prettyprint ms-0">
using System.Collections; 
using UnityEngine;

public class PlayerController : MonoBehaviour 
{
    public float speed = 5f;
    private Rigidbody playerRb; 
    private GameObject focalPoint; 
    private float powerUpStrength = 15f;
    public bool hasPowerUp = false; 
    public GameObject powerupIndicator;

    // güdümlü füze için gerekli olan değişkenler
    public PowerUpType currentPowerUp = PowerUpType.None; // mevcup powerup türü
    public GameObject rocketPrefab; 
    private GameObject tmpRocket; 
    private Coroutine powerupCountdown;

    // smash powerupı için gerekli olan değişkenler
    [Header("Smash Powerup")]
    public float hangTime; // zıplama süresi
    public float smashSpeed; // zıplama hızı
    public float explosionForce; // patlama kuvveti
    public float explosionRadius; // patlama yarıçapı

    bool smashing = false;
    float floorY;

    IEnumerator Smash() // hareket içeren ve sıralı fonksiyonlar için void yerine IEnumerator kullanıldı. void ile yapsaydık hepsi bir anda olurdu. IEnumerator ile frmame by frame ilerlendi.
    {
        var enemies = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None); // tüm düşmaları bul

        floorY = transform.position.y; // zıplama anındaki yüksekliği değişkene kaydet.

        float jumpTime = Time.time + hangTime; // zıplama zamanının biteceği zamanı hesapla

        while (Time.time &lt; jumpTime) // mevcut zaman zıplama zamanından küçükse (zıplama bitmediyse)
        {
            playerRb.linearVelocity = new Vector2(playerRb.linearVelocity.x, smashSpeed); // yukarı doğru hareket et
            yield return null; // bir sonraki frame'e geç
        }

        while(transform.position.y > floorY) // nesne başlangıç konumundan yüksekse ve üstteki şart sağlanmıyorsa
        {
            playerRb.linearVelocity = new Vector2(playerRb.linearVelocity.x, -smashSpeed); // aşağı doğru hareket et
            yield return null; // bir sonraki frame'e geç
        }

        for(int i = 0; i &lt; enemies.Length; i++) // enemies listesini döngüye al
        {
            if(enemies[i] != null) // enemies[i] null 
            {
                enemies[i].GetComponent&lt;Rigidbody>().AddExplosionForce(explosionForce, transform.position, explosionRadius, 0.0f, ForceMode.Impulse); // düşmanın rigidbody'sine patlama kuvveti uygula
            }

            smashing = false; // zıplama işlemi bitti
        }
    }
    void Start()
    {
        playerRb = GetComponent&lt;Rigidbody>(); 
        focalPoint = GameObject.Find("Focal Point"); 
    }

    void Update()
    {
        float forwardInput = Input.GetAxis("Vertical"); 
        playerRb.AddForce(forwardInput * speed * focalPoint.transform.forward); 

        powerupIndicator.transform.position = transform.position + new Vector3(0, -0.5f, 0);
        
        if(currentPowerUp == PowerUpType.Rockets && Input.GetKeyDown(KeyCode.F)) 
        {
            LaunchRockets(); 
        }

        if(currentPowerUp == PowerUpType.Smash && Input.GetKeyDown(KeyCode.Space) && !smashing) // smash powerupı aktifse ve F tuşuna basıldıysa ve player zıplamış değilse
        {
            smashing = true; // zıplamayı true yap
            StartCoroutine(Smash()); // zıplama işlemini başlat
        }
    }

    private void OnTriggerEnter(Collider other)    
    {
        if (other.CompareTag("Powerup")) 
        {
            hasPowerUp = true;
            currentPowerUp = other.GetComponent&lt;PowerUp>().powerUpType; 
            powerupIndicator.gameObject.SetActive(true); 
            Destroy(other.gameObject); 
            if(powerupCountdown != null) 
            {
                StopCoroutine(powerupCountdown); 
            }
            powerupCountdown = StartCoroutine(PowerUpCooldownRoutine()); 
        }
    }

    IEnumerator PowerUpCooldownRoutine() 
    {
        yield return new WaitForSeconds(7); 
        hasPowerUp = false;
        currentPowerUp = PowerUpType.None; 
        powerupIndicator.gameObject.SetActive(false); 
    }
    
    private void OnCollisionEnter(Collision collision) 
    {
        if (collision.gameObject.CompareTag("Enemy") && currentPowerUp == PowerUpType.Pushback) 
        {
            Rigidbody enemyRb = collision.gameObject.GetComponent&lt;Rigidbody>(); 
            Vector3 awayFromPlayer = collision.transform.position - transform.position; 

            enemyRb.AddForce(awayFromPlayer * powerUpStrength, ForceMode.Impulse); 
        }
    }

    void LaunchRockets() 
    {
        foreach (var enemy in FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None)) 
        {
            tmpRocket = Instantiate(rocketPrefab, transform.position + Vector3.up, Quaternion.identity);
            tmpRocket.GetComponent&lt;RocketBehaviour>().Fire(enemy.transform); 
        }
    }
}

                        </pre>
                    </p>
                    <h2>Boss Fight</h2>
                    <p>
                        Boss'umuzun hangi koşulda spawn edileceği <strong>SpawnManager</strong> güncellenerek belirtildi.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class SpawnManager : MonoBehaviour  
{
    public GameObject[] enemyPrefabs; 
    public GameObject[] powerupPrefabs; // birden fazla powerup eklenebilmesi için array tanımladık 
    private float spawnRange = 9f; 
    public int enemyCount; 
    public int waveNumber = 1;

    // Boss Fight için gereken değişkenler
    [Header("Boss Fight")]
    public GameObject bossPrefab; // Boss prefab'ı
    public GameObject[] miniEnemyPrefabs; // Mini düşman prefab'ı
    public int bossRound; // kaç turda 1 boss spawn edileceği
    void Start()
    {
        int randomPowerup = Random.Range(0, powerupPrefabs.Length); 
        SpawnEnemyWave(waveNumber);
        Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); 
    }

    void Update()
    {
        enemyCount = FindObjectsByType&lt;Enemy>(FindObjectsSortMode.None).Length; 

        if (enemyCount == 0) 
        {
            waveNumber++; 
            if(waveNumber % bossRound == 0) // Boss spawn etme koşulu
            {
                SpawnBossWave(waveNumber);
            }
            else
            {
                SpawnEnemyWave(waveNumber);
            }
            int randomPowerup = Random.Range(0, powerupPrefabs.Length); 
            Instantiate(powerupPrefabs[randomPowerup], GenerateSpawnPosition(), powerupPrefabs[randomPowerup].transform.rotation); 
        }
    }

    void SpawnEnemyWave(int enemiesToSpawn) 
    {
        for(int i = 0; i &lt; enemiesToSpawn; i++) 
        {
            Instantiate(enemyPrefabs[Random.Range(0, enemyPrefabs.Length)], GenerateSpawnPosition(), enemyPrefabs[0].transform.rotation); 
        }
    }

    private Vector3 GenerateSpawnPosition() 
    {
        float spawnPosX = Random.Range(-spawnRange, spawnRange);
        float spawnPosZ = Random.Range(-spawnRange, spawnRange);

        Vector3 randomPos = new Vector3(spawnPosX, 0, spawnPosZ);

        return randomPos; 
    }

    void SpawnBossWave(int currentRound)
    {
        int miniEnemysToSpawn;

        if(bossRound != 0) // her boss savaşında belirli aralıklarla boss levelinin yarısı kadar mini düşman spawn edilecek.
        {
            miniEnemysToSpawn = currentRound / bossRound;
        }
        else
        {
            miniEnemysToSpawn = 1;
        }

        var boss = Instantiate(bossPrefab, GenerateSpawnPosition(), bossPrefab.transform.rotation); // Boss'u spawn et
        boss.GetComponent&lt;Enemy>().miniEnemySpawnCount = miniEnemysToSpawn; // Boss'un mini düşman spawn etme sayısını ayarla
    }

    public void SpawnMiniEnemy(int amount)
    {
        for(int i = 0; i &lt; amount; i++)
        {
            int randomMini = Random.Range(0, miniEnemyPrefabs.Length); // Mini düşman prefab'ını rastgele seç
            Instantiate(miniEnemyPrefabs[randomMini], GenerateSpawnPosition(), miniEnemyPrefabs[randomMini].transform.rotation); // Mini düşmanı spawn et
        }
    }
}

                        </pre>
                    </p>
                    <p>
                        Boss spawn edildiğinde nasıl davranacağı <strong>Enemy</strong> içinde yazıldı.
                        <pre class="prettyprint ms-0">
using UnityEngine;

public class Enemy : MonoBehaviour 
{
    public float speed = 3f;
    private Rigidbody enemyRb;
    private GameObject player;

    // Boss Fight için gereken değişkenler
    public bool isBoss = false; // Boss olup olmadığını kontrol etmek için

    public float spawnInterval;
    private float nextSpawn;

    public int miniEnemySpawnCount; // Boss'un spawn edeceği mini düşman sayısı. Bu sayı SpawnManager'dan ayarlanacak.

    private SpawnManager spawnManager;
    void Start()
    { 
        enemyRb = GetComponent&lt;Rigidbody>(); 
        player = GameObject.Find("Player"); 

        if(isBoss)
        {
            spawnManager = FindAnyObjectByType&lt;SpawnManager>();
        }
    }

    void Update()
    {
        Vector3 lookDirection = (player.transform.position - transform.position).normalized; 
        enemyRb.AddForce(lookDirection * speed); 

        if(isBoss) // spawn edilen boss ise
        {
            if(Time.time > nextSpawn)
            {
                nextSpawn = Time.time + spawnInterval; // Spawn aralığını ayarlıyoruz
                spawnManager.SpawnMiniEnemy(miniEnemySpawnCount); // Mini düşmanları spawn et. Fonksiyon spawnManager'da tanımlı.
            }
        }

        if (transform.position.y &lt; -10) 
        {
            Destroy(gameObject); 
        }
    }
}

                        </pre>
                    </p>
                </div>
            </div>
            <div id="5">
                <div id="userInterface">
                    <h1>Proje 5: Clicky Crates</h1>
                    <p>
                        Basit bir giriş sayfasında zorluk seçtikten sonra nesnelerin yukarıya uçtuğu, bizim de ekrana gelen nesneleri tıklayarak yok ettiğimiz bir oyun hazırladık.
                    </p>
                    <h2>GameManager</h2>
                    <pre class="prettyprint ms-0">
using System.Collections; // IEnumerator için 
using System.Collections.Generic; // List kullanabilmek için
using TMPro; // TextMeshPro kullanabilmek için
using UnityEngine.SceneManagement; // SceneManager kullanabilmek için
using UnityEngine.UI; // UI kullanabilmek için
using UnityEngine;

public class GameManager : MonoBehaviour // Oyun yöneticisi scripti. Game Manager adında bir empty Game Objecte atandı.
{
    [Header("UI References")] // UI referansları için başlık ekliyoruz.
    public TextMeshProUGUI scoreText; // TextMeshProUGUI kullanarak scoreText'i tanımlıyoruz.
    public TextMeshProUGUI gameOverText; // TextMeshProUGUI kullanarak gameOverText'i tanımlıyoruz.
    public Button restartButton; // Restart butonunu tanımlıyoruz.
    public GameObject titleScreen; // Başlangıç ekranını tanımlıyoruz. (Title ve zorluk butonları bunun child'idır.)

    [Header("Spawn Object References")] // Spawn nesne referansları için başlık ekliyoruz.
    public List&lt;GameObject> targets;
    public bool isGameActive; // Oyun aktif mi değil mi kontrol etmek için bir boolean değişkeni tanımlıyoruz.
    private int score; // Skor değişkenini tanımlıyoruz.
    public float spawnRate = 1.0f;

    
    IEnumerator SpawnTarget() // Nesnekeri Spawn eden fonksiyon. Başlatıldıktan sonra belirli aralıklarla tekrarlayan bir işlem olduğundan bu yöntemle yazıldı.
    {
        while (isGameActive) // while şart true olduğu sürece içerideki döngüyü devam ettirir.
        {
            yield return new WaitForSeconds(spawnRate); // spawnRate kadar bekle.
            int index = Random.Range(0, targets.Count);
            Instantiate(targets[index]); // targets listesinden rastgele bir nesne seçip instantiate ediyoruz.
        }
    }

    public void UpdateScore(int scoreToAdd) // Skor güncelleme fonksiyonu.
    {
        score += scoreToAdd;
        scoreText.text = "Score: " + score; // Skor metnini güncelliyoruz.
    }

    public void GameOver() // Oyun bitti fonksiyonu.
    {
        gameOverText.gameObject.SetActive(true); // Oyun bitti metnini gösteriyoruz.
        restartButton.gameObject.SetActive(true); // Yeniden başlat butonunu gösteriyoruz.

        isGameActive = false; // Oyun artık aktif değil.
    }

    public void RestartGame() // Yeniden başlatma fonksiyonu.
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name); // Mevcut sahneyi yeniden yüklüyoruz.
    }
    public void StartGame(int difficulty) // Oyun başlatma fonksiyonu. Zorluk seviyesini parametre olarak alır.
    {
        isGameActive = true; // Oyun aktif.
        score = 0; // Skor değişkenini sıfırlıyoruz.
        spawnRate /= difficulty; // Zorluk seviyesine göre spawnRate'i ayarlıyoruz.
        titleScreen.gameObject.SetActive(false); // Başlangıç ekranını gizliyoruz.

        StartCoroutine(SpawnTarget()); // SpawnTarget() fonksiyonunu başlatır.
        UpdateScore(0); // Skor metnini güncelliyoruz.
    }
}

                    </pre>

                    <h2>Target</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class Target : MonoBehaviour // Hedef nesnesi için bir script. Bu script, hedef nesnelerin hareketini ve etkileşimlerini kontrol eder. Hedef olarak kullanılacak prefablara eklendi.
{
    private Rigidbody targetRb;
    private float minSpeed = 12;
    private float maxSpeed = 16;
    private float maxTorque = 10;
    private float xRange = 4;
    private float ySpawnPos = -6;

    private GameManager gameManager; // GameManager scriptini tanımlıyoruz.

    public int pointValue; // Target'ın puan değerini tanımlıyoruz.

    public ParticleSystem explosionParticle;
    void Start() // Nesne oluşturulduğunda çalışacak olan fonksiyon.
    {
        targetRb = GetComponent<Rigidbody>();
        
        targetRb.AddForce(RandomForce(), ForceMode.Impulse);
        targetRb.AddTorque(RandomTorque(), RandomTorque(), RandomTorque(), ForceMode.Impulse);

        transform.position = RandomSpawnPos();

        gameManager = GameObject.Find("Game Manager").GetComponent<GameManager>(); // GameManager scriptini buluyoruz.

    }

    private void OnMouseDown() // Obje mouse ile tıklandığında çalışacak olan fonksiyon.
    {
        if(gameManager.isGameActive) // Eğer oyun aktifse
        {
            Destroy(gameObject); // Mouse tıklandığında gameObject'i yok eder.
            Instantiate(explosionParticle, transform.position, explosionParticle.transform.rotation); // Patlama efektini oluşturur.
            gameManager.UpdateScore(pointValue); // GameManager'daki UpdateScore fonksiyonunu çağırır ve 1 ekler.
        }
    }

    private void OnTriggerEnter(Collider other) // Bir nesne triger özellikli collider'a girdiğinde çalışacak olan fonksiyon. Bunun için nesnelerin ekranı terkettiği yerde isTrigger = true bir nesne yer alır 
    {
        Destroy(gameObject); // Eğer bir nesne collider'a girerse onu yok eder.
        if (!gameObject.CompareTag("Bad")) // Eğer nesne "Bad" tag'ine sahip değilse
        {
            gameManager.GameOver(); // GameManager'daki GameOver fonksiyonunu çağırır.
        }

    }

    Vector3 RandomForce() // Rastgele bir kuvvet oluşturur.
    {
        return Vector3.up * Random.Range(minSpeed, maxSpeed);
    }

    float RandomTorque() // Rastgele bir tork oluşturur.
    {
        return Random.Range(-maxTorque, maxTorque);
    }

    Vector3 RandomSpawnPos() // Rastgele bir konum oluşturur.
    {
        return new Vector3(Random.Range(-xRange, xRange), ySpawnPos);
    }
}

                    </pre>

                    <h2>DiffucltyButton</h2>
                    <pre class="prettyprint ms-0">
using UnityEngine.UI;
using UnityEngine;

public class DiffucltyButton : MonoBehaviour // Zorluk seviyesini ayarladığımız butonlara atadığımız script
{
    private Button button;
    private GameManager gameManager; // GameManager scriptini tanımlıyoruz.

    public int difficulty; // Zorluk seviyesini tanımlıyoruz.
    void Start()
    {
        button = GetComponent&lt;Button>();
        gameManager = GameObject.Find("Game Manager").GetComponent&lt;GameManager>(); // GameManager scriptini buluyoruz.

        button.onClick.AddListener(SetDifficulty); // Butona tıklandığında SetDifficulty fonksiyonunu çağırır.
    }

    void Update()
    {
        
    }
    void SetDifficulty()
    {
        gameManager.StartGame(difficulty); // GameManager'daki StartGame fonksiyonunu çağırır.
    }
}

                    </pre>
                </div>
                <div id="extraChallenges5">
                    <h1>Proje 5 için Daha Fazla Mücadele</h1>
                    <h2>LiveUI</h2>
                    <p>
                        Canvas içinde "Live Text" oluşturuldu ve yerleştirildi. "GameManager" scriptinde değişken olarak eklendi. Game Manager içinde inspectorde ataması yapıldı. "GameManager" scriptinde LiveUpdate() fonksiyonu oluşturuldu ve bu fonksiyon "Target" scriptinde kullanıldı
                    </p>
                    <h3>GameManager</h3>
                    <pre class="prettyprint ms-0">
using System.Collections; 
using System.Collections.Generic; 
using TMPro; 
using UnityEngine.SceneManagement; 
using UnityEngine.UI; 
using UnityEngine;

public class GameManager : MonoBehaviour 
{
    [Header("UI References")] 
    public TextMeshProUGUI scoreText; 
    public TextMeshProUGUI gameOverText; 
    public TextMeshProUGUI liveText; // TextMeshProUGUI kullanarak liveText'i tanımlıyoruz.
    public Button restartButton; 
    public GameObject titleScreen; 

    [Header("Spawn Object References")] 
    public List &lt;GameObject> targets;
    public bool isGameActive; 
    private int score; 
    private int lives; // can değişkeni
    public float spawnRate = 1.0f;

    IEnumerator SpawnTarget() 
    {
        while (isGameActive) 
        {
            yield return new WaitForSeconds(spawnRate);  
            int index = Random.Range(0, targets.Count);
            Instantiate(targets[index]); 
        }
    }

    public void UpdateScore(int scoreToAdd) 
    {
        score += scoreToAdd;
        scoreText.text = "Score: " + score; 
    }
    public void LiveUpdate() // Can güncelleme fonksiyonu
    {
        lives--; // Her can kaybında 1 azaltıyoruz.
        liveText.text = "Lives: " + lives; // Can sayısını güncelliyoruz.
        if (lives &lt;= 0) // Eğer can sayısı 0 veya daha az ise
        {
            GameOver(); // Oyun bitiyor.
            lives = 0; // Can sayısını 0 yapıyoruz.
        }
    }
    public void GameOver() 
    {
        gameOverText.gameObject.SetActive(true); 
        restartButton.gameObject.SetActive(true); 

        isGameActive = false; 
    }

    public void RestartGame() 
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name); 
    }
    public void StartGame(int difficulty) 
    {
        lives = 3; // Oyuna başlarken can sayısını 3 yapıyoruz.
        isGameActive = true; 
        score = 0; 
        spawnRate /= difficulty; 
        titleScreen.gameObject.SetActive(false);

        liveText.text = "Lives: " + lives; // Can sayısını başlatıyoruz.

        StartCoroutine(SpawnTarget()); 
        UpdateScore(0); 
    }
}

                    </pre>
                    <h3>Target</h3>
                    <pre class="prettyprint ms-0">
using UnityEngine;

public class Target : MonoBehaviour 
{
    private Rigidbody targetRb;
    private float minSpeed = 12;
    private float maxSpeed = 16;
    private float maxTorque = 10;
    private float xRange = 4;
    private float ySpawnPos = -6;

    private GameManager gameManager; 

    public int pointValue; 

    public ParticleSystem explosionParticle;
    void Start() 
    {
        targetRb = GetComponent&lt;Rigidbody>();
        
        targetRb.AddForce(RandomForce(), ForceMode.Impulse);
        targetRb.AddTorque(RandomTorque(), RandomTorque(), RandomTorque(), ForceMode.Impulse);

        transform.position = RandomSpawnPos();

        gameManager = GameObject.Find("Game Manager").GetComponent&lt;GameManager>(); 

    }

    private void OnMouseDown() 
    {
        if(gameManager.isGameActive) 
        {
            Destroy(gameObject); 
            Instantiate(explosionParticle, transform.position, explosionParticle.transform.rotation); 
            gameManager.UpdateScore(pointValue); 
        }
    }

    private void OnTriggerEnter(Collider other) 
    {
        Destroy(gameObject); 
        if (!gameObject.CompareTag("Bad")) // buradaki GameOver() fonksiyonunu sildik ve can azalma fonksiyonunu çağırdık. GameOver() fonksiyonu bir şarta bağlanarak LiveUpdate() içinden çağırılıyor.
        {
            gameManager.LiveUpdate(); 
        }

    }

    Vector3 RandomForce() 
    {
        return Vector3.up * Random.Range(minSpeed, maxSpeed);
    }

    float RandomTorque() 
    {
        return Random.Range(-maxTorque, maxTorque);
    }

    Vector3 RandomSpawnPos() 
    {
        return new Vector3(Random.Range(-xRange, xRange), ySpawnPos);
    }
}

                    </pre>
                    <h2>Pause Button</h2>
                    <p>
                        Oyunu duraklatacak bir buton ve duraklatmada gösterilecek bir panel oluşturduk. "GameManager" scriptine aşağıdaki fonksiyonu ekleyip foksiyonu butona atadık.
                    </p>
                    <pre class="prettyprint ms-0">
using System.Collections; 
using System.Collections.Generic; 
using TMPro; 
using UnityEngine.SceneManagement; 
using UnityEngine.UI; 
using UnityEngine;

public class GameManager : MonoBehaviour 
{
    [Header("UI References")] 
    public TextMeshProUGUI scoreText; 
    public TextMeshProUGUI gameOverText; 
    public TextMeshProUGUI liveText; 
    public Button restartButton; 
    public GameObject titleScreen;
    public GameObject pausePanel; // pause paneli için referans

    [Header("Spawn Object References")] 
    public List&lt;GameObject> targets;

    public bool isGameActive = false; 
    private int score; 
    private int lives; 
    public float spawnRate = 1.0f;
    bool isPaused = false; // oyunun duraklatılıp duraklatılmadığını kontrol etmek için bir değişken

    IEnumerator SpawnTarget() 
    {
        while (isGameActive) 
        {
            yield return new WaitForSeconds(spawnRate);  
            int index = Random.Range(0, targets.Count);
            Instantiate(targets[index]); 
        }
    }

    public void UpdateScore(int scoreToAdd) 
    {
        score += scoreToAdd;
        scoreText.text = "Score: " + score; 
    }
    public void LiveUpdate() 
    {
        lives--; 
        liveText.text = "Lives: " + lives; 
        if (lives &lt;= 0) 
        {
            GameOver(); 
            lives = 0; 
        }
    }
    public void GameOver() 
    {
        gameOverText.gameObject.SetActive(true); 
        restartButton.gameObject.SetActive(true); 

        isGameActive = false; 
    }

    public void RestartGame() 
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name); 
    }
    public void StartGame(int difficulty) 
    {
        lives = 3; 
        isGameActive = true; 
        score = 0; 
        spawnRate /= difficulty; 
        titleScreen.gameObject.SetActive(false);

        liveText.text = "Lives: " + lives; 

        StartCoroutine(SpawnTarget()); 
        UpdateScore(0); 
    }

    public void PauseGame()
    {
        if(isGameActive)
        {
            isPaused = !isPaused; // Oyunun duraklatılıp duraklatılmadığını tersine çeviriyoruz.
            if (isPaused)
            {
                Time.timeScale = 0; // Zamanı duraklatıyoruz.
                pausePanel.SetActive(true); // Pause panelini açıyoruz.
            }
            else
            {
                Time.timeScale = 1; // Zamanı devam ettiriyoruz.
                pausePanel.SetActive(false); // Pause panelini kapatıyoruz.
            }
        }
    }
}

                    </pre>
                    <h2>Click and Swipe</h2>
                    <p>
                        Tıklayıp kaydırdığında bir iz bırakan ve temas ettiği hedefleri yok eden fruit ninja tarzı bir yapı için "ClickAndSwipe" adında bir script oluşturduk ve bunu EmtyGameObject oluşturup içine attık.
                    </p>
                    <pre class="prettyprint ms-0">
using UnityEngine;

[RequireComponent(typeof(TrailRenderer), typeof(BoxCollider))] // Bu bileşenin ekli olduğu GameObject'e TrailRenderer ve BoxCollider bileşenlerinin zorunlu olarak eklenmesini sağlar.

public class ClickAndSwipe : MonoBehaviour
{
    private GameManager gameManager;    // GameManager scriptine erişim için bir referans
    private Camera cam;                 // Ana kameraya referans
    private Vector3 mousePos;           // Fare konumunun dünya koordinatındaki karşılığı
    private TrailRenderer trail;        // İz (trail) çizmek için TrailRenderer bileşeni
    private BoxCollider col;            // Çarpışmaları algılamak için BoxCollider bileşeni

    private bool swiping = false;       // Kullanıcının şu anda sürükleme yapıp yapmadığını tutar

    void Awake()
    {
        cam = Camera.main; // Ana kamerayı bulur ve referansa atar
        trail = GetComponent&lt;TrailRenderer>(); // Aynı GameObject'teki TrailRenderer bileşenini alır
        col = GetComponent&lt;BoxCollider>();     // Aynı GameObject'teki BoxCollider bileşenini alır

        trail.enabled = false; // Başlangıçta iz çizilmesin
        col.enabled = false;   // Başlangıçta çarpışma olmasın

        gameManager = GameObject.Find("Game Manager").GetComponent&lt;GameManager>(); // "Game Manager" isimli GameObject'i bulup içindeki GameManager scriptine erişir
    }

    void UpdateMousePosition() // Fare pozisyonunu dünya koordinatlarına çevirip GameObject'in pozisyonunu günceller
    {
        mousePos = cam.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, 10f)); // Fare pozisyonu ekran koordinatlarında. Kamera z= -10f olduğundan bunu 10f derinliğe sahip dünya koordinatına çeviriyoruz.
        transform.position = mousePos; // GameObject'in pozisyonu fare konumuna ayarlanıyor
    }

    void UpdateComponents() // TrailRenderer ve BoxCollider bileşenlerini swiping durumuna göre aktif/pasif yapar
    {
        trail.enabled = swiping; // Eğer swiping true ise trail çizilir
        col.enabled = swiping;   // Eğer swiping true ise collider aktif olur
    }

    void Update()
    {
        if(gameManager) // Eğer gameManager referansı varsa çalışmaya devam eder
        {
            if (Input.GetMouseButtonDown(0)) // Sol fare tuşuna basıldıysa
            {
                swiping = true;     // Sürükleme başlatılır
                UpdateComponents(); // Bileşenler aktif hale getirilir
            }
            else if (Input.GetMouseButtonUp(0)) // Sol fare tuşu bırakıldıysa
            {
                swiping = false;    // Sürükleme durdurulur
                UpdateComponents(); // Bileşenler pasif hale getirilir
            }

            if(swiping) // Eğer sürükleme devam ediyorsa pozisyon güncellenir
            {
                UpdateMousePosition(); // Fare konumuna göre nesne konumu güncellenir
            }
        }   
    }

    private void OnCollisionEnter(Collision collision) // Başka bir nesneyle çarpışma gerçekleştiğinde çalışır
    {
        // Eğer çarpılan nesnenin tag'i "Target" ya da "Bad" ise:
        if(collision.gameObject.CompareTag("Target") || collision.gameObject.CompareTag("Bad"))
        {
            // O nesnenin Target scriptine ulaşıp yok etme fonksiyonunu çağırır
            collision.gameObject.GetComponent&lt;Target>().DestroyTarget();
        }
    }
}

                    </pre>
                    <p>
                        Kodu eklediğimiz EmptyGameObject seçiliyken inspectorde BoxCollider ve TrailRenderer içinde ayarlar değiştirilir.
                    </p>
                </div>
            </div>
            <div id="6">
                <div id="optimization">
                    <h1>Proje Optimizasyonu</h1>
                    <p>
                        Değişkenler ve event fonksiyonlar için <a href="https://chatgpt.com/share/68234f7d-0fa8-8004-b5e5-5206fb73da30">referans chatgpt konuşması</a>
                    </p>
                    <h2>Nesne Havuzu</h2>
                    <p>
                        Tekrar tekrak kullanılacak mermi vs nesneler için Object Pooling diye bir teknik kullanılabilir. Bunun için önce prefabı ve prefabdan oluşturulan nesneleri de tutan bir fonksiyon oluşturulur ve sahnede çağırılması için bir gameobjecte atanır.
                        <pre class="prettyprint ms-0">
using System.Collections.Generic;
using UnityEngine;

// Bu sınıf bir nesne havuzu (object pool) yöneticisi olarak kullanılacak
public class ObjectPool : MonoBehaviour
{
    // Singleton mantığıyla tek bir örneğe erişmek için static değişken tanımlanır
    public static ObjectPool SharedInstance;

    // Havuzda tutulacak (hazır bekletilecek) GameObject listesidir
    public List&lt;GameObject> pooledObjects;

    // Havuzda üretilecek olan prefab (örn: mermi prefabı)
    public GameObject objectToPool;

    // Havuzda başlangıçta kaç tane nesne üretileceğini belirler
    public int amountToPool;

    // Awake() fonksiyonu, script aktif olduğunda Start'tan önce çalışır
    void Awake()
    {
        // Bu sınıfın örneğini static olarak saklıyoruz (Singleton gibi)
        SharedInstance = this;
    }

    // Start() fonksiyonu oyun başladığında bir kez çalışır
    void Start()
    {
        // Boş bir liste oluşturuyoruz
        pooledObjects = new List&lt;GameObject>();

        GameObject tmp;

        // Belirtilen sayıda nesneyi havuzda oluşturuyoruz
        for (int i = 0; i &lt; amountToPool; i++)
        {
            // Prefab'den bir nesne oluştur
            tmp = Instantiate(objectToPool);

            // Şimdilik bu nesneyi sahnede aktif etme (gizli tut)
            tmp.SetActive(false);

            // Havuz listesine ekle
            pooledObjects.Add(tmp);
        }
    }

    public GameObject GetPooledObject()
    {
        // Havuzda aktif olmayan bir nesne bul
        for (int i = 0; i &lt; pooledObjects.Count; i++)
        {
            // Eğer nesne aktif değilse, onu döndür
            if (!pooledObjects[i].activeInHierarchy)
            {
                return pooledObjects[i];
            }
        }
        // Eğer havuzda aktif olmayan bir nesne yoksa, null döndür
        return null;
    }
}


                        </pre>
                    </p>
                    <p>
                        Daha sonra ateş etme fonksiyonu olarak Instantiate(...) yerine:
                        <pre class="prettyprint ms-0">
...
    {
        GameObject bullet = ObjectPool.SharedInstance.GetPooledObject(); //ObjectPool'dan bir nesne alır
        bullet.transform.position = transform.position; //Nesnenin pozisyonunu oyuncunun pozisyonuna ayarlar
        bullet.transform.rotation = transform.rotation; //Nesnenin rotasını oyuncunun rotasına ayarlar
        bullet.SetActive(true); //Nesneyi aktif hale getirir
    }
...
                        </pre>
                        Destroy() ile nesne yok etmek yerine de:
                        <pre class="prettyprint ms-0">
...
    gameObject.SetActive(false);
...
                        </pre>
                        kodları kullanılır. Herhangi bir şekilde nesne havuzunda oluşturulan ve kullanılan nesnelerden silinen olursa kod hata verir.
                    </p>
                </div>
            </div>
            <div id="7">
                <div id="dataManage">
                    <h1>Data Kalıcılığı</h1>
                    <p>
                        Data kalıcılığı için iki ayrı senaryo için iki farklı metot kullandık. İlk metot datanın scene değiştiğinde de varlığını koruması için kullanıldı. "Singleton" olarak adlandırılan bu metotta bir gameobject oluşturduk. Bu nesneyi DontDestroyOnLoad() metotu ile scene değişikliklerinde de korunur hale getirdik. Bu sayede nesnede yer alan data korunmuş oldu. "static" özelliği de değişkenin içeriğinin sınıf üzerinden doğrudan ulaşılabilmesini sağladı.
                        <pre class="prettyprint ms-0">
using UnityEngine;
using System.IO; // File işlemleri için gerekli

public class MainManager : MonoBehaviour
{
    public static MainManager Instance; // static niteliği verinin dışarıdan erişilmesini sağlar.
    public Color TeamColor;

    private void Awake()
    {
        // Singleton pattern: Bu sınıfın tek bir örneği olmasını sağlar
        if (Instance != null) 
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject); // nesnenin sayfa geçişlerinde silinmesini engeller.
    }
}
                        </pre>
                    </p>
                    <p>
                        Verimizin proje kapatıldığında da saklanabilmesi için veri JSON formatına çevirilip bir dosyaya kaydedilir. Bu şekilde saklanabilmesi için verinin bir kalıbının (class) oluşturulması gerelir. Verinin JSONa çevirilebilmesi için class kalıbının [System.Serializable] ön eki ile serializable yapılması gerekir.
                        <pre class="prettyprint ms-0">
...
 [System.Serializable] // Bu sınıfın JSON formatında serileştirilmesini sağlar
 class SaveData // Veri kaydetmek için kullanılacak sınıf
 {
     public Color TeamColor;
 }

 public void SaveColor() // Rengi kaydetmek için kullanılacak fonksiyon
 {
     SaveData data = new SaveData(); // Yeni bir veri nesnesi oluştur
     data.TeamColor = TeamColor; // Rengi ata

     string json = JsonUtility.ToJson(data); // Veriyi JSON formatına çevir

     File.WriteAllText(Application.persistentDataPath + "/savefile.json", json); // Veriyi dosyaya kaydet
 }

 public void LoadColor() // Rengi yüklemek için kullanılacak fonksiyon
 {
     string path = Application.persistentDataPath + "/savefile.json"; // Dosya yolu
     if (File.Exists(path)) // Dosya var mı kontrol et
     {
         string json = File.ReadAllText(path); // Dosyadan veriyi oku
         SaveData data = JsonUtility.FromJson&lt;SaveData>(json); // JSON formatından nesneye çevir

         TeamColor = data.TeamColor; // Rengi ayarla
     }
 }
 ...
                        </pre>
                    </p>
                </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>