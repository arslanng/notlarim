<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Development</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">Deployment</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          <li><a class="dropdown-item" href="GraphQL.html" target="_blank">GraphQL</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#install">Unity ve Visual Studio Kurulumu</a>
                  <a class="nav-link" href="#firstProject">Unity Hub ve İlk Proje</a>
                  <a class="nav-link" href="#interface">Arayüz</a>
                  <a class="nav-link" href="#sceneTab">Scene Ekranı</a>
                  <a class="nav-link" href="#gameTab">Game Sekmesi</a>
                  <a class="nav-link" href="#assetStore">Asset Store</a>
                  <a class="nav-link" href="#programing">Programlamaya Giriş</a>
                  <a class="nav-link" href="#firstScript">İlk Scriptimiz</a>
                  <a class="nav-link" href="#variables">Değişkenler</a>
                  <a class="nav-link" href="#publicAndPrivateVariables">Public ve Private Değişken Tanımlama</a>
                  <a class="nav-link" href="#ifElse">If - Else</a>
                  <a class="nav-link" href="#arithmetic">Aritmetik İşlemler</a>
                  <a class="nav-link" href="#logic">logic operators</a>
                  <a class="nav-link" href="#relational">İlişkisel Operatörler</a>
                  <a class="nav-link" href="#incrementDecrement">Artım Azaltım Özel Operatörleri</a>
                  <a class="nav-link" href="#switchCase">switch case</a>
                  <a class="nav-link" href="#while">while</a>
                  <a class="nav-link" href="#for">for</a>
                  <a class="nav-link" href="#functions">Fonksiyonlar</a>
                  <a class="nav-link" href="#specialFunctions">Özel Fonksiyonlar</a>
                  <a class="nav-link" href="#lists">Listeler</a>
                  <a class="nav-link" href="#arrayList">ArrayList</a>
                  <a class="nav-link" href="#enterComponents">Componentlere Giriş</a>
                  <a class="nav-link" href="#collisionAndRigitbody">Collision ve Rigidbody</a>
                  <a class="nav-link" href="#light">Light</a>
                  <a class="nav-link" href="#camera">Camera</a>
                  <a class="nav-link" href="#controlComponentByScript">Script ile Component Kontrolü</a>
                  <a class="nav-link" href="#controlScriptByScript">Script ile Başka Script Kontrolü</a>
                  <a class="nav-link" href="#componentsAreVariables">Her Komponent Bir Değişken Türüdür</a>
                  <a class="nav-link" href="#bounds">Bounds - (Box Collider)</a>
                  <a class="nav-link" href="#vectors">Vektörler</a>
                  <a class="nav-link" href="#rigitbody">Rigitbody</a>
                  <a class="nav-link" href="#transform">Transform</a>
                  <a class="nav-link" href="#trailRenderer">Trail Renderer</a>
                  <a class="nav-link" href="#meshRender">Mesh Render</a>
                  <a class="nav-link" href="#inputGetKeyInputGetMouseButton">Input.GetKey & Input.GetMouseButton</a>
                  <a class="nav-link" href="#inputGetAxis">Input.GetAxis</a>
                  <a class="nav-link" href="#findGameObjectWithTag">Tag ile Obje Bulma</a>
                  <a class="nav-link" href="#gameObjectFind">Find ile Obje Bulma</a>
                  <a class="nav-link" href="#layers">Layers</a>
                  <a class="nav-link" href="#deltaTime">Time.deltaTime & Time.fixedDeltaTime</a>
                  <a class="nav-link" href="#drawRay">DrawRay</a>
                  <a class="nav-link" href="#physicsRaycast">Physics.Raycast</a>
                  <a class="nav-link" href="#physicsCheckSphere">Physics.CheckSphere</a>
                  <a class="nav-link" href="#onCollisionEnterOnTriggerEnter">OnCollisionEnter & OnTriggerEnter</a>
                  <a class="nav-link" href="#flipFlop">Flip-Flop</a>
                  <a class="nav-link" href="#moveByInput">Objeyi Input ile Hareket Ettirme</a>
                  <a class="nav-link" href="#cameraController">Kamera Kontrolü</a>
                  <a class="nav-link" href="#moveByInputUpdate">Yönleri Güncellemek</a>
                  <a class="nav-link" href="#shootAndKill">Ateş Etme</a>
                  <a class="nav-link" href="#intoTheBlender">Blender Giriş</a>
                  <a class="nav-link" href="#moveRotateScale">Move, Rotate, Scale</a>
                  <a class="nav-link" href="#editModeAndBevelEdges">Edit Mode ve Bevel Edges</a>
                  <a class="nav-link" href="#editGeometricObject">Geometrik Objelerin Detaylandırılması</a>
                  <a class="nav-link" href="#extrudeRegion">Extrude Region</a>
                  <a class="nav-link" href="#originTo3dCursor">Ağırlık Merkezi ve Cursor Yerini Değiştirme</a>
                  <a class="nav-link" href="#mirroring">Mirror İşlemi</a>
                  <a class="nav-link" href="#woodenBox">Ahşap Sandık Projesi Notları</a>
                  <a class="nav-link" href="#hafta6textures">Textures</a>
                  <a class="nav-link" href="#intoCanvas">Canvas</a>
                  <a class="nav-link" href="#UIImage">Image</a>
                  <a class="nav-link" href="#UIButton">Buton</a>
                  <a class="nav-link" href="#UISlider">Slider</a>
                  <a class="nav-link" href="#UIToggle">Toggle</a>
                  <a class="nav-link" href="#UIInputField">InputField</a>
                  <a class="nav-link" href="#UIDropdown">Dropdown</a>
                  <a class="nav-link" href="#UITextMeshPro">TextMeshPro</a>
                  <a class="nav-link" href="#UIPanel">Panel</a>
                  <a class="nav-link" href="#UIScripts">Script ile UI Elemanlarına Ulaşmak</a>
                  <a class="nav-link" href="#intoAnimations">Animasyon Giriş</a>
                  <a class="nav-link" href="#mixamo">Mixamo</a>
                  <a class="nav-link" href="#animator">Animator</a>
                  <a class="nav-link" href="#animationControlByScripts">Script ile Kontrol</a>
                  <a class="nav-link" href="#cinemachine">Cinemachine</a>
                  <a class="nav-link" href="#joystickAndAndroid">Joystik ve Android Çıktı Alma</a>
                  <a class="nav-link" href="#playerPrefs">PlayerPrefs</a>
                  <a class="nav-link" href="#projeLabirent">Labirent</a>
                  <a class="nav-link" href="#audioSourceAudioListener">AudioSource ve AudioListener</a>
                  <a class="nav-link" href="#audioPlayer">Player</a>
                  <a class="nav-link" href="#audioFootsteps">Adım Sesleri</a>
                  <a class="nav-link" href="#audioReverbZone">Yankı Oluşturma</a>
                  <a class="nav-link" href="#audioDopplerEffect">Doppler Effect</a>
                  <a class="nav-link" href="#audioDistance">Mesafeye Göre Ses İşlemleri</a>
                  <a class="nav-link" href="#musicZone">Music Zone</a>
                  <a class="nav-link" href="#audioMixer">AudioMixer</a>
                  <a class="nav-link" href="#audioControl">Ses Kontrol</a>
                  <a class="nav-link" href="#ar">Artırılmış Gerçeklik</a>
                  <a class="nav-link" href="#arAdroidSettings">AR Android Ayarları</a>
                  <a class="nav-link" href="#arPlaneManagement">Zemin Tespiti</a>
                  <a class="nav-link" href="#arPlacementIndicator">Placement Indicator Oluşturma</a>
                  <a class="nav-link" href="#arAddObject">Ortama Objenin Eklenmesi</a>
                  <a class="nav-link" href="#faydaliSayfalar">Faydalı Sayfalar (Asset)</a>
                  <a class="nav-link" href="#arFaceManager">Yüz Algılama</a>
                  <a class="nav-link" href="#arTrackedImageManager">Resim Algılamaa</a>
                  <a class="nav-link" href="#patikaBlender">Patika.dev Blender notları</a>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div id="1">
              <div id="install">
                <h1>Unity ve Visual Studio Kurulumu</h1>
                <p>
                  Önce Unity hub kuruldu. Ardından unity hub içinden unity 2021.3.22f kuruldu (hoca ile uyumlu olması için). Unity hub üzerinden kurulamadı. Unity hub ile <a href="https://unity.com/releases/editor/archive">archive</a> açılıp manuel kuruldu.
                  <ul>
                    <li>Microsoft Visual Studio Comminity 2022</li>
                    <li>Android Build Support</li>
                    <li>WebGL Build Support</li>
                    <li>Windows Build Support</li>
                    <li>Windows Dedicated Server Build Support</li>
                    <li>Documantation</li>
                  </ul>
                </p>
              </div>
              <div id="firstProject">
                <h1>Unity Hub ve İlk Proje</h1>
                <p>
                  Unity Hub > New Project 
                </p>
                <p>
                  İlk proje için template alanından 3D Core seçildi ve proje adı ve proje yeri gösterildi. "Create Project" denilerek ilk proje yaratıldı.
                </p>
                <p>
                  Projemizi açtıktan sonra edit>preferences>external tools segmesi içinde external script editor: microsoft visual studio seçilir.
                </p>
              </div>
              <div id="interface">
                <h1>Arayüz</h1>
                <p>
                  Kısayol: Duplicate: Ctrl + D
                </p>
                <p>
                  Kısayol: Focus: F + Left Click (Hierarchy)
                </p>
                <p>
                  Ekran Kısayolları
                  <ul>
                    <li>"W": move</li>
                    <li>"E": rotate</li>
                    <li>"R": skale</li>
                  </ul>
                </p>
                <p>
                  Yaptığımız bir tasarımı alttaki asset menüsünden prefabs (hazır kalıp) olarak ekleyebiliriz. Bunun için asset>new>folder (dosya adı: prefabs) ile dosya oluşturup bu dosyayı açıp hazır şeklimizi içine sürükleyip bıraktık. 
                </p>
                <p>
                  Sesler için "Sounds", kaplamalar için "Textures", kodlar için "Scripts" vs klasörler Assets altına açılır.
                </p>
                <p>
                  Right Click basılı iken "WASD" ile ekranda gezinilebilir. "Q" ve "E" ile de yukarı - aşağı hareket edilebilir.
                </p>
                <p>
                  Console: hataların ve bizim istediğimiz durumların sonucunun bildirildiği kısım.
                </p>
                <p>
                  File>Build Settings altından uygulama build edilebilir.
                </p>
              </div>
              <div id="sceneTab">
                <h1>Scene Ekranı</h1>
                <p>
                  Scene ekranında üstteki menüyü inceliyoruz.
                </p>
                <p>
                  Birden fazla objeyi seçtiğimiz bir senaryoda "center" seçili ise grubun ağırlık merkezine göre işlem yapılır ve bütün grup tek nesne gibi davranır. "pivot" seçili ise her nesne kendi içinde hareket eder.
                </p>
                <p>
                  ikici sembolde "local" seçili ise eksenler objeye göre verilir. "global" seçili ise eksenler sahneye göre verilir.
                </p>
                <p>
                  Üçüncü sembol rehber grid yapısını ayarlar
                </p>
                <p>
                  ekranın sağındakiler görünümler ile ilgi.
                </p>
              </div>
              <div id="gameTab">
                <h1>Game Sekmesi</h1>
                <p>
                  Game sekmesi uygulamanın nasıl göründüğü konusunda bize yardımcı olur.
                </p>
                <p>
                  İlk segme "Game/Simılator" kısmı. Simulator mobil cihazlarda sahnenin nasıl görüneceği konusunda bilgi verir. "Simulator" kısmında "safe area" çeltikli telefonlarda hangi alanın aktif kullanılabileceğini gösterir.
                </p>
              </div>
              <div id="assetStore">
                <h1>Asset Store</h1>
                <p>
                  "window" > "asset store" > "search online"
                </p>
                <p>
                  Gelen sayfadan istenilen asset seçilir ve alınır. Sonra "Open in unity" ile unity paket yöneticisinde açılır. İndirilir ve import edilir. Gelen paket "Asset" içinde görüntülenir.
                </p>
              </div>
            </div>
            <div id="2">
              <div id="programing">
                <h1>Programlamaya Giriş</h1>
                <p>
                  Unity içinde C# .NET programlama dili kullanılır
                </p>
                <p>
                  Projemizin içinde asset kısmında sağ click > "create" > "folder" ile adı "Scripts" olan bir klasör oluşturulur. Klasörün içinde sağ click > "create" "c script" ile adı "HelloWorld" olan dosya oluşturulur. 
                </p>
                <p> Visual Studio aracılığı ile açılan kod:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine; // Bu kısım kütüphaneleri import ettiğimiz kısım.
  
  public class HelloWorld : MonoBehaviour // Dosya ismi ile class ismi aynı olmalı. "MonoBehaivor" klasından kalıtım alınmış.
  {
      // kod ilk çağırıldığında ilk çelışan fonksiyon
      void Start() 
      {
          print("selamlar");
      }
  
      // Her frame değiştiğinde çalışır.
      void Update() 
      {
          
      }
  }
  
  // c# içinde her kod ";" ile bitirilir. Kod yukarıdan aşağı okunur.
                  </pre>
                </p>
                
              </div>
              <div id="firstScript">
                <h1>İlk Scriptimiz</h1>
                <p>
                  Boş proje alanına bir küp bir de küre oluşturduk.
                </p>
                <p>
                  Daha önce yazdığımız scripti eklemek için eklemek istediğimiz nesne seçiliyken kod asset alanından sürükle bırak ile "Inspector" ekranının en altına bırakılabilir. Veya "Inspector" ekranında "Add component" tıklanarak eklenebilir.
                </p>
                <p>
                  Scripti ayırmak için "Inspector" ekranında bulup en sonundaki üç noktadan "remove component" tıklanır.
                </p>
                <p>
                  Script bir nesneyi değil de ortamı ilgilendiriyorsa "Hierarchy" ekranında "Create empty" seçilir ve script ona eklenir.
                </p>
                <p>
                  Scriptimizin son hali
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine; 
  
  public class HelloWorld : MonoBehaviour 
  {
      // Start is called before the first frame update
      void Start() 
      {
          print("start blogunda calisti"); // start aninda "start blogunda calisti" ibaresi konsola yazdirilir
      }
  
      // Update is called once per frame
      void Update() 
      {
          print("Update bloğunda çalıştı"); // her framede "Update bloğunda çalıştı" ibaresi konsola yazdırılır.
      }
  }
                  </pre>
                </p>
              </div>
              <div id="variables">
                <h1>Değişkenler</h1>
                <p>Değişkenler notları
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine; 
  
  public class HelloWorld : MonoBehaviour 
  {
      //int: tam sayı
      int canSayisi = 4;
      int gold = -2;
      //float: virgüllü sayılar
      float ates = 38.9f;
      //string
      string oyuncuAdi = "Murat";
      string tc_no = "216343216215";
      //bool: boolean
      bool canli_mi = true;//false
  
      // Start is called before the first frame update
      void Start() 
      {
          
      }
  
      // Update is called once per frame
      void Update() 
      {
          
      }
  }
                  </pre>
                </p>
                <p>Örnek
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine; 
  
  public class HelloWorld : MonoBehaviour 
  {
      // Burada oluşturulan değişkenler void Start() ve void Update() altında kullanılabilir.
      int can;
      int ilave_can;
      int son_can;
      float sicaklik;
      bool oyun_bitti_mi = false;
      void Start()
  
      // Start is called before the first frame 
      {// Burada oluşturulan değişkenler sadece void Start() altında kullanılabilir
          can = 10;
          ilave_can = 3;
          sicaklik = 28.2f;
      }
  
      // Update is called once per frame
      void Update() 
      {
          son_can = can + ilave_can;
          print(son_can);
          print(sicaklik);
          print(oyun_bitti_mi);
      }
  }
                  </pre>
                </p>
              </div>
              <div id="publicAndPrivateVariables">
                <h1>Public ve Private Değişken Tanımlama</h1>
                <p>
                  public değişkenlere dışarıdan erişilebilir. private değişkenlere dışarıdan erişilemez.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine; 
  
  public class HelloWorld : MonoBehaviour 
  {
      // Başında public olan değişkenler unityde "Inspector" alanında görünür ve play sırasında değiştirilebilir.
      public int can;
      public int ilave_can;
      // başında private olanlara dışarıdan ulaşılamaz. Varsayılan olarak tüm değerler private olarak gelir.
      private int son_can;
      float sicaklik;
      bool oyun_bitti_mi = false;
  
      // Start is called before the first frame 
      void Start()
      {
          can = 10;
          ilave_can = 3;
          sicaklik = 28.2f;
      }
  
      // Update is called once per frame
      void Update() 
      {
          son_can = can + ilave_can;
          print(son_can);
          print(sicaklik);
          print(oyun_bitti_mi);
      }
  }
                  </pre>
                </p>
              </div>
              <div id="ifElse">
                <h1>If - Else</h1>
                <p>
                  if (&lt;şart>) { &lt;şart true ise çalışacak fonksiyon>}
                </p>
                <p>
                  Örnek
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine; 
  
  public class HelloWorld : MonoBehaviour 
  {
      public int can;
  
      // Start is called before the first frame 
      void Start()
      {
          can = 5;        
      }
  
      // Update is called once per frame
      void Update() 
      {
          if (can > 0)
          {
              print("Oyun devam ediiyor");
          }
          else
          {
              print("Oyun bitti");
          }
      }
  }
                  </pre>
                </p>
                <p>
                  Birden fazla koşul aynı anda yürütülebilir.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int can;
  
      // Start is called before the first frame 
      void Start()
      {
          can = 5;
      }
  
      // Update is called once per frame
      void Update()
      {
          //Durum 1
          if (can > 3)
          {
              print("Oyun devam ediiyor");
          }
          else if (can == 3)
          {
              print("3 cana özel 2 puan");
          }
          else if (can > 0)
          {
              print("0-3 arası özel durum");
          }
          else
          {
              print("Oyun bitti");
          }
  
          //Durum 2
          if(can == 5)
          {
              print("--Can 5 e özel durum--");
          } 
          else
          {
              print("--Özel Durum Yok--");
          }
      }
  }
  
  
                  </pre>
                </p>
              </div>
              <div id="arithmetic">
                <h1>Aritmetik İşlemler</h1>
                <p>
                  Örnek
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int sayi1, sayi2, toplam, fark, carpim, kalan; //aynı karakterdeki birden fazla değişken bu şekilde tanımlanabilir.
      public float bolum; // bölüm sonucu tam sayı bile olsa değer float olarak tanımlanır.
  
      // Start is called before the first frame 
      void Start()
      {
          sayi1 = 10;
          sayi2 = 20;
      }
  
      // Update is called once per frame
      void Update()
      {
          toplam = sayi1 + sayi2;
          fark = sayi1 - sayi2;
          carpim = sayi1 * sayi2;
          bolum = (float)sayi1 / sayi2;
          kalan = sayi1 % sayi2;
  
          print(sayi1 + " ile " + sayi2 + "'nin toplamı: " + toplam);
          print(sayi1 + " ile " + sayi2 + "'nin farkı: " + fark);
          print(sayi1 + " ile " + sayi2 + "'nin çarpımı: " + carpim);
          print(sayi1 + " ile " + sayi2 + "'nin bölümü: " + bolum + " kalanı ise: " + kalan);
  
      }
  }
  
  
                  </pre>
                </p>
              </div>
              <div id="logic">
                <h1>logic operators</h1>
                <p>"&&" = ve, "||" = veya</p>
                <p>"!" işareti bir önermenin sonucu true ise false'a false ise true'ya çevirir.</p>
                <p>Örnek:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int sayi1, sayi2;
      public string isim;
      public bool evliMi;
  
      // Start is called before the first frame 
      void Start()
      {
          sayi1 = 10;
          sayi2 = 20;
          isim = "Murat";
          evliMi = false;
      }
  
      // Update is called once per frame
      void Update()
      {
          // ve logic mantık örneği
          if(sayi1 &lt; sayi2 && !(isim == "Murat")) // sim önermesinden çıkan değer "!" ile tersine çevirildi
          {
              print("sayi1 sayi2 den küçük ve isim Murat değil");
          }
          else
          {
              print("iki önermeden biri yanlış veya ikisi de yanlış");
          }
          // veya logic mantık örneği
          if (sayi1 &lt; sayi2 || isim != "Murat") // isim önermesi eşit değil şeklinde sorgulandı
          {
              print("___sayi1 sayi2 den küçük veya isim Murat değil");
          }
          else
          {
              print("___iki önermeden ikisi de yanlış");
          }
  
          if(!evliMi)
          {
              print("Bekar");
          }
          else
          {
              print("Evli");
          }
      }
  }
  
  
                  </pre>
                </p>
              </div>
              <div id="relational">
                <h1>İlişkisel Operatörler</h1>
                <ul>
                  <li><b>==</b> eşittir</li>
                  <li><b>&lt;</b> küçüktür</li>
                  <li><b>&lt;=</b> küçük veya eşittir</li>
                  <li>></b> büyüktür</li>
                  <li>>=</b> büyük veya eşittir</li>
                </ul>
                <p>Örnek:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int sayi1, sayi2;
  
      // Start is called before the first frame 
      void Start()
      {
          sayi1 = 10;
          sayi2 = 20;
      }
  
      // Update is called once per frame
      void Update()
      {
          if (sayi1 &lt;= sayi2)
          {
              print("Ok");
          }
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="incrementDecrement">
                <h1>Artım Azaltım Özel Operatörleri</h1>
                <p>
                  Örnekler:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int sayi1, sayi2;
  
      // Start is called before the first frame 
      void Start()
      {
          sayi1 = 10;
          print(sayi1++); // önce sayi1 yaz sonra arttır (10)
          print(++sayi1); // önce arttır sonra yazdır. (12)
          print(sayi1--); // önce yaz sonra azalt (12)
          print(--sayi1); // önce azalt sonra yaz (10)
          sayi1 = sayi1 + 1; // sayi1++ veya sayi1+=1
          sayi1 = sayi1 + 3;// sayi1+=3
          print(sayi1); //(14)
          sayi1 *= 2; //sayi1 = sayi1*2
          print(sayi1); //(28)
          sayi1 /= 4; //Bölmede int veri tipinde küsürleri atar.
          print(sayi1); //(7)
          sayi1 %= 2;
          print(sayi1); //(1)
      }
  
      // Update is called once per frame
      void Update()
      {
         
      }
  }
                  </pre>
                </p>
              </div>
              <div id="switchCase">
                <h1>switch case</h1>
                <p>
                  Birden fazla koşulun sınandığı durumlarda if - else yerine kullanılabilir.
                </p>
                <p>
                  Örnek:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int sayi;
  
      // Start is called before the first frame 
      void Start()
      {
          sayi = 7;
      }
  
      // Update is called once per frame
      void Update()
      {
          int sonuc = sayi % 5;
          switch(sonuc)
          {
              case 0:
                  print("kalan 0");
                  break;
              case 1:
                  print("kalan 1");
                  break;
              case 2:
                  print("kalan 2");
                  break;
              default: // üstteki durumlar dışında kalan her durum için
                  print("default durum");
                  break;
          }
      }
  }
                  </pre>
                </p>
              </div>
              <div id="while">
                <h1>while</h1>
                <p>
                  while (&lt;şart>) {&lt;şart sürdüğü sürece tekrarlanacak fonksiyon>}
                </p>
                <p>
                  Örnek:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      public int sayi;
  
      // Start is called before the first frame 
      void Start()
      {
          sayi = 10;
          while (sayi > 0)
          {
              print("sayi :" + sayi); // 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
              sayi--;
          } 
          print("sayının son değeri :" + sayi); // 0
      }
  
      // Update is called once per frame
      void Update()
      {
         
      }
  }
                  </pre>
                </p>
              </div>
              <div id="for">
                <h1>for</h1>
                <p>
                  for genelde belirli bir sayıda aynı işlemin tekrarlanması için kullanılır.
                </p>
                <p>
                  Örnek:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      // Start is called before the first frame 
      void Start()
      {
          for(int i = 10; i>0; i--) //i'ye atanan 10 değeri her turda 1 azaltılır. i>0 şartına uyulduğu sürece işlem tekrarlanır.
          {
              print("i değeri : " + i); // 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
          }
      }
  
      // Update is called once per frame
      void Update()
      {
         
      }
  }
                  </pre>
                </p>
              </div>
              <div id="functions">
                <h1>Fonksiyonlar</h1>
                <p>
                  void &lt;fonksiyonAdi> (&lt;alınan parametre>) {&lt;uygulanacak fonksiyon>}
                </p>
                <p>
                  Fonsiyon aşağı da yazılsa yukarıda çağırılabilir.
                </p>
                <p>
                  Örnek 1:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      // Start is called before the first frame 
      void Start()
      {
          benimFonksiyon(100, 7); // bizim tanımladığımız fonksiyonun kullanımı
      }
  
      // Update is called once per frame
      void Update()
      {
         
      }
  
      void benimFonksiyon(int a, int b) // bizim tanımladığımız fonksiyon
      {
          print("Yazı 1");
          print("Görev 1");
          for(int i = a; i>0; i--)
          {
              print(i + " x " + b + " = " + i*b);
          }
      }
  }
                  </pre>
                </p>
                <p>
                  Örnek 2
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      // Start is called before the first frame 
      void Start()
      {
          selamla("Ayla", true); // bizim tanımladığımız fonksiyonun kullanımı (Merhaba Ayla Hanım)
          selamla("Murat", false); // (Merhaba Murat Bey)
          selamlama();
      }
  
      // Update is called once per frame
      void Update()
      {
         
      }
      void selamlama()
      {
          print("Merhaba");
      }
      void selamla(string isim, bool cinsiyet)
      {
          if(cinsiyet)
          {
              print("Merhaba " + isim + " Hanım");
          }
          else
          {
              print("Merhaba " + isim + " Bey");
          }
      }
  }
                  </pre>
                </p>
                <p>
                  Sonucu bir değişkene atanan fonksiyon örneği:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      // Start is called before the first frame 
      void Start()
      {
          int toplam1 = Topla(22, 33); // fonksiyondan alınan değeri değişkene atadık
          string selamMesaji = Selamla("Ayla");
          int toplam2 = Topla(44, toplam1);
          print(selamMesaji + "toplam sonuç: " + toplam2);
      }
  
      // Update is called once per frame
      void Update()
      {
         
      }
      int Topla(int sayi1, int sayi2)
      {
          int sonuc = sayi1 + sayi2;
          return sonuc;
      }
      int Cikar(int sayi1, int sayi2)
      {
          return sayi1 - sayi2;
      }
      string Selamla(string name)
      {
          return "Merhaba " + name + " ";
      }
  }
                  </pre>
                </p>
              </div>
              <div id="specialFunctions">
                <h1>Özel Fonksiyonlar</h1>
                <p>
                  Bu fonksiyonlar unity ile gelen "MonoBehavior" klasında tanımlıdır.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      int sayi1;
      private void Awake() // starttan önce yapılacak işlemler buraya eklenir.
      {
          
      }
      private void Start() // Start is called before the first frame 
      {
          
      }
      private void Update() // her framede çalışır. fps(saniyedeki frame sayısı) değiştikçe yapılma sıklığı değişir.
      {
         
      }
      private void FixedUpdate() // saniyede 60 kere çalışır.
      {
          
      }
      private void LateUpdate() // her framede çalışır ama biraz gecikmeli çalışır.
      {
          
      }
  }
                  </pre>
                </p>
              </div>
              <div id="lists">
                <h1>Listeler</h1>
                <p>
                  Bu liste yapısı sabit kalacak listeler için kullanışlıdır. Ekleme çıkarma vs yapılacak dinamik listeler için aşağıdaki ArrayList yapısı daha uygundur.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      float[] /*"[]" bu yapının liste olduğunu belirtir.*/ liste = {2f, 2.5f, 11f, 11.5f }; //c# yapısında liste tek tip elemanla kurgulanır.
  
      private void Start() // Start is called before the first frame 
      {
          liste[0] = 22.4f; /* listenin ilk elemanı olan index 0 elemanı güncelledik */
          print(liste[0]); // ilk elemanı yazdırır (22.4)
          string listeString = "";
          foreach(float eleman /* "eleman" bizim liste elemanlarına atadığımız isim */ in liste /* "liste" daha önce oluşturduğumuz array yapımız */) 
          {
              listeString += " " + eleman; // liste elemanları string olarak düzenlendi
          }
          print(listeString); // (22.4 2.5 11 11.5)
      }
  
  }
                  </pre>
                </p>
              </div>
              <div id="arrayList">
                <h1>ArrayList</h1>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HelloWorld : MonoBehaviour
  {
      ArrayList benimListem = new ArrayList(); // benimListem adında boş bir ArrayList oluşturduk.
      private void Start() // Start is called before the first frame 
      {
          benimListem.Add(22); // Add yöntemi yeni bir elemanı listenin sonuna ekler
          benimListem.Add(33);
          benimListem.Add(900);
  
          foreach(int eleman in benimListem)
          {
              print(eleman);
          }
      }
  
  }
                  </pre>
                </p>
              </div>
            </div>
            <div id="3">
              <div id="enterComponents">
                <h1>Componentlere Giriş</h1>
                <p>
                  Unity içinde yerleştirdiğimiz her nesne bir component. Her nesneyi görünür kılan veya davranışını düzenleyen özellikler de onun companentleri.
                </p>
                <p>
                  Mesh: kaplama, yani nasıl göründüğü, Box Collider: Çarpışma durumunda nasıl davrandığı vs.
                </p>
                <p>
                  Bu kısımlar inspector ekranında görünüyor
                </p>
              </div>
              <div id="collisionAndRigitbody">
                <h1>Collision ve Rigidbody</h1>
                <p>
                  Nesneye katılık eklemek için "Inspector" ekranında "Add Component" > "Rigitbody" eklenir
                </p>
                <p>
                  Rigitbody nesneye yer çekimi de kazandırır. Rigitbody içinde kütle (mass), sürtünme (drag), açısal sürtünme (angular drag), yerçekimi kullan (use gravity), konumunda sabit dursun mu? (is kinematic) vs seçenekler mevcut.
                </p>
                <p>
                  Rigitbody dahil olduğu nesneye fizik özellikleri tanımlar.
                </p>
                <p>
                  Box Collider nesnenin çarpışma sınırlarını verir. Şekilden bağımsız olarak büyütülebilir. İçindeki "is triger" çarpışma anında bir tetikleme başlatmak için kullanılır. Mevcut collider sonundaki üç nokta menüden kaldırılıp başka bir şeklin colliderı "Add Component" kısmından eklenebilir.
                </p>
                <p>
                  İki nesnenin birbirine çarpabilmesi için ikisinde de collider olmak zorunda.
                </p>
              </div>
              <div id="light">
                <h1>Light</h1>
                <p>
                  "GameObject" > "Light" içinde seçenekler mevcut. 
                </p>
                <p>
                  <b>Point light</b>: noktasal ışık. <br>
                  <b>Spot light</b>: spot ışık. <br>
                  <b>Directional light</b>: güneş ışıği gibi. 
                </p>
                <p>
                  "range" ışık menzilini, "intensity" ise ışığın gücünü verir
                </p>
              </div>
              <div id="camera">
                <h1>Camera</h1>
                <p>
                  "Inspector" ekranında "clear flags": arka plan görüntüsünü, "background" arka plan rengini verir. "Field of view" ile kamera açısı ayarlanır. "Projection" kısmında ise perspektif ile izometrik arasında seçim yapılır.
                </p>
                <p>
                  Scene ekranındaki görüntüyü kameraya atamak için kamerayı sağ tıkladık ve "Align with view"i seçtik.
                </p>
              </div>
              <div id="controlComponentByScript">
                <h1>Script ile Component Kontrolü</h1>
                <p>
                  Script ile nesnelerin özelliklerini yönetebiliriz.
                </p>
                <p>
                  Örnek olarak "Create Emty" ile adı Script olan bir nesne oluşturduk. Script alanına da adı Intensity olan bir c# scripti oluşturduk.
                  Scriptin içine:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Intensity : MonoBehaviour
  {
      // Start is called before the first frame update
      public GameObject kup; // kup adında bir GameObject değişkeni public atadık.
      void Start()
      {
          print(kup); // içeriğini başlangıçta yazdırdık.
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
  }
  
                  </pre>
                </p>
                <p>
                  Scriptin çalışması için bir nesneye component olarak atanması gerekiyordu. Script adıyla oluşturduğumuz objeye ekledik. "Inspector" ekranında açılan menüden kup seçeneğini bizim daha önce oluşturduğumuz "kup" adındaki game obje ile eşleştirdik. Konsolda "Kup (UnityEngine.GameObject)
                  UnityEngine.MonoBehaviour:print (object)" çıktısını aldık.
                </p>
                <p>
                  Kup komponente Light özelliği ekledik. Kup'un light komponentine erişip intensity değerini değiştirmek için
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Intensity : MonoBehaviour
  {
      // Start is called before the first frame update
      public GameObject kup;
      void Start()
      {
          kup.GetComponent&lt;Light>().intensity = 5.0f; // kup adlı değişkene atanan komponentin "Light" komponentine eriş ve intensity değerini 5 yap
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
  }
  
                  </pre>
                </p>
              </div >
              <div id="controlScriptByScript">
                <h1>Script ile Başka Script Kontrolü</h1>
                <p>
                  Degisken.cs adında bir script oluşturup komponent olarak Script nesnesine ekledik. İçine bir public değişken ve bir de public fonksiyon ekledik.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Degisken : MonoBehaviour
  {
      // Start is called before the first frame update
  
      public int intensityDeger;
      void Start()
      {
          intensityDeger = 10;
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
      public void DegerGoster()
      {
          print("değer" + intensityDeger);
      }
  }
  
                  </pre>
                </p>
                <p>
                  Aynı nesne altındaki daha önce oluşturduğumuz Intensity.cs dosyasında Degisken.cs içindeki değişkeni ve fonksiyonu kullandık.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Intensity : MonoBehaviour
  {
      // Start is called before the first frame update
      public GameObject kup;
      void Start()
      {
         
      }
      // Update is called once per frame
      void Update()
      {
          kup.GetComponent&lt;Light>().intensity = GetComponent&lt;Degisken>().intensityDeger;
          /* kup adlı değişkene atanan komponentin "Light" komponentine eriş ve intensity değerini Degisken komponentindeki "intensityDeger" değişkeninin değeri yap 
          * Aynı komponentin içindeki değişkeni almak için başında hiçbirşey olmadan "GetComponent&lt;>()" fonksiyonu kullanılır. */
          GetComponent&lt;Degisken>().DegerGoster(); // aynı nesnedeki başka bir scriptteki fonksiyonu çalıştırıyoruz.
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="componentsAreVariables">
                <h1>Her Komponent Bir Değişken Türüdür</h1>
                <p>
                  GetComponent&lt;KomponentAdi>() kullanmak yerine KomponentAdi bir değişken türü olarak tanımlı olduğundan, buna bağlı bir değişken atanıp işlemler bunun üzerinden yapılabilir. Intensity.cs : 
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Intensity : MonoBehaviour
  {
      // Start is called before the first frame 
      public Light light; // Light değişken tipinde public ve adı "light" olan bir değişken tanımlandı.
      void Start()
      {
          
      }
      // Update is called once per frame
      void Update()
      {
          light.intensity = 7; // değişkene 7 değeri verildi.
      }
  }
  
                  </pre>
                </p>
                <p>
                  Değişkenin bağlı olduğu nesnenin "Inspector" ekranında light değişkeni nesnelerdeki bir Light kompanentine bağlandı. Bu şekilde run edildiğinde bağlanan Light komponentinin intensity değeri koddaki değeri aldı.
                </p>
              </div>
              <div id="bounds">
                <h1>Bounds - (Box Collider)</h1>
                <p>
                  bounds ile nesnenin collider sınır değerlerini bulabiliriz.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class BoxCol : MonoBehaviour
  {
      // Start is called before the first frame update
      void Start()
      {
          print(GetComponent&lt;BoxCollider>().bounds.max); // tüm eksenlerde cisim sınırlarının en yüksek değerleri verir.
          print(GetComponent&lt;BoxCollider>().bounds.min); // tüm eksenlerde cisim sınırlarının en düşük değerleri verir.
          print(GetComponent&lt;BoxCollider>().bounds.max.y); // y eksenine göre cismin en yüksek noktasını verir.
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="vectors">
                <h1>Vektörler</h1>
                <p>
                  Temel matematikteki vektörlerin toplanabilme özelliğini anlatıyor. Bunun için Vektorler.cs oluşturulup bir nesneye atandı.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Vektorler : MonoBehaviour
  {
      Vector2 vec, vec2, son;
      // Start is called before the first frame update
      void Start()
      {
          /*
          vec.x = 1.0f;
          vec.y = 1.0f;
          print(vec);
          */
          vec = new Vector2(5, 3);
          vec2 = new Vector2(5, 7);
          son = 2 * vec + vec2;
          print(son);
  
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
  }
                  </pre>
                </p>
              </div>
              <div id="rigitbody">
                <h1>RigitBody</h1>
                <p>
                  Küpe Rigitbody ekledik.
                </p>
                <p>
                  Adı RigitB.cs olan bir dosya oluşturduk. İçine 
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class RigitB : MonoBehaviour
  {
      public Rigidbody rb; // Rigitbody değerini eşlemek için değişken public verilir.
      public Vector3 pozisyon; // pozisyon için değişken
      public Vector3 hiz; // hız için değişken
    
      void Start()
      {
         pozisyon = new Vector3(0, 4, 5); // başlangıç için varsayılan pozisyon bilgisi
         hiz = new Vector3(1, 1, 1); // başlangıçta hız için varsayılan değer.
      }
  
  
      void Update()
      {
          // rb.MovePosition(pozisyon); // İnspector ekranında pozisyon değeri değiştirildiğinde bu veriyi işleyecek fonksiyon
          rb.velocity = hiz * 5; // İnspector ekranında hiz değeri değiştirildiğinde bu veriyi işleyecek fonksiyon
          // Hem hız hem de pozisyon bilgisi sürekli güncellendiğinde nesne hareket edemiyor. 
      }
  }
  
                  </pre>
                  yazdık ve scripti küpe ekledik. Script alanından Rb değişkeni olarak da küpün Rigitbody özelliğini seçtik
                </p>
                <p>
                  Bu durumda verdiğimiz hız değeri doğrultusunda nesne hareket etti.
                </p>
              </div>
              <div id="transform">
                <h1>Transform</h1>
                <p>
                  Bir adet küp oluşturuldu. Bir adet ismi "TransformKonusu.cs" olan script oluşturulup küpe dahil edildi. Script içine:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class TransfomKonusu : MonoBehaviour
  {
      public Vector3 yon; // nesnenin yön bilgisi için değişken
      public Vector3 don; // nesnenin rotate bilgisi için değişken
      void Update()
      {
          // GetComponent&lt;Transform>().Translate(new Vector3(0,1,0)); // nesneyi her update anında 1 birim y ekseninde kareket ettirir.
          /*
          GetComponent&lt;Transform>().Translate(yon); // nesneyi her update anında yon değişkeni kadar hareket ettirir.
          GetComponent&lt;Transform>().Rotate(don); // nesneyi her update anında don değişkeni kadar döndürür.
          */
          //yukarıdaki ifadede GetComponent&lt;Transform>() yerine transform yazılabilir.
          transform.Rotate(don);
          transform.Translate(yon);
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="trailRenderer">
                <h1>Trail Renderer</h1>
                <p>
                  Bir küp oluşturup "Add Component" > "Trail Renderer" ekledik.
                </p>
                <p>
                  Trail renderer nesne hareket ettiğinde ardında bıraktığı kuyruklu yıldız benzeri ize denir.
                </p>
                <p>
                  İzin nasıl olacağını Trail Renderer altındaki material sekmesinden ayarlarız.
                </p>
                <p>
                  Diğer ayarlar deneme yanılma ile yapılabilir.
                </p>
              </div>
              <div id="meshRender">
                <h1>Mesh Render</h1>
                <p>
                  Dış kaplama
                </p>
                <p>
                  Bir adet "Create Empty" yarattık.
                </p>
                <p>
                  Buna "Mesh Filter" ekleyerek bir şekil tanımladık.
                </p>
                <p>
                  "Mesh Renderer" ekleyerek material kısmından kaplama seçtik.
                </p>
                <p>
                  Assets içine adı "Materials" olan bir klasör oluşturduk. Bunun içine Create > Material ile bir material oluşturduk. Oluşturduğumuz material için renk vs ayarlayıp bunu yeni oluşturduğumuz "GameObject" içinde kullandık.
                </p>
                <p>
                  İnternetten bulduğumuz kaplamayı kullanmak için, dosyayı Assets>Textures içine image (.jpeg) olarak kaydettik. Sonra image dosyasını tıklayıp "Inspector" alanında "Texture Type": "Sprite (2D and IU)" seçildi. Material alanında yeni bir materyal yarattık. Materyalin albedo alanına (alanın başındaki kareye) bu image dosyasını sürükleyip bıraktık.
                </p>
                <p>
                  Günes ve Dunya adında iki küre oluşturup internetten aldığımız kaplamalarla kapladık. Bu nesnelere daha önce yazdığımız "TransformKonusu.cs" eklendi. Buradaki Donus özelliğini kullandık.
                </p>
                <p>
                  Dünyanın güneş etrafında dönüşü için merkezi güneş olan bir boş "GameObject" oluşturuldu. Dünya onun altına bir alt nesne olarak eklendi. Buna da "TransformKonusu.cs" eklendi.
                </p>
              </div>
            </div>
            <div id="4">
              <div id="inputGetKeyInputGetMouseButton">
                <h1>Input.GetKey & Input.GetMouseButton</h1>
                <p>
                  Control.cs Scripts alanında oluşturuldu ve çalışması için bir objeye atandı.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      void Update()
      {
          print(Input.GetMouseButton(0)); //0: sol buton, 1: sağ buton, 2: orta buton. Sağ buton tıklıyken çıktı olarak sürekli true verir. Elini çekince false verir.
      }
  }
  
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      void Update()
      {
          //0: sol buton, 1: sağ buton, 2: orta buton.
          print(Input.GetMouseButtonDown(0));  //Her tıklamada tıklanma anında 1 kere true verir. Diğer anlarda false verir
      }
  }
  
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      void Update()
      {
          //0: sol buton, 1: sağ buton, 2: orta buton.
          print(Input.GetMouseButtonUp(0));  //Her tıklamada tıklanma anından sonra elini çeker çekmez 1 kere true verir. Diğer anlarda false verir
      }
  }
  
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      void Update()
      {
          //Keycode. dan sonrası klavyedeki tuşu verir.
          print(Input.GetKey(KeyCode.Space));  //space basılıyken true, basılı değilken false döner.
      }
  }
  
                  </pre>
                </p>
                <p>
                  Klavyede yaptığımız işlemi fiziksel olarak da görmek için bir küp yarattık ve ona light kompanenti ekledik. Yine kompanent olarak içeriği aşağıda yazan scripti ekledik.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      void Update()
      {
          //Keycode. dan sonrası klavyedeki tuşu verir.
          if(Input.GetKeyDown(KeyCode.Space)) // Space basılı iken true verir.
          {
              GetComponent&lt;Light>().intensity = 2; // Space basılı iken light intensity 2 olur
          }
          else
          {
              GetComponent&lt;Light>().intensity = 1; // space basılı değilken light intensity 1 e döner.
          }
      }
  }
  
                  </pre>
                  space tuşuna basılıyken light intensity 2, basılı değilken 1 olur.
                </p>
              </div>
              <div id="inputGetAxis">
                <h1>Input.GetAxis</h1>
                <p>
                  Yön tuşlarını ve WASD kullanımını öğreneceğiz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      void Update()
      {
          print(Input.GetAxis("Horizontal")); //Sağ ve sol yön tuşu ile A ve D tuşuna basma durumunda: Sağ ve A için 0 dan başlayarak -1 e kadar değer döndürür. Sol ve D için 1 e kadar değer döndürür. Basılı tuttukça değerler 0 dan uzaklaşır. Bırakınca yine 0 olur.
      }
  }
  
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Control : MonoBehaviour
  {
      private float yatay;
      private float dikey;
  
      void Update()
      {
          yatay = Input.GetAxis("Horizontal");
          dikey = Input.GetAxis("Vertical");
          if(yatay > 0)
          {
              print("D veya sol ok tusuna bastiniz");
          }
          else if(yatay &lt; 0)
          {
              print("A ve sag ok tusuna bastiniz");
          }
          else
          {
              print("Tusa basmadiniz");
          }
          if (dikey > 0)
          {
              print("W veya yukarı ok tusuna bastiniz");
          }
          else if (dikey &lt; 0)
          {
              print("s veya aşağı ok tusuna bastiniz");
          }
          else
          {
              print("Tusa basmadiniz");
          }
      }
  }
  
                  </pre>
                </p>
                <p>
                  File > Build Settigns... > Player Settigns... > Axes altında GetAxis() ile ulaşılabilen tüm işlemler ve tuşlar mevcut. Buradan özelleştirilebilirler.
                </p>
                <p>
                  GetAxisRaw(), GetAxis() ten farklı olarak küsürlü değer almaz. Sadece üç değer verir. -1, 0 ve 1
                </p>
                <img class="w-100" src="./images/gamedev/1.jpg" alt="">
              </div>
              <div id="findGameObjectWithTag">
                <h1>Tag ile Obje Bulma</h1>
                <p>
                  Nesne seçiliyken Inspector ekranında üst tarafta tag seçeneği mevcut. Bu kısımda adı "ozel" olan kendi tagınızı oluşturduk. İçinde light olan iki eşit küp oluşturup birine bu tagı atadık.
                </p>
                <p>
                  FindWithTag.cs dosyasını oluşturduk ve içine:
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class FindWithTag : MonoBehaviour
  {
      // Start is called before the first frame update
      void Start()
      {
          GameObject.FindGameObjectWithTag("ozel").GetComponent&lt;Light>().intensity = 2; //ozel tagına sahip tek bir gameObjecti bul ve light intensity değerini 2 yap.
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
  }
                  </pre>
                  scriptin çalışması için onu herhangi bir gameobject üzerine ekledik. Play dediğimizde "ozel" tagına sahip küp daha parlak olur.
                </p>
                <p>
                  Aynı tagı başka bir küpe daha atadık ve birden fazla küpe işlem yapmak istiyoruz.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class FindWithTag : MonoBehaviour
  {
      // Start is called before the first frame update
      void Start()
      {
          GameObject.FindGameObjectsWithTag("ozel")[1].SetActive(false); //ozel tagına sahip nesnelerden indeksi 1 olanın aktif olma durumunu false yap.
          GameObject.FindGameObjectsWithTag("ozel")[0].GetComponent&lt;Light>().intensity = 0; // ozel tagına sahip nesnelerden indeksi 0 olanın light intensity değerini 0 yap.
  
      }
  
      // Update is called once per frame
      void Update()
      {
          
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="gameObjectFind">
                <h1>Find ile Obje Bulma</h1>
                <p>
                  Objenin adı ile de objeye ulaşabiliriz.
                </p>
                <p>
                  Adı "Kapsul" olan bir obje yarattık.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class FindWithTag : MonoBehaviour
  {
      // Start is called before the first frame update
      void Start()
      {
          GameObject.Find("Kapsul").SetActive(false); // adı "Kapsul" olanın setActive değerini false yap.
      }
  }
                  </pre>
                  Birden fazla "Kapsul" adında nesne varsa ilk bulduğuna kodu uygular.
                </p>
              </div>
              <div id="layers">
                <h1>Layers</h1>
                <p>
                  Inspector ekranında tag'ın yanıdaki layer kısmından nesnenin hangi layerın parçası olduğu ayarlanabilir.
                </p>
                <p>
                  Bu kısımdan yeni layer adı da verilebilir. 
                </p>
                <p>
                  İleriki derslerde detaylı uygulanacakmış.
                </p>
              </div>
              <div id="deltaTime">
                <h1>Time.deltaTime & Time.fixedDeltaTime</h1>
                <p>
                  Zamana bağlı işlemler için kullanılır. 
                </p>
                <p>
                  Adı "Timer" olan bir script oluşturduk.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Timer : MonoBehaviour
  {
      private float timer;
      /*
      void Update()
      {
          timer += 1 * Time.deltaTime;
          //Time.deltaTime = 1/fps olduğundan update işlemi de her fps sırasında çalıştığından artışı sn ile eşittir.
          print(timer);
      }
      */
      private void FixedUpdate()
      {
          timer += 1 * Time.fixedDeltaTime;
          //Time.fixedDeltaTime = 1/60 olduğundan ve FixedUpdate işleminde de fps = 60 olduğundan artışı sn ile eşittir.
          print(timer);
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="drawRay">
                <h1>DrawRay</h1>
                <p>
                  Kılıç sallama vs için kullanılıyormuş. Play durumunda game ekranında görünmeyen ama scene ekranında görünen bir birimlik bir çizgi oluşturmuş olduk. Bunun için bir küpe bağladığımız sciptimize
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class DrawRay : MonoBehaviour
  {
      void Update()
      {
          //Debug.DrawRay(transform.position, Vector3.forward /* = new Vector3(0,0,1) Vector3.dan sonra backi forward vs hazır kısayollar kullanılabiliyor. */, Color.red);
          Debug.DrawRay(transform.position, transform.forward /* üstteki ifade globalde yön veriyor. transform.forward ise lokalde yön veriyor. Bu nedenle cisim rotasyon yaptığında drawRay de rotasyona uğruyor. */, Color.red);
  
      }
  }
  
                  </pre>
                </p>
                <p>
                  Detaylı kullanımını ileride görecekmişiz.
                </p>
              </div>
              <div id="physicsRaycast">
                <h1>Physics.Raycast</h1>
                <p>
                  Bir cisme ateş ettiğimizde onun adını konsola yazdıracak bir demo yaptık. Bunun için ateş edecek küpü yarattık. z eksenine eklediğimiz daha küçük bir küp ile görsel bir ateş etme ucu tasarladık.
                </p>
                <p>
                  Her iki küpün box collider özelliğini kaldırdık. Bu sayede merkez küpün merkezinden çıkan lazer küplere temas etmemiş oldu.
                </p>
                <p>
                  Merkez küpe aşağıdaki kodun yazdığı scripti ekledik.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Laser : MonoBehaviour
  {
      RaycastHit hit;
      void Update()
      {
          if (Physics.Raycast(transform.position, transform.forward, out hit, Mathf.Infinity)) //ilk parametre çıkış noktası. ikinci parametre yönü, üçüncüsü vurulan cismin bilgisini alan değişken, dördüncü de menzili.
          {
              print(hit.collider.gameObject); // çarptığı colliderin gameobject'inin adını yazdır
          }
      }
  }
                  </pre>
                </p>
                <p>
                  Küpün lokal z eksenini hangi cisme cevirirsek onun adını konsolda alıyoruz.
                </p>
              </div>
              <div id="physicsCheckSphere">
                <h1>Physics.CheckSphere</h1>
                <p>
                  Çarpma durumlarını kullanmak için aşağıdaki örneği yaptık.
                </p>
                <p>
                  Bir küre oluşturup aşağıdaki script ile bağladık.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class CheckSphare : MonoBehaviour
  {
      void Update()
      {
          if(Physics.CheckSphere(transform.position, 1f)) // 1. parametre pozisyonu. 2. parametre çapı
          {
              print("Çarpma Gerçekleşti");
          }
      }
  }
                  </pre>
                </p>
              </div>
              <div id="onCollisionEnterOnTriggerEnter">
                <h1>OnCollisionEnter & OnTriggerEnter</h1>
                <p>
                  Çarpma durumu için özel fonksiyon: OnCollisionEnter
                </p>
                <p>
                  Bir adet zemin ve bir adet küp yarattık. Her ikisinde de box collider özelliği mevcut.
                </p>
                <p>
                  Küpe rigitbody eklendi.
                </p>
                <p>
                  Aşağıdaki script küpe eklendi.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Carpma : MonoBehaviour
  {
      private void OnCollisionEnter(Collision col) // Çarpma durumuna özel fonksiyon. 2. parametre çarpılan cisimi verir.
      {
          print(col.gameObject.name); // Çarptığı cismin gameObject name parametresini yazdır.
      }
  }
  
                  </pre>
                  play dediğimizde küpün çarptığı her nesnenin adı konsolda çarpma anında yazar.
                </p>
                <p>
                  Triger durumunda çalışan özel fonksiyonumuz: OnTriggerEnter
                </p>
                <p>
                  Bunun için daha önce script eklediğimiz küp ile zemin arasına isTrigger'ı seçili ve adı perde olan bir nesne oluşturduk.
                </p>
                <p>
                  Bu işlem için de nesnelerden birinde rigitbody olmak zorunda.
                </p>
                <p>
                  Scripti aşağıdaki gibi yazdık. Bu script perdede ise küpün, küpte ise perdenin adını verir.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Carpma : MonoBehaviour
  {
      private void OnTriggerEnter(Collider other) // ikinci parametrede içinden geçtiği objeyi
      {
          print(other.gameObject.name);
      }
  }
  
                  </pre>
                </p>
              </div>
              <div id="flipFlop">
                <h1>Flip-Flop</h1>
                <p>
                  İçine spot ışık atadığımız bir küpte klavyeden ışığı aç-kapat yapmak için aşağıdaki scripti ekledik.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class FlipFlop : MonoBehaviour
  {
      private bool aciksa;
      void Start()
      {
          aciksa = true;
      }
  
      void Update()
      {
          if(Input.GetKeyDown(KeyCode.F))
          {
              GetComponent&lt;Light>().enabled = aciksa;
              aciksa = !aciksa;
          }
      }
  }
  
                  </pre>
                </p>
                <p>
                  Aynı işi yapan alternatif kod
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class FlipFlop : MonoBehaviour
  {
      private bool aciksa;
      void Start()
      {
          aciksa = true;
      }
  
      void Update()
      {
          if(Input.GetKeyDown(KeyCode.F))
          {
              if(aciksa)
              {
                GetComponent&lt;Light>().enabled = false;
                aciksa = false;
              }
              else
              {
                GetComponent&lt;Light>().enabled = true;
                aciksa = true
              }
          }
      }
  }
  
                  </pre>
                </p>
                <p>
                  İlk kodu ben yazdım. İkincisi hocanın eğitimde kullandığı kod.
                </p>
              </div>
              <div id="moveByInput">
                <h1>Objeyi Input ile Hareket Ettirme</h1>
                <p>
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HareketEtme : MonoBehaviour
  {
      public float hiz = 1f;
      void Update()
      {
          /*
           * Aşağıdaki kodda nesne sadece x= (1, -1) ve z= (1, -1) aralığında hareket eder. 
          Vector3 playerInput = new Vector3(Input.GetAxis("Horizontal"), 4.34f, Input.GetAxis("Vertical"));
          transform.position = playerInput;
          */
  
          Vector3 playerInput = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
          Vector3 konumDegisimi = hiz * Time.deltaTime * playerInput;
          transform.position += konumDegisimi; // bu hali ile cisim bütün alanı gezebilir.
      }
  }
                  </pre>
                  Bu scripti eklediğimiz nesneyi klavyeden yön tuşları ile veya WASD ile x ve z ekseninde yönetebiliriz.
                </p>
              </div>
              <div id="cameraController">
                <h1>Kamera Kontrolü</h1>
                <p>
                  "Main Camera" nesnesini bir kpe bağladık ve kameraya aşağıdaki scripti ekledik.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class CameraController : MonoBehaviour
  {
      private float xRotation = 0.0f;
      public float mouseSenivity = 100f;
      public GameObject gamer;
      
      // Start is called before the first frame update
      void Start()
      {
          
      }
  
      // Update is called once per frame
      void Update()
      {
          float mouseX = Input.GetAxis("Mouse X") *  mouseSenivity * Time.deltaTime;
          float mouseY = Input.GetAxis("Mouse Y") * mouseSenivity * Time.deltaTime;
  
          xRotation += mouseY;
          xRotation = Mathf.Clamp(xRotation, -90f, 90f);
  
          transform.localRotation = Quaternion.Euler(-xRotation, 0, 0); // localRotation: parente göre rotasyon.
          gamer.transform.Rotate(Vector3.up * mouseX); //mmouse x ekseninde hareket ettiğinde atanan cismi döndürür
      }
  }
                  </pre>
                  Gamer değişkeni olarak da kamerayı atadığımız küpü seçtik.
                </p>
                <p>
                  Mouse yukarı aşağı hareket ettiğnde kamera da yukar ve aşağı bakar. Mouse sağa ve sola döndüğünde küpü de dönderir.
                </p>
              </div>
              <div id="moveByInputUpdate">
                <h1>Yönleri Güncellemek</h1>
                <p>
                  Daha önce hareket için girdiğimiz kod bizi global eksenlerde hareket ettiriyordu. Kamera kontrolleri ile beraber yaptığımız rotasyon hareketi nedeni ile bu kullanışsız hale geldi. Lokale göre dönüş sağlaması için script aşağıdaki gibi güncellendi
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class HareketEtme : MonoBehaviour
  {
      public float hiz = 1f;
      void Update()
      {
          /*
           * Aşağıdaki kodda nesne sadece x= (1, -1) ve z= (1, -1) aralığında hareket eder. 
          Vector3 playerInput = new Vector3(Input.GetAxis("Horizontal"), 4.34f, Input.GetAxis("Vertical"));
          transform.position = playerInput;
          */
  
          // Aşağıdaki hali ile cisim bütün alanı gezebilir.
          Vector3 playerInput = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
          Vector3 konumDegisimi = hiz * Time.deltaTime * playerInput;
          // transform.position += konumDegisimi; // bu hali ile global yönlerde gider
          transform.Translate(konumDegisimi); // bu hali ile lokal yönlerde gider.
      }
  }
                  </pre>
                </p>
              </div>
              <div id="shootAndKill">
                <h1>Ateş Etme</h1>
                <p>
                  Daha önce yaptığımız kamera ve küp (adı player olarak değiştirildi) kompleksine ek olarak ateş etme fonksiyonu ekliyoruz. Ateş edebilmemiz için hedef olarak tagı "dusman" olan küpler oluşturduk.
                </p>
                <p>
                  Adı player olan küpe aşağıdaki script eklendi.
                  <pre class="prettyprint ms-0">
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class AtesEt : MonoBehaviour
  {
      RaycastHit hit;
      void Update()
      {
          if(Input.GetMouseButtonDown(0)) 
          {
              if(Physics.Raycast(Camera.main.transform.position, transform.forward, out hit, Mathf.Infinity)) //Başlangıç noktası: Ana kamera, Yön: ileri doğru, vurma bilgisi için değişken: hit, menzil: sonsuz.
              {
                  if (hit.collider.gameObject.tag == "dusman") // vurulanın tagi "dusman" ise
                  {
                      Destroy(hit.collider.gameObject); // vurulanı sil.
                  }
              }
          }
      }
  }
                  </pre>
                </p>
              </div>
            </div>
            <div id="5">
              <div id="intoTheBlender">
                <h1>Blender Giriş</h1>
                <p>
                  Ekrandaki mevcut objeleri her açılışta getirmesi için "file" > "defaults" > "save startup file"
                </p>
                <p>
                  mouse orta top tıklıyken kamera açısı değiştiriliyor. "shift" basılıyken ortamda gezebiliyoruz.
                </p>
                <p>
                  numped 1, 3 ve 7 xyz eksenlerinin birine göre eksendeki görüntüyü ayarlar.
                </p>
              </div>
              <div id="moveRotateScale">
                <h1>Move, Rotate, Scale</h1>
                <p>
                  Küp eklemek için üst menüden "Add" > "Mesh" > "Cube". Add kısayolu "Left Shift" + "A"
                </p>
                <p>
                  Unityden farklı olarak z ve y eksenleri yer değiştirmiş durumda. Blenderda x ve y eksenleri zemin verirken z ekseni yüksekliği veriyor.
                </p>
                <p>
                  Nesne seçiliyken "G" (grab) ye basıldığında nesneyi turar ve mouse hareketi ile taşır. Nesnenin tutulduğu halde "X", "Y" veya "Z" tuşuna basılırsa nesne sadece o eksende hareket eder. Taşıma sırasında bir eksendeki hareketi iptal edip sadece diğer iki eksende hareket etmesini istiyorsak nesnenin tutulduğu halde "Shift" + "eksen yönü(x,y veya z)" kombinasyonu kullanılır.
                </p>
                <p>
                  Nesne seçiliyken "R" (rotate) ye basıldığında nesneyi turar ve mouse hareketi ile döndürür. Nesnenin tutulduğu halde "X", "Y" veya "Z" tuşuna basılırsa nesne sadece o eksende döndürür. Dönderme sırasında bir eksendeki döndermeyi iptal edip sadece diğer iki eksende dönmesini istiyorsak nesnenin tutulduğu halde "Shift" + "eksen yönü(x,y veya z)" kombinasyonu kullanılır. Belirli bir eksende belirli bir açıda dönmesi için "R" > "Eksen (x, y veya z)" > "dönme açısı" kombinasyonu kullanılr.
                </p>
                <p>
                  Nesne seçiliyken "S" (Scale) ye basıldığında nesneyi turar ve mouse hareketi boyutlandırır. Nesnenin tutulduğu halde "X", "Y" veya "Z" tuşuna basılırsa nesne sadece o eksende boyutlandırışır. Boyutlandırma sırasında bir eksendeki boyutlandırmayı iptal edip sadece diğer iki eksende dönmesini etmesini istiyorsak nesnenin tutulduğu halde "Shift" + "eksen yönü(x,y veya z)" kombinasyonu kullanılır. Belirli bir eksende belirli bir miktarda boyutlanması için "R" > "Eksen (x, y veya z)" > "dönme açısı" kombinasyonu kullanılr.
                </p>
                <p>
                  Eksen seçimi için örneğin x e ilk bastığımızda globali, tekrar bastağımızda lokal ekseni alır. 3. basışımızda seçimi iptal eder.
                </p>
                <p>
                  Global-lokal seçimi üst menünün ortasından da seçilebilir.
                </p>
                <p>
                  Nesnenin global eksenlerini lokal ekseni haline getirmek için "CTRL + A" > "All transform" seçilir. Bu sırada konum bilgisi de sıfırlanır ve cismin yeni ağırlık merkezi "0, 0, 0" koordinatları olur. Ağırlık merkezini tekrardan cismin içine taşımak için üst menüden "Object" > "Set Origin" > "Origin to Center of Mass(surface/volume)" (surface: yüzey alanına göre, "volume: şeklin hacmine göre ağırlık merkezini ayarlar.")
                </p>
                <p>
                  "Left Shift" + "Space Bar" kombinasyonu kısa yol menüsünü açar.
                </p>
              </div>
              <div id="editModeAndBevelEdges">
                <h1>Edit Mode ve Bevel Edges</h1>
                <p>
                  Edit mode a geçmek için nesne seçiliyken üst menüde "object mode" seçili kısım "edit mode" a getirilir. Kısa yolu: "Tab" tuşu.
                </p>
                <p>
                  Edit mode seçtiğimiz yerin hemen sağında seçimimizin nokta mı, kenar mı yoksa yüzey mi olduğunu belirlediğimiz kısım var. Çoklu seçim için "shift"e basılı iken seçim yapıyoruz.
                </p>
                <p>
                  "Bevel Edges" ile kenarlar yumuşatılabilir. Bunu için kenarı seçtikten sonra sağ click menüden Bevel edges seçilir ve mouse tıklanmadan bir tarafa doğru sürüklenir. Mouse topu ile poligon miktarı ayarlanabilir. Bunun yerine sol bardan da seçim yapılabilir. Sol barda "Bevel" seçildiğinde üst menüde ayarları da görünür.
                </p>
                <p>
                  Edit mode açıkken yukarıdaki tüm kısa yolları aynı şekilde kullanabiliriz.
                </p>
                <p>
                  Edit mode üzerinde yapılan işlemler ağırlık merkezini değiştirmez. Edit sonrası ağırlık merkezini otomatik almak için üst menüden "Object" > "Set Origin" > "Origin to Center of Mass(surface/volume)" (surface: yüzey alanına göre, "volume: şeklin hacmine göre ağırlık merkezini ayarlar.")
                </p>
                <p>
                  Edit modda üst menüde snap aktif ise tüm hareketleri birer birim olacak şekilde yapar. Rotasyonraı da 45° olacak şekilde yapar.
                </p>
              </div>
              <div id="editGeometricObject">
                <h1>Geometrik Objelerin Detaylandırılması</h1>
                <p>
                  Bir şekil eklediğimizde sol altta "add &lt;nesne_adi>" şeklinde bir menü çıkar. Buradan pek çok ayar yapabiliriz. 
                </p>
                <p>
                  Geometrik şekillerde sağ click menüden shade smooth/shade flat seçenekleri ile nesnenin görünümü değiştirilebilir.
                </p>
              </div>
              <div id="extrudeRegion">
                <h1>Extrude Region</h1>
                <p>
                  Extrude Region: edit modda yüzey seçiliyken "E" tuşu ile veya sol menüden seçilerek kullanılır.Seçili yüzeyi yüzeye dik eksende yükseltir. 
                </p>
                <p>
                  "E" den hemen sonra "S" ye basınca yükselecek yüzey ölçeklendirilebilir. 
                </p>
                <p>
                  "X" tuşu silme menüsünü açar. Buradan yüzer, kenar, nokta vs silinebilir.
                </p>
                <p>
                  Yüzey silinmiş olsa de etrafındaki noktalar seçilip "E" ile yükseltilebilir.
                </p>
              </div>
              <div id="originTo3dCursor">
                <h1>Ağırlık Merkezi ve Cursor Yerini Değiştirme</h1>
                <p>
                  "Alt" + "Z" yüzeylerin hepsini görünür kılar. Görünümle ilgili seçenekler ekranın sağ üstünde yer alır.
                </p>
                <p>
                  Edit modda yüzey seçip "Left Shift" + "S" dedik. Cursor selected ile cursor yüzeye taşındı. üst menüden "Object" > "Set Origin" > "Origin to 3D Cursor" ile ağırlık merkezi cursorun olduğu yere taşındı. 
                </p>
              </div>
              <div id="mirroring">
                <h1>Mirror İşlemi</h1>
                <p>
                  Yansıma ağırlık merkezine göre alınıyor.
                </p>
                <p>
                  Edit modda ağırlık merkezini taşımak istediğimiz yüzeyi, kenarı veya noktayı seçtik. "Shift" + "S" ile gelen menüden "Cursor to Selected" seçilerek cursor taşınır. Object modda "Object" > "Set Origin" > "Origin to 3D Cursor" seçilerek ağırlık merkezi taşınır. 
                </p>
                <p>
                  En sağdaki alandan "modifiers" > "add modifiers" > "mirror" dan axis olarak aynalanacak eksen seçilir. Bu durumda ağırlık merkezine ve seçilen eksene göre objenin simetriği meydana gelir. Kaydettiğimizden emin olmak içim eksen seçtiğimiz menüdeki ters üçgenden açılan menüden apply olduğumuzdan emin olun
                </p>
                <p>
                  "N" kısa yolu transform menüsünü açar veya kapatır.
                </p>
              </div>
              <div id="woodenBox">
                <h1>Ahşap Sandık Projesi Notları</h1>
                <p>
                  "Edit mode"da bir şeyi (kenar, yüzey, nokta) seçip "A" ya basınca tümünü seçer.
                </p>
                <p>
                  "Edit mode" içinde yüzey seçip "I" ya basınca aynı yüzeyin farklı boyutlusu yüzeyin içine mouse ile bpyutlandırılarak eklenir.
                </p>
                <p>
                  "Object mode" içinde "sağ click" menüde "shade auto smooth" bazı açıları yumuşatırken bazı açıları normal bırakır. Normal bırakılacak açıların ayarı sağ menüde "data">"normals" içinde yer alır.
                </p>
                <p>
                  "Edit mode" içinde seçili kısmı çoğaltmak için "Shift" + "D" (dublicate) kullanılır. Çoğalan kısım hala orijin aldığı objenin parçasıdır. Bunun hiyerarşide ayrıca seçilebilmesi için seçiliyken "P" ye basıp gelen menüden "selection" seçilir. "F2" ile yeniden adlandırılır. Orijinal parçadan ayrıldığı anda orijinal parçanın ağırlık merkezi nerede ise yeni parçanın ağırlık merkezi de oradadır.
                </p>
                <p>
                  Ekranın sağ üstündeki "show overlays" kısmının sağındaki ters üçgen ile açılan menüde "face orientation" tıklı iken mavi yüzeyler var olan, kırmızılar ise var olmayan yüzeyleri gösterir.
                </p>
                <p>
                  "Loop Cut": "edit mode"da "Ctrl" + "R" ile veya sol menüden tıklanarak çağırılır. Yüzeyi keser. Kesilmiş yüzeyler ayrı ayrı boyutlandırılabilir.
                </p>
                <h2>Render</h2>
                <p>
                  En üst menüden "UV Editing" seçildiğinde ekran ikiye bölünür ve solda seçili cismin 2D açılmış hali görünür. "Edit mode" içinde ne seçiliyse sağ ekranda da o görülür.
                </p>
                <p>
                  Tüm yüzeyleri seçip "Ctrl" + "E" ile açılan edge menüden "mark seam" seçilir. sonra "U" ile açılan "UV mapping" menüden "unwrap" seçildiğinde tüm yüzeyler kesilmiş olarak sağ ekranda belirir.
                </p>
                <p>
                  Birden fazla nesne seçilip "Ctrl" + "J" denilirse seçilen nesneler tek bir nesne olur.
                </p>
                <p>
                  Her bir nesne tek tek mark seam ve unwrap işlemi geçirdikten sonra hepsini "Ctrl" + "J" ile birleştirdik. 
                </p>
                <p>
                  "Edit mode" da tüm çizgiler seçiliyken sağ ekrandan "new" > "generated Type: UV Grid" > "OK" yapılır.
                </p>
                <p>
                  En üst menüden "Shading" seçilir. En alttaki ekranda Öence "New" denilir. Ardından "Shift" + "A" ile girilen ekranda "Texture" > "Image Texture" seçilir.
                </p>
                <p>
                  "Image Texture - Color" alanı "Principed BSDF - Base Color" alanı ile eşleştirilir.
                </p>
                <p>
                  Nesnemiz kaplanmaya hazır.
                </p>
                <p>
                  Nesneyi unityde kullanılacak şekilde export etmek için: "File" -> "Export" -> "FBX" seçilir. Çıkan ekranda sağ menüden "mesh" seçilir. Animasyon olmadığından "bake animation" tıkı kaldırılır.
                </p>
                <p>
                  Nesne kaplamak için hoca "Adobe Substance 3D Painter" aadında paralı bir uygulamanın deneme sürümünü kurdu. 5.18 ve 5.19 bunu anlatıyor.
                </p>
              </div>
            </div>
            <div id="6">
              <div id="hafta6textures">
                <h1>Textures</h1>
                <p>
                  Materyali kaplayan 2 boyutlu resim.
                </p>
                <p>
                  <a href="https://www.textures.com/">textures.com</a>: Güzel hazır textures dosyaları var.
                </p>
                <p>
                  İndirdiğimiz texture dosyasını projemizin "Assets" > "Textures" dosyasına ekliyoruz ve "Texture Type" özelliğini "Sprite 2D and UI" yapıyoruz. Sonra ilgili texture kullanılacağı materyalin "albedo" kısmına eklenir.
                </p>
                <p>
                  Material içindeki tiding ayarı kaplamanın yenilenme durumunu belirtir. 1'e 1 ise texture tüm materyali kaplar.
                </p>
                <h2>PBR(Physically Based Rendering)</h2>
                <p>
                  Kaplamanın sadece resim değil de bizim yaptığımız üç boyutlu modelle uyumlu ve fizik kurallarına uygun render edilmesine denir. Texture sadece "albeno"da değil diğer katmanlarda da farklı farklı uygulanır. İleri konularda işleyecekmişiz.
                </p>
                <p>
                  Material alanındaki map alanları texture için pürüz vs bilgileri taşır. "albedo" kısmına texture eklediğimiz gibi bunları da ekleyebiliriz.
                </p>
              </div>
              <div id="intoCanvas">
                <h1>Canvas</h1>
                <p>
                  "Hierarchy" alanında sağ click menü içinde "UI" komponentleri eklenebiliyor.
                </p>
                <p>
                  "UI" elemanı eklediğimizde otomatik olarak "Canvas" ve "Event System" da oluşur ve "UI" elemanı "Canvas" içine yerleşmiş olarak gelir.
                </p>
                <p>
                  Kamera seçiliyken "Ctrl" + "Shift" + "F" kamerayı bizim baktığımız açıya taşır.
                </p>
                <p>
                  Canvas tıklandığında sağdaki "Inspector" alanında "Render Mode" da canvas oyun ögelerine de eklenecekse "world space" seçilir. "Screen space - overlay" ise ögelerin ekrana sabitlenir. 
                </p>
                <p>
                  Aynı bölgedeki "Canvas Scaler" de "Constan pixel size" seçili ise ekran boyutu değişse de pixel sabit kalacağından UI elemanların boyutu pixel cinsinden sabit kalacak ancak ekranda kapladığı yer değişecektir. "scale with screen size"ı seçersek UI elemanların boyutu ekrana orantılı olarak değişecektir. Bu seçenğe göre işlem yaparken test ekranımızın çözünürlüğünü referans olarak girersek ayarlamak daha kolay olacaktır.
                </p>
                <p>
                  Aynı bölgede "Graphic Raycaster" dokunmatik ekrandaki bazı işlemlerde kullanılıyormuş
                </p>
                <p>
                  Canvasta UI elemanların yerleşimini görmek için "Scene" modunda "2D" seçilir ve "Hierarchy" alanından "Canvas" seçilir.
                </p>
                <p>
                  "Button" seçiliyken "Inspector" ekranında "Rect transform" altındaki kare şeklini tıklayıp "Alt" basılı iken seçimm yaparsak elemanı o kenara veya köşeye yaslar.
                </p>
                <p>
                  EventSystem canvastaki UI elemanlarına fonksiyon veren kısımdır.
                </p>
                <h2>Text & TextMeshPro</h2>
                <p>
                  TextMeshPro, klasik text yapısına göre daha fazla özellik eklememizi sağlar. Bunun dışındaki kullanımları aynı. 
                </p>
                <p>
                  Image "Hierarchy" içinde eklendikten sonra "Inspector" alanında "Source Image" olarak seçilir.
                </p>
                <p>
                  "Hierarchy" içindeki yeri üstte mi yoksa altta mı görüneceğini belirler.
                </p>
              </div>
              <div id="UIImage">
                <h1>Image</h1>
                <p>
                  Image dosyasını UI içinde kullanabilmek için assets içinde ilgili alana ekledikten sonra "Texture Type: Sprite (2D and UI)" seçilir.
                </p>
              </div>
              <div id="UIButton">
                <h1>Buton</h1>
                <p>
                  Button "Hierarchy" içinden eklenebilir. Buton olarak eklenmemiş herhangi bir UI elemana da "Add Component" olarak buton özellikleri eklenebilir.
                </p>
                <p>
                  Buton rengi, tıklanınca alacağı renk vs. "Inspector" ekranından ayarlanıyor.
                </p>
                <p>
                  Butonların çalışması için script yazıyoruz.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement; // sahneler arası geçiş için import ettik.

public class Butonlar : MonoBehaviour
{
    public void CikisButonu()
    {
        Application.Quit(); // aplikasyondan çıkış sağlar. Build sonrası çalışır.
    }

    public void YeniOyun()
    {
        // sahne numarasına göre ayarlamak:
        // SceneManager.LoadScene(1 /* build manager içinde kaçıncı sahne olduğunu yazdık*/);

        SceneManager.LoadScene("YeniOyun"); //scene adına göre ayarladık
    }
    public void Anasayfa()
    {
        SceneManager.LoadScene("altinciHafta");
    }
    
}
                  </pre>
                  Scriptin çalışması için bir komponente bağladık.
                </p>
                <p>
                  Butonun çalışması için "Inspector" ekranında "On Click ()" altındaki "+" butonuna tıklanır. Gelen menüde game object olarak kodları bağladığımız komponenti tanımladık. "No function"yazan kısımıda "butonlar" (scriptin adı) > "CikisButonu" (ilgili kodun adı) seçilir.
                </p>
              </div>
              <div id="UISlider">
                <h1>Slider</h1>
                <p>
                  Input olarak da output olarak da kullanılabilir.
                </p>
                <p>
                  Sliderdan gelen değeri karşılaması için aşağıdaki script yazılır ve bir komponente atanır.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Butonlar : MonoBehaviour
{
    public void On_Value_Changed(float deger)
    {
        print(deger);
    }
}

                  </pre>
                </p>
                <p>
                  Slider için "Inspector" ekranında "On Value Changed (Single)" alanının altındaki "+" butonuna tıklanır. Gelen menüde game object olarak kodları bağladığımız komponenti tanımladık. "No function"yazan kısımıda "butonlar" (scriptin adı) > dynamic float alanındaki "On_Value_Changed" (ilgili kodun adı) seçilir.
                </p>
                <p>
                  Slider ile her değişiklik yaptığımızda ilgili kod çalışır.
                </p>
              </div>
              <div id="UIToggle">
                <h1>Toggle</h1>
                <p>
                  Toggledan gelen değeri karşılaması için aşağıdaki script yazılır ve bir komponente atanır.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Butonlar : MonoBehaviour
{
    public void Ses(bool ses)
    {
        print(ses);
    }
}

                  </pre>
                </p>
                <p>
                  Toggle için "Inspector" ekranında "On Value Changed (boolean)" alanının altındaki "+" butonuna tıklanır. Gelen menüde game object olarak kodları bağladığımız komponenti tanımladık. "No function"yazan kısımıda "butonlar" (scriptin adı) > dynamic float alanındaki "Ses" (ilgili kodun adı) seçilir.
                </p>
                <p>
                  Toogle ile her değişiklik yaptığımızda ilgili kod çalışır.
                </p>
              </div>
              <div id="UIInputField">
                <h1>InputField</h1>
                <p>
                  "Inspector" alanındaki "Content Type" kısmı inputun alacağı veri tipini verir.
                </p>
                <p>
                  Inputtan gelen değeri karşılaması için aşağıdaki script yazılır ve bir komponente atanır.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Butonlar : MonoBehaviour
{
     public void OnEndEditText(string name)
    {
        print(name);
    }
}

                  </pre>
                </p>
                <p>
                  Input için "Inspector" ekranında kodu ekleyebileceğimiz üç alan vardır. "On Value Changed (String) " inputta her değişiklik yaptığımızda, "On Submit (String)" submit anında, "On End Edit (String)" ise değişiklik yapmayı bitirdiğimizde kodu çalıştırır. Biz "On End Edit (String)"i kullanacağız. 
                </p>
                <p>
                  "On End Edit (String)" alanının altındaki "+" butonuna tıklanır. Gelen menüde game object olarak kodları bağladığımız komponenti tanımladık. "No function" yazan kısımıda "butonlar" (scriptin adı) > dynamic float alanındaki "OnEndEditText" (ilgili kodun adı) seçilir.
                </p>
                <p>
                  Input ile değişiklik yaptığımızın sonunda ilgili kod çalışır.
                </p>
              </div>
              <div id="UIDropdown">
                <h1>Dropdown</h1>
                <p>
                  Dropdown içinde yer alacak seçenekler "Inspector" ekranında "Options" segmesinden düzenlenir. Dropdown seçilen değerin index numarasını atanan fonksiyona verir.
                </p>
                <p>
                  Toggledan gelen değeri karşılaması için aşağıdaki script yazılır ve bir komponente atanır.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Butonlar : MonoBehaviour
{
    public void DropdownValue(int index)
    {
        switch (index)
        {
            case 0:
                print("araba");
                break;
            case 1:
                print("ev");
                break;
            case 2:
                print("arsa");
                break;
        }
    }
}

                  </pre>
                </p>
                <p>
                  Dropdown için "Inspector" ekranında "On Value Changed (Int32)" alanının altındaki "+" butonuna tıklanır. Gelen menüde game object olarak kodları bağladığımız komponenti tanımladık. "No function" yazan kısımıda "butonlar" (scriptin adı) > dynamic float alanındaki "DropdownValue" (ilgili kodun adı) seçilir.
                </p>
                <p>
                  Dropdown ile her değişiklik yaptığımızda ilgili kod çalışır.
                </p>
              </div>
              <div id="UITextMeshPro">
                <h1>TextMeshPro</h1>
                <p>
                  Geleneksel texte göre daha fazla seçenek sunuyor.
                </p>
                <p>
                  İndirdiğimiz fontu önce "Assets" altında bir klasöre ekleyip ardından, üst menüden "Window" > "TextMeshPro" > "Asset Font Creator" ile açılan menüden "Source Font File" kısmına sürükleyip "Generate Font Atlas" tıklanarak kendimiz font ekleyebiliyoruz.
                </p>
                <p>
                  Assets altındaki tüm font dosyalarına geleneksel text dosyası için de direk ulaşabiliyoruz.
                </p>
              </div>
              <div id="UIPanel">
                <h1>Panel</h1>
                <p>
                  İç içe ekran (canvas) kullanmak için kullanılır. Kendisine ait UI elemanları eklenir. (Oyun içi menüsü vs.)
                </p>
                <p>
                  Açık olan paneli kapatmak için aşağıdaki kodu yazdık.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement; // sahneler arası geçiş için import ettik.

public class Butonlar : MonoBehaviour
{
    public GameObject panel;
    public void OyunaGeriDon()
    {
        panel.SetActive(false);
    }
    
}

                  </pre>
                  Kodun çalışması için scripti bir kompanente ekledik. "panel" adındaki değişkene kapanacak paneli ekledik. Son olarak da kapatacak butona kodu ekledik.
                </p>
              </div>
              <div id="UIScripts">
                <h1>Script ile UI Elemanlarına Ulaşmak</h1>
                <p>
                  Aşağıdaki kodu yazdık ve çalışması için bir kompanente bağladık.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; // UIlar ile işlem yapmak için
using TMPro; //textMeshPro için

public class YeniYontemler : MonoBehaviour
{
    public Slider sl; //slidera ulaşmak için "sl" adında değişken oluşturduk.
    public TMP_Text TMmetin; //textMeshPro text verisine ulaşmak için "TMmetin" adında değişken oluşturduk.
    public Text ClassicText; //klasik texte ulaşmak için "ClassicText" adında değişken oluşturduk.

    void Start()
    {
        // her iki komponentin de text özelliğini buradan yönetiyoruz.
        TMmetin.text = "Merhaba Dünyalı"; 
        ClassicText.text = "Biz Dostuz";
    }


    void Update()
    {
        print(sl.value); //slider value değerini yazdırır.
    }
}

                  </pre>
                  Her bir değişken için ilgili UI komponentini bağladık.
                </p>
              </div>
            </div>
            <div id="7">
              <div id="intoAnimations">
                <h1>Animasyon Giriş</h1>
                <p>
                  Üst menüden "window" > "Animation" > "Animation" ile ilgili menü açılır (kısa yolu "Ctrl" + "6"). Sürükle bırak ile ana ekrana eklenir.
                </p>
                <p>
                  Animasyon eklenmek istenen öge seçilir ve "Animation" ekranında "Create" tıklanır. Gelen menüden "Assets" içine "Animations" adında bir klasör oluşturulup bu klasör seçilir. Bu klasöre animasyon ve "animator" için iki dosya oluşturulur. "Animator" animasyonun kumandasıdır.
                </p>
                <p>
                  "Animation" ekranıda record tuşuna bastıktan sonra timeline üzerinde istenilen zamana gelinir ve o zamanda olması istenilen değişiklik gerçekleştirilir. Yazılım araları kendisi doldurur.
                </p>
                <p>
                  Timeline alanındaki noktaların yeri kaydırılarak veya çoklu seçim yapıp alanı uzatıp kısaltarak animasyonu yeniden ayarlayabiliriz.
                </p>
                <p>
                  Bütün özelliklerin animasyonu oluyor gibi görünüyor. Mesh renderer, rotation, position vs. Özelliğin nesnede olması yeterli.
                </p>
                <p>
                  "Animation" ekranında "Add Property" ile de aynı şekilde animasyona özellik eklenebilir.
                </p>
              </div>
              <div id="mixamo">
                <h1>Mixamo</h1>
                <p>
                  <a href="https://www.mixamo.com/">mixamo.com</a> hazır karakterlerin ve animasyonların olduğu bir web sitesi.
                </p>
                <p>
                  Bir karakter seçip ona animasyonları dahil ediyoruz.
                </p>
                <p>
                  idle: durma konumu
                </p>
                <p>
                  Download > "format: FBX for Unity" > "Download"
                </p>
                <p>
                  walk: yürüme durumu > ilerlemesin, yerinde dursun biz ilerlemeyi kod ile yapalım dersek "In place" seçilir. > "Download"
                </p>
                <p>
                  İndirdiklerimiz "Assets" içinde bir klasöre (derste adı "Anime" idi) atıyoruz.
                </p>
                <p>
                  Modeli "Hierarchy" alanına sürükleyer kullanabiliriz. Bu hali ile kaplama yapılmamış gibi görünüz. Kaplama için aynı klasörün içine materials adında bir klasör daha oluşturulur. Model tıklanıp "Inspector" ekranında "Select" > "Materials" > "Extarct Textures" tıklanır ve hedef olarak az önce oluşturduğumuz klasör seçilir. 
                </p>
                <p>
                  Animasyonların aktif olması için, bir klasör daha oluşturup (derste adı: "Anim") içine indirdiğimiz paketlerden "Ctrl" + "D" ile ayırdığımız animasyon dosyalarını atıyoruz.
                </p>
              </div>
              <div id="animator">
                <h1>Animator</h1>
                <p>
                  Yukarıda yaptığımız işleme devam ediyoruz.
                </p>
                <p>
                  Karaktere "Inspector" > "Add Component" ile "Animator" ekliyoruz.
                </p>
                <p>
                  Daha önce animasyon dosyalarımızı attığımız klasörde "Create" > "Animator Controller" yapılır. Adı "Yuruyus" olark değiştirilir ve açılır. "Idle" animasyonunu sürükleyip bırakınca "Entry" kısmına bağlandı.
                </p>
                <p>
                  "Walking" animasyonunu da sürükleyip aynı alana bıraktık. "Idle" üzerinde "Sağ Click" > "Make Transition" seçip "Walking" tıklanarak bağlanır. Aynı işlem tersine de yapılır.
                </p>
                <p>
                  "Animator" ekranında "Parameters" > "+" tıklanır. "Boolean" seçilir. "isWalking" adında bir değişken oluşturulur. 
                </p>
                <p>
                  "Idle -> Walking" bağlantısı seçili iken "Inspector" ekranında "Has Exit Time" tikli değilse geçiş aniden olur. "Conditions" > "List is Empty" tıklanır. Parametre olarak "isWalking" otomatik gelir. "True" olarak ayarlanır. Aynı işlem tersine de yapılır. Bu sefer "isWalking = false" seçilir.
                </p>
                <p>
                  Aynı işlemi "Runnung" için yaptık.
                </p>
                <p>
                  Oluşturduğumuz "Animator Controller"ı karaktere eklediğimiz "Animator" içindeki "Contoller"a atıyoruz. 
                </p>
                <p>
                  Eklediğimiz animasyonlarda "Inspector" ekranında "Loop Time" seçili ise biz iptal edene kadar döngü devam eder. Yoksa bir sefer oynar ve durur.
                </p>
              </div>
              <div id="animationControlByScripts">
                <h1>Script ile Kontrol</h1>
                <p>
                  Animasyonları kontrol etmesi için aşağıdaki scripti yazdık ve komponent olarak karaktere ekledik.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class WalkAndRun : MonoBehaviour
{
    Animator animator;
   
    void Start()
    {
        animator = GetComponent&lt;Animator>(); // içinde olduğu komponentin "Animator" komponentine ulaştık.
    }

    private void FixedUpdate()
    {
        if (Input.GetKey(KeyCode.W))
        {
            animator.SetBool("isWalking", true); // animation controller içinde boolen olarak ayarladığımız "isWalking" parametresini "true" yaptık.
            transform.Translate(new Vector3(0, 0, 2f) * Time.deltaTime);
        } 
        else
        {
            animator.SetBool("isWalking", false);
        }
        if (Input.GetKey(KeyCode.R))
        {
            animator.SetBool("isRunning", true);
            transform.Translate(new Vector3(0, 0, 4f) * Time.deltaTime);
        }
        else
        {
            animator.SetBool("isRunning", false);
        }
    }
}

                  </pre>
                </p>
              </div>
              <div id="cinemachine">
                <h1>Cinemachine</h1>
                <p>
                  Kameramızın kontrol ettiğimiz yapıyı kontrol etmesi için:
                </p>
                <p>
                  "Window" > "Package Manager" > "Packages: Unity Registry" kısmında search alanına "Cinemachine" yazıp gelen paketi kuruyoruz ve projemize import ediyoruz.
                </p>
                <p>
                  "MainCamera"ya component olarak "CinemachineBrain" özelliğini ekledik. Bu sayede Cinemachine mantığı ile çalışacak.
                </p>
                <p>
                  "Hierarchy" ekranında "Sağ Click" menüde "Cinemachine" > "Virtual Camera" yaptık ve oluşturduğumuz komponentin "Inspector" ekranında "Follow" alanında takip etmesini istediğimiz komponenti seçtik.
                </p>
                <p>
                  Aynı alandaki body kameranın takip ettiği nesneye olan mesafesini, transform.rotation ise açısını verir.
                </p>
                <p>
                  Tank oyununda "body: 3rd Person Follow" ayarı çok işime yaradı
                </p>
              </div>
              <div id="joystickAndAndroid">
                <h1>Joystik ve Android Çıktı Alma</h1>
                <p>
                  Asset store içine joystick araması yapıp <a href="https://assetstore.unity.com/packages/tools/input-management/joystick-pack-107631">bunu</a> indirdik ve import ettik.
                </p>
                <p>
                  "Hierarchy" ekranında bir canvas oluşturduk. Canvasta "Scale with Screen Size" seçilir ve telefona uygun ölçüler girildi. İndirdiğimiz asset içinde "Prefix" içinden "Fixed Joystick"i canvasa ekledik.
                </p>
                <p>
                  "Build Settigs" içinde Android'e "Switch platform" ettik. 
                </p>
                <p>
                  Önceki derste animasyon oluşturduğumuz klasörde adı "Yuru" olan bir "Animation Controller" oluşturduk. Default state'i "Idle" onun gideceği bağlantı iki yönlü olarak da "Walking" eklendi. "isWalking" adında bir parametre oluşturduk ve bağlantılara mantık olarak atadık. Bu animation controller'ı karakterin "Inspector" menüsünde "Anımator.Controller" alanına atadık. Karaktere "Rigidbody" ve "Box Collider" eklendi. 
                </p>
                <p>
                  Yeni bir script oluşturup karaktere ekledik.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
[RequireComponent (typeof(Rigidbody), typeof(BoxCollider))] // bu scriptin eklendiği komponentte "RigitBody" ve "BoxCollider" olmak zorunda. Yoksa kodu ekleyince kendisi ekler.
public class Yuru : MonoBehaviour
{
    [SerializeField] private Rigidbody _rigidbody; //SerializeField kod içinde private kalacak değerlerin "Inspector" alanında görüntülenmesi ve kullanılabilmesi için yazılır. 
    [SerializeField] private FixedJoystick _joystick;
    [SerializeField] private Animator _animator;
    [SerializeField] private float _movespeed;
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
    private void FixedUpdate()
    {
        _rigidbody.velocity = new Vector3(_joystick.Horizontal, 0, _joystick.Vertical);

        if(_joystick.Horizontal != 0 || _joystick.Vertical != 0)
        {
            transform.rotation = Quaternion.LookRotation(_rigidbody.velocity); //Quaternion: dönüşlerin daha yumuşak olmasını sağlayan matematiksel bir ifade
            _animator.SetBool("isWalking", true);
            transform.Translate(new Vector3(0, 0, _movespeed) * Time.deltaTime);
        }
        else
        {
            _animator.SetBool("isWalking", false);
        }
    }
}

                  </pre>
                  ilgili değişkenleri ekledik.
                </p>
                <p>
                  "Build Setting" > "Player Settigns" > "Player" > "Resolution and Presentation" > "Orientation" > "Default Orientation" kısmı "Landscape Left" seçilirse ekran yan olarak ayarlanmış olur. 
                </p>
              </div>
              <div id="playerPrefs">
                <h1>PlayerPrefs</h1>
                <p>
                  Oyundaki bilgileri kullandığımız cihazda saklı tutmamıza yarar.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class KodlarPlayerPref : MonoBehaviour
{
    void Start()
    {
        //SetFloat-GetFloat
        PlayerPrefs.SetFloat("EnYuksekScore", 500); // float olarak "EnYuksekScore" keyi ile "500" değerini saklar. Kodun bir kere çalışması yeterlidir.
        print(PlayerPrefs.GetFloat("EnYuksekScore")); // "EnYuksekScore" keyindeki float değeri getirir ve yazdırır. Hafızada bu key yoksa "0" verir.
        print(PlayerPrefs.GetFloat("EnYuksekScore", 1000)); //"EnYuksekScore" keyi yoksa "1000" verir.

        //SetInt-GetInt
        PlayerPrefs.SetInt("canSayisi", 5); // integer olarak "canSayisi" keyi ile "5" değerini saklar. Kodun bir kere çalışması yeterlidir.
        print(PlayerPrefs.GetInt("canSayisi")); // "canSayisi" keyindeki integer değeri getirir ve yazdırır. Hafızada bu key yoksa "0" verir.
        print(PlayerPrefs.GetInt("canSayisi", 10)); //"canSayisi" keyi yoksa "10" verir.

        //SetString-GetString
        PlayerPrefs.SetString("OyuncuAdi", "Murat Gökduman"); // string olarak "OyuncuAdi" keyi ile "Murat Gökduman" değerini saklar. Kodun bir kere çalışması yeterlidir.
        print(PlayerPrefs.GetString("OyuncuAdi")); // "OyuncuAdi" keyindeki string değeri getirir ve yazdırır. Hafızada bu key yoksa "" verir.
        print(PlayerPrefs.GetString("OyuncuAdi", "Oyuncu 1")); // "OyuncuAdi" keyi yoksa "Oyuncu 1" verir.

        //DeleteKey
        PlayerPrefs.DeleteKey("OyuncuAdi"); // "OyuncuAdi" keyi ve verisi silinir.

        //DeleteAll
        PlayerPrefs.DeleteAll(); // PlayerPrefs içindeki tüm keyleri ve verileri siler. 
    }
}

                  </pre>
                </p>
              </div>
            </div>
            <div id="8">
              <div id="projeLabirent">
                <h1>Labirent</h1>
                <p>
                  Adı "Labirent" olan yeni bir proje oluşturduk.
                </p>
                <p>
                  Labirente duvarlar yapıp material atandı. Tüm duvarlar bir parent altında toplandı. Parentinin tagı "Duvar" olarak atandı. Alt elemanlara da "Duvar" tagı atandı Adı "Baslangic" ve "Bitis" olan iki küçük plane oluşturup başlangıç ve bitişe yerleştirdik.
                </p>
                <p>
                  Başlangıca adı "Top" olan bir küre yerleştirdik ve "rigidbody" ekledik. Topa aşağıdaki script eklendi.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TopKontrol : MonoBehaviour
{
    private Rigidbody rb;
    public float Hiz = 1.8f;
    void Start()
    {
        rb = GetComponent&lt;Rigidbody>();
    }

    private void FixedUpdate()
    {
        float yatay = Input.GetAxis("Horizontal");
        float dikey = Input.GetAxis("Vertical");
        Vector3 kuvvet = new Vector3(-yatay, 0, -dikey);
        rb.AddForce(kuvvet * Hiz);
    }
    private void OnCollisionEnter(Collision other) // çarpışma sırasında çalışacak fonksiyon
    {
        string objIsmi = other.gameObject.name;
        if (objIsmi.Equals("Bitis"))
        {
            print("Oyunu Kazandınız");
        }
    }
}
                  </pre>
                </p>
                <p>
                  UI çin "Canvas" oluşturuldu. Ekranın sağ ve sol üst köşeleri için zaman ve can textleri oluşturuldu. Can textinin yanına kalp imajı konuldu. Script aşağıdaki güncellendi.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; // UI için gerekli

public class TopKontrol : MonoBehaviour
{
    private Rigidbody rb;
    public float Hiz = 1.8f;
    public Text zaman, can;
    float zamanSayaci = 500f;
    float canSayaci = 20;

    void Start()
    {
        rb = GetComponent&lt;Rigidbody>();
    }
    private void Update()
    {
        zamanSayaci -= Time.deltaTime;
        zaman.text = (int)zamanSayaci + ""; // baştaki "(int)" veriyi integer olarak çevirir. sondaki "" kısmı da dönüşen veriyi string yapar.
        can.text = canSayaci + "";
    }

    private void FixedUpdate() // hareketleri yönetmek için fixedUpdate daha uygun
    {
        float yatay = Input.GetAxis("Horizontal");
        float dikey = Input.GetAxis("Vertical");
        Vector3 kuvvet = new Vector3(-yatay, 0, -dikey);
        rb.AddForce(kuvvet * Hiz);
    }
    private void OnCollisionEnter(Collision other) // çarpışma sırasında çalışacak fonksiyon
    {
        string objIsmi = other.gameObject.name;
        if (objIsmi.Equals("Bitis"))
        {
            print("Oyunu Kazandınız");
        }
        if(other.gameObject.tag.Equals("Duvar"))
        {
            canSayaci--;
        }
    }
}

                  </pre> 
                  "zaman" ve "can" text değişkenlerine ilgili UI elemanları atandı.
                </p>
                <p>
                  Oyunun devam edip etmediğini kontrol etmek için "oyunDevam" adında bir boolean değişken başlangıçta true olacak şekilde atandı. Zaman bittiğinde veya can bittiğinde false oluyor. True veya false olduğu durumlar if ile kullanıldı.
                </p>
                <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; // UI için gerekli

public class TopKontrol : MonoBehaviour
{
    private Rigidbody rb;
    public float Hiz = 1.8f;
    public Text zaman, can;
    float zamanSayaci = 500f;
    float canSayaci = 20;
    bool oyunDevam = true;

    void Start()
    {
        rb = GetComponent&lt;Rigidbody>();
    }
    private void Update()
    {
        if(oyunDevam)
        {
            zamanSayaci -= Time.deltaTime;
            zaman.text = (int)zamanSayaci + ""; // baştaki "(int)" veriyi integer olarak çevirir. sondaki "" kısmı da dönüşen veriyi string yapar.
        }
        can.text = canSayaci + "";
        if(zamanSayaci &lt;= 0 || canSayaci &lt;= 0) // can veya zaman biterse
        {
            oyunDevam = false;
        }
    }

    private void FixedUpdate() // hareketleri yönetmek için fixedUpdate daha uygun
    {
        if (oyunDevam) // oyunDevam "true" ise ediyorsa top yönetilebilir.
        {
            float yatay = Input.GetAxis("Horizontal");
            float dikey = Input.GetAxis("Vertical");
            Vector3 kuvvet = new Vector3(-yatay, 0, -dikey);
            rb.AddForce(kuvvet * Hiz);
        }
        else
        {
            rb.velocity = Vector3.zero;
            rb.angularVelocity = Vector3.zero;
        }
    }
    private void OnCollisionEnter(Collision other) // çarpışma sırasında çalışacak fonksiyon
    {
        string objIsmi = other.gameObject.name;
        if (objIsmi.Equals("Bitis"))
        {
            print("Oyunu Kazandınız");
        }
        if(other.gameObject.tag.Equals("Duvar"))
        {
            canSayaci--;
        }
    }
}

                </pre>
                <p>
                  Bu seferki projeyi "WebGL" olarak build edeceğiz. "Build Settings" içine sahnemizi atadık. Player Settings -> Player -> "WebGL" -> "Others Settings" "Color Space: Gama" ve "Lightmap Encoding: normal quality" olarak ayarlandı.
                </p>
                <p>
                  Oyunu yeniden başlatması için UI kısmına bir buton eklendi. Butona atanmak üzere aşağıdaki script yazıldı.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement; // scene yönetmek için gerekli.

public class Btn : MonoBehaviour
{
    public void YenidenBasla()
    {
        SceneManager.LoadScene(0);
    }
}
                  </pre>
                </p>
                <p>
                  Butonun gerektiği durumlarda görünmesini sağlayan kod scripte eklendi.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; // UI için gerekli

public class TopKontrol : MonoBehaviour
{
    private Rigidbody rb;
    public float Hiz = 1.8f;
    public Text zaman, can, durum;
    float zamanSayaci = 500f;
    float canSayaci = 20;
    bool oyunDevam = true;
    public Button btn;

    void Start()
    {
        rb = GetComponent&lt;Rigidbody>();
    }
    private void Update()
    {
        if(oyunDevam)
        {
            zamanSayaci -= Time.deltaTime;
            zaman.text = (int)zamanSayaci + ""; // baştaki "(int)" veriyi integer olarak çevirir. sondaki "" kısmı da dönüşen veriyi string yapar.
        }
        can.text = canSayaci + "";
        if(zamanSayaci &lt;= 0 || canSayaci &lt;= 0) // can veya zaman biterse
        {
            oyunDevam = false;
            durum.text = "Oyun tamamlanamadı.";
            btn.gameObject.SetActive(true); // Butonu görünür yapar.
        }
    }

    private void FixedUpdate() // hareketleri yönetmek için fixedUpdate daha uygun
    {
        if (oyunDevam) // oyunDevam "true" ise ediyorsa top yönetilebilir.
        {
            float yatay = Input.GetAxis("Horizontal");
            float dikey = Input.GetAxis("Vertical");
            Vector3 kuvvet = new Vector3(-yatay, 0, -dikey);
            rb.AddForce(kuvvet * Hiz);
        }
        else
        {
            rb.velocity = Vector3.zero;
            rb.angularVelocity = Vector3.zero;
        }
    }
    private void OnCollisionEnter(Collision other) // çarpışma sırasında çalışacak fonksiyon
    {
        string objIsmi = other.gameObject.name;
        if (objIsmi.Equals("Bitis"))
        {
            durum.text = "Oyunu tamamladınız. Tebrikler.";
            oyunDevam = false;
            btn.gameObject.SetActive(true);
        }
        if(other.gameObject.CompareTag("Duvar"))
        {
            canSayaci--;
        }
    }
}

                  </pre>
                </p>
                <p>
                  "Window" > "Package Manager" içinden "Cinemachine" import edildi. "Hierarchy" ekranından "Cinemachine" -> "FreeLook Camera" eklendi. Bu eklenince otomatik olarak main camera içine "CinemachineBrain" kompanenti eklenmiş oldu.
                </p>
                <p>
                  "FreeLook Camera" seçiliyken "Inspector" ekranında "Follow" ve "Look at" alanına top eklendi. "Axis Control" alanından kameranın yeri ayarlanabilir.
                </p>
                <p>
                  Ben "FreeLook camera" yerine daha önce kullandığımız "Virtual Camera" ile de düzgün sonuç alamadım. Üzerinde tekrar çalışacağım.
                </p>
                <p>
                  "Window" > "Package Manager" içinden "WebGL publisher" import edildi. Sonra "Build Settings" içinden webgl için build edildi.
                </p>
                <p>
                  <a href="https://play.unity.com/">play.unity.com</a> içine projemizi göndermek için en üst menüden "Publish" ile yayınlayabiliyoruz.
                </p>
                <p>
                  Oyunumuz <a href="https://play.unity.com/mg/other/odev8-n8k">https://play.unity.com/mg/other/odev8-n8k</a> içinde yayınlandı.
                </p>
                <p>
                  <a href="https://itch.io/">itch.io</a> içinde oyunu ücretli veya ücretsiz olarak yayınlayabiliyoruz.
                </p>
              </div>
            </div>
            <div id="9">
              <div id="audioSourceAudioListener">
                <h1>AudioSource ve AudioListener</h1>
                <p>
                  Audio adında yeni bir proje oluşturduk. Hocanın hazır verdiği "Audio", "Models" ve "Textures" klasörlerini asset klasörüne ekledik.
                </p>
                <p>
                  Hazır texture olarak verilen "Gras"ı materyale ekleyip oluşturduğumuz zemine atadık. 
                </p>
                <p>
                  Ekranın sağ altındaki ampul sembolünü tıklayarak "Lighting" menüsünü açtık. "Scene" > "New Lighting Settings" ile yeni ışık ayarı oluşturduk. "Inspector" ekranınan "Auto Generate" açıldı.
                </p>
                <p>
                  Zemine 4 adet küpü köşeleri bir kareye denk gelecek şekilde yerleştirdik.
                </p>
                <p>
                  Tüm bu alanı "_Environment" adında bir parent altında topladık.
                </p>
                <p>
                  Ses konusunda iki önemli component var. Biri "Main Camera" içinde varsayılan olarak gelen "Audio Listener" sesin algılanıp bize iletildiği kısımdır. "Audio source" ise sesin kaynağıdır. "Hierarchy" içinde ayrı bir nesne gibi eklenebilir veya nesneye komponent olarak atanabilir.
                </p>
                <p>
                  <b>Audio Source</b> "Inspector" ekranında
                  <ul>
                    <li>"Audio Clip" -> ses dosyasını eklediğimiz kısım.</li>
                    <li>"Output" -> sesin ince ayarları.</li>
                    <li>"Mute" -> sessize al.</li>
                    <li>"Play on awake" -> proje çalışır çalışmaz sesi başlatır.</li>
                    <li>"Loop" -> döngü.</li>
                    <li>"Priority" -> sesin önceliği.</li>
                    <li>"Sterio Pan" -> sterio yön ayarı.</li>
                    <li>"Spatial Blend" -> sese üç boyut kazandırır.</li>
                    <li>"Reverse on Mix" -> yankı ile ilgili</li>
                    <li>"3D Sound Settings"
                      <ul>
                        <li>"Doppler Level" -> ses kaynağının yakınlaşma ve uzaklaşma sırasındaki değişimini ayarlar.</li>
                        <li>"Volume Rolloff -> sesin kaynaktan uzklaştıkça azalma grafiğini belirler</li> 
                      </ul>
                    </li>
                  </ul>
                </p>
              </div>
              <div id="audioPlayer">
                <h1>Player</h1>
                <p>
                  Adı ve tagı "Player" olan boş bir gameobject oluşturduk.
                </p>
                <p>
                  Komponent olarak "Character Controller" eklendi. Boyu çapı ve yüksekliği ayarlandı. Sonra komponent olarak "Audio Source" eklendi. Volume ayarlandı.
                </p>
                <p>
                  Player elementinin altına bir kapsul eklendi ve box collider'ı kaldırıldı. Çünkü player controller kendi colliderına sahip. Kapsül playerin kapsayacağı şekilde ayarlandı.
                </p>
                <p>
                  Main Camera da Player altına eklendi. Kamera tam kapsülün üst noktasına gelecek şekilde ayarlanır.
                </p>
                <p>
                  PlayerController adında bir script oluşturduk.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public float moveSpeed;
    public CharacterController characterController;
    public Transform cam;
    public float lookSensivity;
    public float maxXRot;
    public float minXRot;
    private float curXRot;
    void Start()
    {
        Cursor.lockState = CursorLockMode.Locked;
    }

    // Update is called once per frame
    void Update()
    {
        Move();
        Look();
    }
    void Move()
    {
        float x = Input.GetAxis("Horizontal");
        float z = Input.GetAxis("Vertical");
        Vector3 dir = transform.right * x + transform.forward * z; // vektörel toplama
        dir.Normalize(); // vektör yönü aynı kalır değeri 1 olur.
        dir *= moveSpeed * Time.deltaTime;
        characterController.Move(dir);
    }
    void Look()
    {
        float x = Input.GetAxis("Mouse X") * lookSensivity;
        float y = Input.GetAxis("Mouse Y") * lookSensivity;

        transform.eulerAngles += Vector3.up * x; // "eulerAngles" de "rotation" gibi dönüş işlemlerinde kullanılır. Farkı anlamadım.

        curXRot += y;
        curXRot = Mathf.Clamp(curXRot, minXRot, maxXRot);

        cam.localEulerAngles = new Vector3(-curXRot, 0, 0); // "localEulerAngles" globalde değil lokalde dönüşü kontrol eder.
    }
}

                  </pre>
                </p>
              </div>
              <div id="audioFootsteps">
                <h1>Adım Sesleri</h1>
                <p>
                  "Footsteps" adında bir script yazdık.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Footsteps : MonoBehaviour
{
    public AudioClip[] footstepClips; // çalınacak ses dosyaları
    public AudioSource audioSource;

    public CharacterController controller;

    public float footstepTreshold; // hangi hızı aşarsak adım sesi verilecek?
    public float footstepRate; // kaç sn aralıklarla adım sesi verilecek?
    private float lastFootstepTime;

    private void FixedUpdate()
    {
        if(controller.velocity.magnitude > footstepTreshold) // "velocity.magnitude" vektörün boyutunu ve yönünü göz ardı ederek sadece büyüklüğünü ifade eden skaler bir değerdir.
        {
            if (Time.time - lastFootstepTime > footstepRate)
            {
                lastFootstepTime = Time.time;

                audioSource.PlayOneShot(footstepClips[Random.Range(0, footstepClips.Length)]);
                /*
                 "audioSource.PlayOneShot" bir sesin bir defa çalıp susmasını sağlar.
                 "Random.Range" belirli bir aralıkta random tam sayı üretir.
                */
            }
        }
    }
}
                  </pre>
                </p>
                <p>
                  Scripti player komponentine bağladık ve ilgili değişkenleri atadık.
                </p>
              </div>
              <div id="audioReverbZone">
                <h1>Yankı Oluşturma</h1>
                <p>
                  Bir koridor oluşturduk. Arasına "Audio" -> "Audio Reverb Zone" elementi "Hierarchy" içinden eklendi. İç içe iki çemberden dıştaki yankı giriş bölgesi, içteki ise yankı bölgesidir. "Inspector" ekranında "ReverbPreset" üzerinden yankı tipi değiştirilebilir.
                </p>
              </div>
              <div id="audioDopplerEffect">
                <h1>Doppler Effect</h1>
                <p>
                  Doppler etkisi, ses dalgalarının veya ışık dalgalarının bir kaynaktan yayıldığı bir gözlemciye doğru yaklaşırken veya uzaklaşırken frekansındaki değişimi ifade eder. Örneğin, bir ambulans geçerken sesinin yüksek frekanslı başlayıp düşük frekanslı devam etmesi Doppler etkisine bir örnektir. 
                </p>
                <p>
                  Örnek için asset store içinden bir uçak modeli indirdik. Komponent olarak "AudioSource" ekledik. "AudioClip" kısmına hocanın verdiği ses dosyalarından "plane" eklendi. 
                  <ul>AudioSource ayarları:
                    <li>Spatial Blend = 3D</li>
                    <li>Doppler Level = 0.5</li>
                    <li>Max Distance = 1000</li>
                    <li>Volume Rolloff = Lineer (veya Custom)</li>
                  </ul>
                </p>
                <p>
                  Boş bir gameObject oluşturulup player'dan 500 birim öteye yerleştirildi. Uçak modeli ona alt eleman olarak eklendi. Boş gameObject için aşağıdaki script yazıldı ve eklendi.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Rotator : MonoBehaviour
{
    public Vector3 axis;
    public float speed;
   
    void Update()
    {
        transform.Rotate(axis, speed * Time.deltaTime);
    }
}
                  </pre>
                </p>
                
              </div>
              <div id="audioDistance">
                <h1>Mesafeye Göre Ses İşlemleri</h1>
                <p>
                  AudioSource içindeki "Max - Min Distance" ve "Volume Rolloff" ile mesafeye göre ses işlemlerini yapabiliriz. Belirli mesafelerde sesin duyulması veya duyulmaması için aşağıdaki scripti de dahil edebiliriz.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Crickets : MonoBehaviour
{
    public AudioSource audioSource;

    public float stopDistance;

    private Transform player;
    private float defaultVolume;

    private void Start()
    {
        defaultVolume = audioSource.volume;
        player = FindAnyObjectByType&lt;PlayerController>().transform; // "FindAnyObjectByType&lt;PlayerController>()" içinde "PlayerController" olan nesneyi bulur
    }

    private void Update()
    {
        if(player == null)
        {
            return;
        }

        float dist = Vector3.Distance(transform.position, player.position); // "Vector3.Distance()" iki vektör arasındaki mesafeyi bulur.

        if (dist > stopDistance)
        {
            audioSource.volume = defaultVolume;
        }
        else
        {
            audioSource.volume = 0.0f;
        }
    }
}
                  </pre> 
                </p>
              </div>
              <div id="musicZone">
                <h1>Music Zone</h1>
                <p>
                  "OnTriggerEnter" ve "OnTriggerExit" fonksiyonları ile ses açma - kapama işlemi yaptık.
                </p>
                <p>
                  Bunun için boş bir gameObject içine "AudioSource" ve "BoxCollider" ekledik. BoxCollider "isTriger" seçili ve istenilen alanı kapsayacak halde düzenlendi. Trigger durumunu denetlemek için script yazıldı.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MusicZone : MonoBehaviour
{
    public AudioSource audioSource;
    public float fadeTime;
    private float targetVolume;
    // Start is called before the first frame update
    void Start()
    {
        targetVolume = 0f;
        audioSource.volume = 0f;
    }

    // Update is called once per frame
    void Update()
    {
        audioSource.volume = Mathf.MoveTowards(audioSource.volume, targetVolume, (1f / fadeTime) * Time.deltaTime); 
        /* 
            "Mathf.MoveTowards()" bir değerin başka bir değere yumuşak bir şekilde dönüşmesini sağlar.
            ilk parametre başlangıcı, ikincisi hedefi son parametre ise değişim miktarını verir. Değişim miktarı küçüldükçe geçiş yumuşaklaşır.
        */
    }
    private void OnTriggerEnter(Collider other) // trigger alanına girdiğimizde çalışır.
    {
        if (other.CompareTag("Player"))
        {
            targetVolume = 1.0f;
        }
    }
    private void OnTriggerExit(Collider other) // trigger alanından çıktığımızda çalışır.
    {
        if (other.CompareTag("Player"))
        {
            targetVolume = 0f;
        }
    }
}

                  </pre>
                </p>
              </div>
              <div id="audioMixer">
                <h1>AudioMixer</h1>
                <p>
                  "Assets" klasöründe "Sağ Click" -> "Create" -> "Audio Mixer" ile yeni bir dosya oluşturup çift tıkladık. "Audio Mixer" ekranı açıldı.
                </p>
                <p>
                  <b>Master</b>: ortamdaki tüm seslerin dB ayarını yapar.
                </p>
                <p>
                  "Groubs" -> "+" ile yeni bir ayar üretilir.
                </p>
                <p>
                  "Inspector" ekranındaki "AudioSource" komponentlerinin altındaki "Output" ile oluşturduğumuz mixerler komponente atanır.
                </p>
                <p>
                  Mixerleri kodla yönetebilmek için, ilgili mixer seçiliyken "Inspector" alanında "Volume" sağ tıklanır. "Expose Volume to Script" tıklanır. Bu işlemden sonra "Audio Mixer" ekranının sağ üst kısmında kodda kullanmamız için parametreler oluştu. Bunları sağ tıklayıp yeniden adlandırabiliriz.
                </p>
              </div>
              <div id="audioControl">
                <h1>Ses Kontrol</h1>
                <p>
                  Ses kontrol için 3 adet slider içeren bir UI tasarlandı.
                </p>
                <p>
                  UI dan alınan veri ile mixerleri kontrol etmesi için aşağıdaki script yazıldı ve "Canvas" ögesine atandı.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro; // TextMeshPro için
using UnityEngine.Audio; // ses işlemleri için.
using UnityEngine.UI; // UI için

public class MusicMixerController : MonoBehaviour
{
    public AudioMixer mixer;

    public GameObject window;
    public Slider masterSlider;
    public Slider sfxSlider;
    public Slider musicSlider;

    void SetSliders() // sliderların pozisyonunu ayarlar.
    {
        masterSlider.value = PlayerPrefs.GetFloat("MasterVolume");
        sfxSlider.value = PlayerPrefs.GetFloat("SFXVolume");
        musicSlider.value = PlayerPrefs.GetFloat("MusicVolume");
    }
    private void Start()
    {
        if(PlayerPrefs.HasKey("MasterVolume")) //ses daha önce ayarlandıysa önceki ayarları mixere atar.
        {
            mixer.SetFloat("MasterVolume", PlayerPrefs.GetFloat("MasterVolume")); // ilk parametredeki "MasterVolume" Audio Mixer içindeki parametre adını, ikincinin içindeki ise PlayerPref içindeki keyi verir.
            mixer.SetFloat("SFXVolume", PlayerPrefs.GetFloat("SFXVolume"));
            mixer.SetFloat("MusicVolume", PlayerPrefs.GetFloat("MusicVolume"));

            SetSliders();
        }
        else
        {
            SetSliders();
        }

    }
    //sliderlara atanacak fonksiyonlar.
    public void UpdateMasterVolume() 
    {
        mixer.SetFloat("MasterVolume", masterSlider.value);
        PlayerPrefs.SetFloat("MasterVolume", masterSlider.value);
    }

    public void UpdateSFXVolume()
    {
        mixer.SetFloat("SFXVolume", sfxSlider.value);
        PlayerPrefs.SetFloat("SFXVolume", sfxSlider.value);
    }
    public void UpdateMusicVolume()
    {
        mixer.SetFloat("MusicVolume", musicSlider.value);
        PlayerPrefs.SetFloat("MusicVolume", musicSlider.value);
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.V))
        {
            window.SetActive(!window.activeInHierarchy); // "activeInHierarchy" hiyerarşide aktif olma durumunu verir. Bu kod durumu tersine çevirir.
            if (window.activeInHierarchy)
            {
                Cursor.lockState = CursorLockMode.None; // window aktifken mouse görünür olur.
            }
            else
            {
                Cursor.lockState = CursorLockMode.Locked;
            }
        }
    }
}

                  </pre>
                  ilgili değişkenleri atadık.
                </p>
                <p>
                  Slider Max-min value -20 ve 1 olarak ayarlandı. Slider fonksiyonları sliderlara eklendi.
                </p>
                <p>
                  mixerleri kontrol ettiğimiz kısım açıkken kameranın dönmemesi için, kamera dönüşünü ayarladığımız fonksiyon koşula bağlandı.
                  <pre class="prettyprint ms-0">
...
  void Update()
      {
          Move();
          if(Cursor.lockState == CursorLockMode.locked)
          {
              Look();
          }
      }
...
                  </pre>
                </p>
              </div>
            </div>
            <div id="10">
              <div id="ar">
                <h1>Artırılmış Gerçeklik</h1>
                <p>
                  Android için <a href="https://developers.google.com/ar/develop?hl=tr">ARCore</a> kullanacağız.
                </p>
                <p>
                  <b>Güncelleme sonrası not:</b> AR Session Origin -> XR Origin mobile, Ar Core -> Google AR Core oldu. (bu not ileriki derslerde anlam kazanacak.)
                </p>
              </div>
              <div id="arAdroidSettings">
                <h1>AR Android Ayarları</h1>
                <p>
                  Yeni bir 3D project oluşturduk. Build Settingste çalışacağımız platformu "Android" yaptık. 
                </p>
                <p>
                  "Window" -> "Package Manager" içinden önce "AR Foundation" ardından "ARCore XR Plugin" kuruldu.
                </p>
                <p>
                  "Build Settigns" -> "Player Settings" içinde "Player" kısmında üst kısımdaki proje bilgilerini girdik. Projeyi yayınlaycaksak "Icon" başlığı altındaki tüm kısımlar doldurulmalıdır. Yayınlamaycaksak "Default Icon" ayarlamak yeterlidir.
                </p>
                <p>
                  "Build Settigns" -> "Player Settings" içinde "Player" kısmında "Resolution and Presentation" altında "Orientation" kısmında ekranın yatay veya dikey kullanımı ayarlanır.
                </p>
                <p>
                  "Build Settigns" -> "Player Settings" içinde "Player" kısmında "Other Settings" başlığının altında "Multithreaded Rendering" seçimini kaldırdık (düzgün çalışmazsa tekrar ekleyeceğiz). "Package Name" istediğimiz gibi değilse "Override Default Package Name" seçilerek değiştirilebilir. "Minimum Api Level" "... (Api Level 26)" olarak seçilir. 
                </p>
                <p>
                  Hocaya ek olarak: "Build Settigns" -> "Player Settings" içinde "Player" kısmında "Other Settings" başlığının altında "Scripting Backend: IL2CPP" seçildi. "ARMv7" seçimi kaldırıldı. "ARM64" seçildi.
                </p>
                <p>
                  "Build Settigns" -> "XR Plug-In Management" kısmında "ARCore" seçilir.
                </p>
                <p>
                  Cep telefonumuz kablo ile bağlıyken "Build And Run" ile uygulama direk çalıştırılabilir. Bunun için telefonun "Geliştirici Seçenekleri" açık olmalıdır. Nasıl açıldığına google'dan baktık. Sonra geliştirici seçeneklerinden "USB debugging" açıldı. Telefon kablo ile bağlıyken "Build Settings" -> "Run Device" olarak telefonumuzu seçebiliriz. Bu şekilde telefonumuza uygulama yüklenmiş ve çalıştırılmış olur.
                </p>
              </div>
              <div id="arPlaneManagement">
                <h1>Zemin Tespiti</h1>
                <p>
                  "Hierarchy" ekranından "XR" -> "AI Session Origin" ve "AR Session" eklendi. "AR Session" ortamımızın AR ile uyumlu çalışmasını sağlar. "AI Session Origin" içinde bize gereken kamera var. Bu nedenle "Main Camera" yı siliyoruz.
                </p>
                <p>
                  AR ile uapacağımız işlemlerin çoğunu "AI Session Origin" içine "Add Component" ile eklenti ekleyerek yapacağız. Zemin tespiti için önce "AR Plane Manager" eklendi. Sadece zemini değil duvarları espit için de kullanılabilir. İçindeki "Detection Mode" kısmı ile bu ayar yapılır.
                </p>
                <p>
                  "Hierarchy" içinden bir adet "AI Default Plane" eklendi. "Asset" içinde "Prefabs" klasörü açılıp "AI Default Plane" sürüklenerek içine bırakıldı. Sonra da "Hierarchy" alanından silindi. "Prefabs" içine eklediğimiz dosyayı "AI Session Origin" içindeki "AR Plane Manager" komponentine "Plane Prefab" olarak atandı.
                </p>
                <p>
                  <code>
                    BuildFailedException: You have enabled the Vulkan graphics API, which is not supported by ARCore... 
                  </code>
                    hatasının çözümü için "Build Settigns" -> "Player" kısmının "Other Settigns" kısmına "Auto Graphics API" seçimi kaldırılır. "Graphic APIs" içinden de "Vulkan" kaldırılır.
                </p>
              </div>
              <div id="arPlacementIndicator">
                <h1>Placement Indicator Oluşturma</h1>
                <p>
                  Hocanın verdiği hazır png yi "Assets" -> "Textures" klasörüne ekledik. "Inspector" alanından "Alpha is Transparacy"yi seçtik.
                </p>
                <p>
                  "Assets" -> "Materials" klasöründe adı "PlacementsIndicator" olan bir material oluşturduk. "Inspector" alanında "Shader: Unlit/Transparent" olarak ayarladık. Texture olarak da az önce ayarladığımız texture'ı seçtik.
                </p>
                <p>
                  "Hierarchy" alanında adı "PlacementsIndicator" olan bir boş obje oluşturduk. İçine alt obje olarak bir plane objesi atadık. Bunun da "Mesh Collider" komponentini remove edip material olarak oluşturduğumuz materyali atadık. Scale "0.03" ayarladık. "Lighting -> Receive Shadow" seçimini kaldırdık.
                </p>
                <p>
                  "AR Session Origin" içindeki "AR Plane Manager" komponentini kaldırdık. Sonra geri ekledik ama "Plane Prefab"ı şimdilik boş bırakıyoruz. Bir de "AR Raycast Manager" (telefondan gelen veriyi yönetir) komponenti ekledik.
                </p>
                <p>
                  "Assets" -> "Scripts" klasörüne "PlacementsIndicator" adında bir script oluşturduk ve onu da adı "PlacementsIndicator" olan nesnemize ekledik.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems; //zemin tepiti, yüzey tespiti vs

public class PlacementsIndicator : MonoBehaviour
{
  private ARRaycastManager rayManager; //telefondan gelen veri
  private GameObject visual; // placeholder görselimiz.

  private void Start()
  {
      rayManager = FindObjectOfType&lt;ARRaycastManager>(); // tipi "ARRaycastManager" olanı bul.
      visual = transform.GetChild(0).gameObject; // child elemanların ilkini (index 0) getir.

      visual.SetActive(false);
  }
  private void Update()
  {
      List&lt;ARRaycastHit> hits = new List&lt;ARRaycastHit>();
      rayManager.Raycast(new Vector2(Screen.width / 2, Screen.height / 2), hits, TrackableType.Planes); //ilk parametre ekranın neresinde olacağı, ikinci parametre telefondan alınan sonuçları tutan değişken, üçüncüsü ise yapılacak işlem

      if(hits.Count > 0) // eğer hits ler 0 dan fazla ise zemin algılanmış demektir.
      {
          transform.position = hits[0].pose.position; //kodun olduğu nesnenin pozisyonunu alanda ilk yakaladığı noltayla eşitler. Kamera hareket ettikçe nesne de hareket eder.
          transform.rotation = hits[0].pose.rotation; //kodun olduğu nesnenin yönünü alanda ilk yakaladığı noltayla eşitler.

          if (!visual.activeInHierarchy) visual.SetActive(true);
      }
  }
}
                  </pre>
                </p>
              </div>
              <div id="arAddObject">
                <h1>Ortama Objenin Eklenmesi</h1>
                <p>
                  "ObjectSpawner" adında boş bir gameObject oluşturduk. Bir de aynı adda script oluşturup içine attık.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ObjectSpawner : MonoBehaviour
{
  public GameObject objectToSpawn;
  private PlacementsIndicator placementsIndicator;

  private void Start()
  {
      placementsIndicator = FindObjectOfType&lt;PlacementsIndicator>(); // Adı "PlacementsIndicator" olan komponenti bulur.
  }

  private void Update()
  {
      if(Input.touchCount>0 && Input.touches[0].phase == TouchPhase.Began) // ekrana dokunulduysa ve dokunmalardan ilki başladığı anda
      {
          GameObject obj = Instantiate(objectToSpawn, placementsIndicator.transform.position, placementsIndicator.transform.rotation); // obj adında bir game objecti "objectToSpawn" örneklendirilerek üret. position ve rotation bilgisi olarak "placementsIndicator" bilgilerini kullan.
      }
  }
}

                  </pre>
                </p>
                <p>
                  "ObjectToSpan" adında boş bir gameObject oluşturup içine AR olarak eklemek istediğimiz nesneyi dahil ettik. Sonra oluşturduğumuz bu yapıyı "Assets" -> "Prefabs" klasörüne taşıdık ve "Hierarchy" alanından sildik. Oluşturduğumuz prefabımızı "ObjectSpawner" içindeki scriptimizdeki gameObject olarak atadık.
                </p>
              </div>
              <div id="faydaliSayfalar">
                <h1>Faydalı Sayfalar (Asset)</h1>
                <ul>
                  <li><a href="https://kenney.nl/">kenney.nl</a> ücretsiz assetler, ücretsiz pixel art yaratım araçları, ücretli yaratım araçları</li>
                  <li><a href="https://www.turbosquid.com/">turbosquid.com</a> ücretli ve ücretsiz assetler</li>
                  <li><a href="https://sketchfab.com/">sketchfab.com</a> ücretli ve ücretsiz assetler</li>
                </ul>
              </div>
              <div id="arFaceManager">
                <h1>Yüz Algılama</h1>
                <p>
                  Yeni boş bir scene oluşturuldu. "Main Camera" yı sildik. "AI Session Origin" ve "AR Session" eklendi. "AI Session Origin" içine komponent olarak "AR Face Manager" eklendi. "AR Face Manager" -> "Maximum Face Count" bulunacak en fazla yüz sayısını belirtir.
                </p>
                <p>
                  "Hierarchy" alanında "AR Default Face" eklendi ve sonra Prefab klasörüne sürüklenip "Hierarchy" alanından silindi. Bu prefab "AI Session Origin" içine komponent olarak yer alan "AR Face Manager"ın Face Prefab alanına ilişkilendirildi. 
                </p>
                <p>
                  "AI Session Origin" -> "AR Camera" nesnesinin "Inspector" ekranında "Facing Direction" ayarı var. Bu ayar açılan kameranın ön mü (user) arka mı (world) olduğuna karar verir.
                </p>
                <p>
                  Daha öncek gibi "Build Settings" alanına sahne eklenip build alındı.
                </p>
                <p>
                  Yüze nesne eklemek için (bıyık vs) internetten incelenecek. Body ve hand tracking konularını da internetten kendimiz araştıracağız.
                </p>
              </div>
              <div id="arTrackedImageManager">
                <h1>Resim Algılama</h1>
                <p>
                  İmage yakalama için kullanılacak resim formatını png yapın. Fotoğrafın "Inspector" ekranında "Advanced" özelliklerden "Read/Write" seçili olmalı.
                </p>
                <p>
                  Takip ettiğimiz video: <a href="https://www.youtube.com/watch?v=GfS72wqKQ_g">youtube.com: Let’s Make an AR App in 15 MINUTES!! (Beginner Friendly)</a>
                </p>
                <p>
                  "ARImageTracking" adında yeni bir proje oluşturuldu. "Window" -> "Package Manager" içinden önce "AR Foundation" ardından "ARCore XR Plugin" kuruldu.
                </p>
                <p>
                  <a href="https://assetstore.unity.com/packages/tools/input-management/joystick-pack-107631">Joystick Pack</a> ve <a href="https://assetstore.unity.com/packages/3d/characters/creatures/dragon-for-boss-monster-hp-79398">Dragon for Boss Monster : HP</a> paketleri eklendi.
                </p>
                <p>
                  "Build Settings"ten "Android" seçildi. 
                </p>
                <ul>
                  <li>"Player Settigns"
                    <ul>
                      <li>"Other Settings"
                        <ul>
                          <li>Auto Graphics API seçimi kaldırıldı.</li>
                          <li>Vulcan silindi.</li>
                          <li>Multithreaded Rendering seçimi kaldırıldı</li>
                          <li>Minimum API Level 24 seçildi.</li>
                          <li>Scripting Backend = IL2CPP seçildi</li>
                          <li>ARM64 seçildi</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>XR Plug-In Management
                    <ul>
                      <li>ARCore seçildi</li>
                    </ul>
                  </li>
                </ul>
                <p>
                  "Hierarchy" ekranından "XR" -> "AI Session Origin" ve "AR Session" eklendi. "Main Camera" yı silindi.
                </p>
                <p>
                  "AI Session Origin" altına komponent olarak "AR Tracked Image Manager" eklendi.
                </p>
                <p>
                  "Assets" içinde "Create" -> "XR" -> "Reference Image Library" seçip "ReferenceImageLibrary" adında bir dosya oluşturduk. "Inspector" ekranında "Add Image" ile tetikleyici olarak kullanacağımız image dosyasını ekledik.
                </p>
                <p>
                  Kullanacağımız ejderha prefabını üzerinde çalışmak için "Hierarchy" alanına ekledik. Boyutunu yanına eklediğimiz küpe göre orantıladık (Default küpün bir kenarı 1 metre). İlk çıkış yönünü "AR Camera" nesnesinin açısına göre ayarladık. "Inspector" ekranındaki "Controller" olarak atanan Animation controller içinden istemediğimiz animasyonları kaldırdık (sadece "Take Off" ve "Fly Forward" kaldı.). "Rigidbody" eklendi. Rigitbodyden "Gravity" kaldırıldı
                </p>
                <p>
                  "AI Session Origin" -> "AR Tracked Image Manager" içindeki "Serialized Library" ile "ReferenceImageLibrary" dosyası eşleştirildi. "Add Component" -> "New Script" ile adı "PrefabCreator" olan bir script yarattık ve ekledik.
                  <pre class="prettyprint ms-0">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.ARFoundation;



public class PrefabCreator : MonoBehaviour
{
    [SerializeField] private GameObject dragonPrefab; // indirdiğimiz dragon prefablarından istediğimiz eşleştireceğiz.
    [SerializeField] private Vector3 prefabOffset;

    private GameObject dragon;
    private ARTrackedImageManager arTrackedImageManager; // ARTrackedImageManager, ARCore veya ARKit tarafından izlenen görselleri işlemek için kullanılır.

    private void OnEnable() // script etkinleştiğinde bu işlevi çağırır.
    {
        arTrackedImageManager = gameObject.GetComponent&lt;ARTrackedImageManager>(); 

        arTrackedImageManager.trackedImagesChanged += OnImageChanged; // trackedImagesChanged olayına abone olur.
    }

    private void OnImageChanged(ARTrackedImagesChangedEventArgs obj) // Fonksiyon içinde, eklendiği, güncellendiği veya kaldırıldığı için değişiklik yapılan tüm izlenen görüntülerin listesi bulunur.
    {
        foreach(ARTrackedImage image in obj.added) // Eklenen her bir yeni izlenen görüntü için döngü başlatır.
        {
            dragon = Instantiate(dragonPrefab, image.transform);
        }
    }
}


                  </pre>
                  Scriptin "Dragon Prefab" kısmına ayarladığımız prefabı eşleştirildi. "Prefab Offset" ayarını "y = -0.1" yapıldı.
                </p>
                <p>
                  "DragonController" olan bir script yarattık ve sahnedeki ejderha prefabına ekledik.
                  <pre class="prettyprint ms-0">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DragonController : MonoBehaviour
{
    [SerializeField] private float speed;

    private FixedJoystick fixedjoystick;
    private Rigidbody rigidbody;

    private void OnEnable() // script etkin olduğunda çağırılan kod.
    {
        fixedjoystick = FindObjectOfType&lt;FixedJoystick>();
        rigidbody = gameObject.GetComponent&lt;Rigidbody>();
    }

    private void FixedUpdate()
    {
        float xVal = fixedjoystick.Horizontal;
        float yVal = fixedjoystick.Vertical;

        Vector3 movement = new Vector3(xVal, 0, yVal);
        rigidbody.velocity = movement * speed;

        if (xVal != 0 && yVal != 0)
            // Karakterin dönme açısını hesaplar.
            transform.eulerAngles = new Vector3(transform.eulerAngles.x, Mathf.Atan2(xVal, yVal) * Mathf.Rad2Deg, transform.eulerAngles.z); // "transform.eulerAngles" lokal eksene göre dönüşleri temsil eder Mathf.Atan2() fonksiyonu, x ve y koordinatları arasındaki açıyı hesaplar. Bu durumda, joystick'in yatay ve dikey girişlerine (xVal ve yVal) dayalı olarak karakterin dönme açısını hesaplamak için kullanılır. Mathf.Rad2Deg ile radianları dereceye dönüştürürüz.
    }
}
                  </pre>
                </p>
                <p>
                  Prefab düzenlemek için ekrana eklediğimiz ejderhamıza "DragonController" scripti eklendi. Speed 0.5 ayarlandı. Sahneye eklediğimiz prefabın ayarlarının ana prefabda da ayarlanması için "Inspector" ekranında "Overrides" -> "Apply All" seçildi. Ana prefabda da ayarlar kontrol edildi. Aktarılmayanlar düzeltildi.
                </p>
                <p>

                </p>
                <p>
                  AR eğitimi için hocanın önerdiği kanallar: <a href="https://www.youtube.com/@xrmasiso">@xrmasiso</a>, <a href="https://www.youtube.com/@KaraDot">@KaraDot</a>
                </p>
                <p>
                  İleri eğitim için video: <a href="https://www.youtube.com/watch?v=FJAO6jDYljs">youtube.com: Project-Based Augmented Reality Course with Unity Engine and AR Foundation</a>
                </p>
              </div>
              <div>
                <h1>Project-Based Augmented Reality Course with Unity Engine and AR Foundation</h1>
                <p>
                  <a href="https://www.youtube.com/watch?v=FJAO6jDYljs&ab_channel=freeCodeCamp.org">Dersin videosu</a>
                </p>
                <p>
                  Her aşamayı tek tek anlatmayacağım. Kodları ve önemli yerleri yazacağım.
                </p>
                <p>
                  Herhangi bir UI elemana komponent olarak "Button" eklenerek buton özellikleri verilebilir.
                </p>
                <p>
                  Textures materiale atandıktan sonra materyal seçiliyken "Inspector" menüsünde "Shader" ayarı için "Unlit/Texture" veya "Legacy Shaders/Diffuse" da kullanılabilir.
                </p>
              </div>
            </div>
            <div id="patikaBlender">
              <h1>Patika.dev Blender notları</h1>
              <p>
                "Ctrl" + "Alt" + "numped 0" kamerayı bizim ekranda gördüğümüz açıya taşır.
              </p>
              <p>
                Normalde dönderme işlemleri ekranın ortası baz alınarak yapılır. Ekranın ortası değil de seçilen nesne baz alınarak dönderilmesi için "Edit" > "Preferences" > "Navigation" > "Orbit around selection" seçilerek yapılır.
              </p>
              <p>
                Normalde zoom işlemleri ekranın ortası baz alınarak yapılır. Ekranın ortası değil de mouse baz alınarak zoom yapması için "Edit" > "Preferences" > "Navigation" > "Zoom to mouse position" seçilerek yapılır.
              </p>
              <p>
                Çift ekran çalışırken bazı özellikleri diğer ekrana taşımak için, taşımak istediğimiz alanın sınırında mouse işaretçisi "+" sembolü olduğunda "Shift" + "Sol Click" ile ilgili kısmı yüzer menü haline getirebiliriz. "+" butonu varken "Ctrl" ye basılıylen sürüklersek de ekrandaki pencereler yer değiştirir.
              </p>
              <p>
                Transform işlemleri sırasında "Shift" e basılı tutarsak işlem hassaslaşır. "Ctrl" ye basılı tutunca da grap ve scale birer tam grid işler. Zoom ile izometrik görüntüde daha minik gridler oluşunca da onlara göre işlerler. Grap sırasında tam gridde değilken de gride yapışması için üst ortadaki "snap" menüsünden "absolude grid snap" seçilir. "Ctrl" ye basılı tutmak yerine üst ortadan "snap" aktif hale getirilebilir(kısa yolu "Shift" + "Tab")
              </p>
              <p>
                Bir konuda blender dökümantasyondan yardım almak için ilgili alanda mouse ile beklerken "F1" tuşuna basın.
              </p>
              <h2>Basitçe Animasyon</h2>
              <p>
                En üstten "Layout" seçiliyken en alttaki "timeline" editöründen "Auto keying" açılır. Timeline üzerinde en sonda başlangıç ve bitiş kare sayıları ayarlanır. En sağdaki "Properties" editörünün "output" alanında videonun fps si seçilir. Timeline üzerinde istenilen kareye gelinip ana kısımda nesneye değişiklik yaptığımızda timeline üzerine otomatik olarak key atılır (auto keying). Yazılım araları kendisi doldurarak animasyonu oluşturur. 
              </p>
              <h2>Properties Editor</h2>
              <ul>
                <li><b>Tool</b>: seçili aracın ayarları</li>
                <li><b>Render</b>: render ayarları</li>
                <li><b>Output</b>: çıktı alırken kullanılacak ayarlar</li>
                <li><b>View Layer</b>: Render alırken hangi katmanların ayrı ayrı alınabileceğini belirler. Bu da bize daha sonra o katmanlarda değişiklik yapma şansı tanır.</li>
                <li><b>Scene</b>: Sahnede hangi kameranın, hangi ölçü sisteminin kullanılacağını vs belirler</li>
                <li><b>Word</b>: Render alınan alanın özelliklerini belirler. Arkaplan vs.</li>
                <li><b>Object</b>: seçili objenin en temel özelliklerini değiştirir.</li>
                <li><b>Modifiers</b>: (sadece mash objesi) objeyi pek çok yönden modifiye eder. İçinde çok kullanışlı araçlar var</li>
                <li><b>Particles</b>: (sadece mash objesi) objenin parçacıklar saçmasını veya saç çıkarmasını sağlar. Bu eklentiler fizik kurallarına uygun davranır. Hareketleri animasyon başlatılınca belli olur.</li>
                <li><b>Physics</b>: (sadece mash objesi) nesnelere yer çekimi vs fizik özellikler ekler.</li> 
                <li><b>Constraints</b>: (sadece mash objesi) İki nesnenin birbirine bağlı hareket etmesini sağlar. Örneğin bir kamera küpe bağlanırsa küpün hareketlerini takip eder.</li>
                <li><b>Data (obje)</b>: Vertex datası objenin şeklin verir. Bu menüden değiştirilebilir. Origin aldığı veri değişince atanan şekil de değişir.</li>
                <li><b>Data (camera)</b>: Kameranın özeliikleri değiştirilebilir. Sensör vs.</li>
                <li><b>Data (light)</b>: Işık özellikleri değiştirilir. Açı, gölge vs</li>
                <li><b>Material</b>: Nesnenin görüntü özelliklerini değiştirebiliriz. Kaplama yapabiliriz.</li>
                <li><b>Texture</b> </li>
              </ul>

              <h2>Notlar</h2>
              <p>
                "F9" nesneyi oluşturduktan hemen sonra çıkan "Add" menüsünü tekrar aktif eder.
              </p>
              <p>
                Bir cismin yüzeyine yapışacak şekilde başka bir cisim yerleştirmek için "snap" açılır ve yanındaki ayarlardan "face nearist" seçilir.
              </p>
              <p>
                Bir yerde açık bir alanı yüzey ile kapatmak için edit modda kapatılacak akan seçilir ve "F" tuşuna basılır.
              </p>
              <p>
                "Subdivision Surface" seçili nesneye atandığında daha yumuşak geçişli bir görünüm sağlayan bir "modifier"dir. Kısayol: "Ctrl" + "1-5'e herhangi bir sayı". Girilen sayı subdivision leveli verir.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>