<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">GraphQL</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          EÄŸitim NotlarÄ±
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notlarÄ±.html" target="_blank">HTML NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- Ä°Ã§erik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yÃ¼kseklik belirtmediÄŸinde kolon en alta kadar indiÄŸinden .sticky-top gÃ¶rÃ¼nÃ¼r bir etki yaratmÄ±yor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#whatIsGraphQL">GiriÅŸ</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsGraphQL">GraphQL Nedir? Ne DeÄŸildir?</a>
                    <a class="nav-link ms-3 my-1" href="#apolloServer">Apollo Server'a GiriÅŸ</a>
                    <a class="nav-link ms-3 my-1" href="#nonNullableFields">Non Nullable Fields</a>
                    <a class="nav-link ms-3 my-1" href="#scalarTypes">Scalar Types</a>
                    <a class="nav-link ms-3 my-1" href="#customTypes">Custom Types</a>
                    <a class="nav-link ms-3 my-1" href="#argumans">ArgÃ¼manlar ile Ã‡alÄ±ÅŸmak</a>
                    <a class="nav-link ms-3 my-1" href="#iliskiselData">Ä°liÅŸkisel Veriler ile Ã‡alÄ±ÅŸmak</a>
                    <a class="nav-link ms-3 my-1" href="#iliskiselDataArgumanlar">Ä°liÅŸkisel Ä°fadelerde ArgÃ¼manlar</a>
                  </nav>
                  <a class="nav-link" href="#whatIsMutation">Mutations (Server)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsMutation">Mutation Nedir? NasÄ±l YazÄ±lÄ±r?</a>
                    <a class="nav-link ms-3 my-1" href="#inputType">Input Type</a>
                    <a class="nav-link ms-3 my-1" href="#updateMutations">Update Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#deleteMutations">Delete Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#deleteAllMutations">Delete All Mutations</a>
                  </nav>
                  <a class="nav-link" href="#subscriptionServerSetup">Subscriptions (Server)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#subscriptionServerSetup">Subscription Server Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#userCRUDsubs">User CRUD Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#postVeCommentCRUDsubs">Post ve Comment CRUD Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#withFilter">withFilter ile Subscription Filtreleme</a>
                    <a class="nav-link ms-3 my-1" href="#redisPubsub">Redis PubSub</a>
                    <a class="nav-link ms-3 my-1" href="#env">Ortam DeÄŸiÅŸkenleri</a>
                  </nav>
                  <a class="nav-link" href="#Folder/Schema Structure - 1">Folder/Schema Structure</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#folderSchemaStructure1">Folder/Schema Structure - 1</a>
                    <a class="nav-link ms-3 my-1" href="#folderSchemaStructure2">Folder/Schema Structure - 2 (File Loader)</a>
                    <a class="nav-link ms-3 my-1" href="#babelComplier">Babel Compiler</a>
                  </nav>
                  <a class="nav-link" href="#setupApolloClient">Queries (Apollo Client)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#setupApolloClient">Apollo Client Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#ApolloClientVisual">Genel GÃ¶rÃ¼nÃ¼mÃ¼n AyarlanmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#reactRouter">React Router</a>
                    <a class="nav-link ms-3 my-1" href="#postlarinListelenmesi">PostlarÄ±n Listelenmesi (useQuery)</a>
                    <a class="nav-link ms-3 my-1" href="#postDetail">Post DetaylarÄ±nÄ±n GÃ¶sterilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#shortDescField">Short Description Field'Ä±nÄ±n TanÄ±mlanmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#useLazyQuery">Post YorumlarÄ±nÄ±n Listelenmesi (useLazyQuery)</a>
                  </nav>
                  <a class="nav-link" href="#subscribeToMore">Subscriptions (Apollo Client)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#subscribeToMore">PostlarÄ±n GerÃ§ek ZamanlÄ± Listelenmesi (subscribeToMore)</a>
                    <a class="nav-link ms-3 my-1" href="#useSubscription">Post SayÄ±sÄ±nÄ± GerÃ§ek ZamanlÄ± GÃ¶stermek (useSubscription)</a>
                    <a class="nav-link ms-3 my-1" href="#commentsRealTime">YorumlarÄ±n GerÃ§ek ZamanlÄ± GÃ¶sterilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#fragments">Fragments</a>
                  </nav>
                  <a class="nav-link" href="#createNewPostForm">Mutations (Apollo Client)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#createNewPostForm">New Post Formunun TasarlanmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#newPostFormUsers">KullanÄ±cÄ± Listesinin Ã‡ekilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#useMutation">Yeni Post Eklemek (useMutation)</a>
                    <a class="nav-link ms-3 my-1" href="#createNewCommentForm">Yorum Formunun HazÄ±rlanmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#mutationNewComment">Yeni Yorum Mutation'unun HazÄ±rlanmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#spinnerDelay">Spinner Delay</a>
                  </nav>
                  <a class="nav-link" href="#connectMongoDb">GraphQL & MongoDB</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#connectMongoDb">MongoDB BaÄŸlantÄ±sÄ±nÄ±n GerÃ§ekleÅŸtirilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#createUserModel">User Modelinin OluÅŸturulmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#createPostModel">Post Modelinin OluÅŸturulmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#createCommentModel">Comment Modelinin OluÅŸturulmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#relationshipMongoDb">MongoDB Ä°liÅŸkileri</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringUserMutation">Refactoring User Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringPostMutation">Refactoring Post Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringCommentMutation">Refactoring Comment Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringSubscriptions">Refactoring Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#apolloClientUpdates">Apollo Client GÃ¼ncellemeleri</a>
                  </nav>
                  <a class="nav-link" href="#enterToHasura">Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#enterToHasura">Hasura'ya GiriÅŸ ve Query</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraMutations">Hasura Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraSubscriptions">Hasura Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraRelationships">Relationships</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraCustomActions">Custom Actions</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraRemoteSchemas">Remote Schemas</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraEventTriggers">Event Triggers</a>
                  </nav>
                  <a class="nav-link" href="#commentHasuraDocker">Comments App with Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#commentHasuraDocker">Hasura Docker YapÄ±landÄ±rmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraData">VeritabanÄ± Mimarisinin OluÅŸturulmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraClient1">Client Entegrasyonu - 1</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraClient2">Client Entegrasyonu - 2</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraClient3">Client Entegrasyonu - 3</a>
                  </nav>
                  <a class="nav-link" href="#votingHasuraBackend">Realtime Voting App with Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#votingHasuraBackend">Hasura Backend'in OluÅŸturulmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#votingApolloClientAndReactRouter">Apollo Client ve React Router Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#votingRealTimeListing">OylamalarÄ±n GerÃ§ek ZamanlÄ± Listelenmesi</a>
                    <a class="nav-link ms-3 my-1" href="#votingNewVoting1">Yeni Oylama OluÅŸturma EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 1</a>
                    <a class="nav-link ms-3 my-1" href="#votingNewVoting2">Yeni Oylama OluÅŸturma EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 2</a>
                    <a class="nav-link ms-3 my-1" href="#votingVotingDetail1">Oylama Detay EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 1</a>
                    <a class="nav-link ms-3 my-1" href="#votingVotingDetail2">Oylama Detay EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 2</a>
                  </nav>
                  <a class="nav-link" href="#hasuraDigitalOceanDeployment">Deployment</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#hasuraDigitalOceanDeployment">Hasura DigitalOcean Deployment</a>
                    <a class="nav-link ms-3 my-1" href="#reactClientNetlifyDeployment">React Client Netlify Deployment</a>
                  </nav>
                  <a class="nav-link" href="#hasuraMeetingApp">Meeting App with Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#hasuraMeetingDb">Hasura Kurulumu ve DB YapÄ±sÄ±nÄ±n OluÅŸturulmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraExpressBackend">Express Backending HazÄ±rlanmasÄ±</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraSucraseHasuraClientRoutingErrorHandling">Sucrase, Hasura Client, Routing ve Error Handling</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraUserRegisterRoute">User Register Route</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraJWTAuthRegister">Hasura JWT Authentication (Register)</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraJWTAuthLogin">Hasura JWT Authentication (Login)</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraMeQuery">Me Query</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraPermissions">Hasura Permissions</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraComputedFields">Computed Fields</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraEventTrigers">Event Triggers</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraMeetingApproveInvitation">Meeting Approve Invitation</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraOneOffScheduledEvents1">One Off Scheduled Events - 1</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraOneOffScheduledEvents2">One Off Scheduled Events - 2</a>
                  </nav>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div class="row" id="giris">
              <div class="row" id="whatIsGraphQL">
                <h1>GraphQL Nedir? Ne DeÄŸildir?</h1>
                <p>
                  Rest Api yapÄ±sÄ±nÄ±n eksik olduÄŸu yÃ¶nleri kapatmak iÃ§in facebook ekibi tarafÄ±ndan geliÅŸtirilmiÅŸtir.
                </p>
                <p>
                  Api'dan veri Ã§ekerken sadece istediÄŸimiz sorguya uygun veri dÃ¶nmesini saÄŸlar. Bunu tek bir endpoint kullanarak yapar.
                </p>
                <p>
                  Ä°liÅŸkisel verilerle Ã§alÄ±ÅŸmasÄ± Ã§ok daha kolaydÄ±r.
                </p>
                <p>
                  GraphQL dÃ¶kÃ¼mantasyonunu kendisi otomatik olarak yapar. Sorgu sonucunun gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ arayÃ¼z de otomatik olarak oluÅŸur.
                </p>
                <p>
                  Versiyonlama yapmaya gerek yok. Eski ve yeni alanlarÄ± belirtebiliyoruz.
                </p>
                <p>
                  Websoket tanÄ±mlarÄ±nÄ± yapmak daha kolay.
                </p>
                <ul>GraphQL Terminolojisi
                  <li>Query: Bir veri kaynaÄŸÄ±na eriÅŸmek istediÄŸinizde kullanacaÄŸÄ±nÄ±z tanÄ±mdÄ±r.</li>
                  <li>Mutation: Ekleme, silme ve gÃ¼ncelleme iÅŸlemi iÃ§in kullanacaÄŸÄ±nÄ±z tanÄ±mdÄ±r.</li>
                  <li>Subscription: GerÃ§ek zamanlÄ± Ã§alÄ±ÅŸan projeler iÃ§in kullanacaÄŸÄ±nÄ±z tanÄ±mdÄ±r.</li>
                </ul>
              </div>
              <div class="row" id="apolloServer">
                <h1>Apollo Server'a GiriÅŸ</h1>
                <p>
                  <a href="https://www.apollographql.com/docs/">Apollo Server</a>, hÄ±zlÄ±ca GraphQL sunucularÄ± oluÅŸturabileceÄŸimiz, oldukÃ§a az baÄŸÄ±mlÄ±lÄ±ÄŸÄ± olan bir kÃ¼tÃ¼phanedir.
                </p>
                <p>
                  Apollo server kullanmak iÃ§in NodeJS pc de kurulu olmalÄ±.
                </p>
                <p>
                  Bir dosya oluÅŸturup aÃ§Ä±yoruz. AÃ§tÄ±ÄŸÄ±mÄ±z dosyanÄ±n iÃ§inde <pre class="prettyprint ms-0">npm init --yes</pre> yazÄ±yoruz. <code>npm init</code> bizim yeni bir proje oluÅŸturmamÄ±zÄ± saÄŸlar. <code>--yes</code> npm init sonrasÄ± sorulacak tÃ¼m sorularÄ±n default olarak otomatik doldurulmasÄ±nÄ± saÄŸlar.
                </p>
                <p>
                  Apollo server iÃ§in 2 tane baÄŸlÄ±lÄ±k gerekiyor. BunlarÄ± yÃ¼klemek iÃ§in terminale <pre class="prettyprint ms-0">npm i @apollo/server graphql</pre> yazÄ±yoruz.
                </p>
                <p>
                  ES6 import yapspÄ±nÄ± kullanabilmek iÃ§in package.json dosyasÄ±nda aÅŸaÄŸÄ±daki ekleme yapÄ±lÄ±r.
                  <pre class="prettyprint ms-0">
  {
    // ...etc.
    "type": "module",
    "scripts": {
      "start": "node index.js"
    }
    // other dependencies
  }
                  </pre>
                </p>
                <p>
                  index.js dosyasÄ± oluÅŸturulur. Ä°Ã§ine: 
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from '@apollo/server/standalone';

  // Tip (type) tanÄ±mÄ±:
  const typeDefs = `#graphql
    # GraphQL dizelerindeki yorumlar (bunun gibi) kare (#) simgesiyle baÅŸlar.
    # Bu "Book" tÃ¼rÃ¼, veri kaynaÄŸÄ±mÄ±zdaki her kitap iÃ§in sorgulanabilir alanlarÄ± tanÄ±mlar.

    type Book {
      title: String
      author: String
    }


    # "Query" tÃ¼rÃ¼ Ã¶zeldir: istemcilerin yÃ¼rÃ¼tebileceÄŸi tÃ¼m kullanÄ±labilir sorgularÄ± ve her birinin dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼ listeler. Bu durumda, "books" sorgusu sÄ±fÄ±r veya daha fazla Book'tan (yukarÄ±da tanÄ±mlanmÄ±ÅŸtÄ±r) oluÅŸan bir dizi dÃ¶ndÃ¼rÃ¼r.
    type Query {
      books: [Book]
    }
    # data tipi ne ise ona ona uygun dÃ¼zenlenmeli. Bu Ã¶rnekte data tipi array olduÄŸundan "[]" iÃ§ine yazÄ±ldÄ±.
  `;
  // data:
  const books = [
    {
      title: "The Awakening",
      author: "Kate Chopin",
    },
    {
      title: "City of Glass",
      author: "Paul Auster",
    },
    {
      title: "YabancÄ±",
      author: "Albert Camus",
    },
  ];

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      books: () => books,
    },
  };

  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`ğŸš€  Server ready at: ${url}`);

                  </pre>
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm start</pre> yazdÄ±ÄŸÄ±mÄ±zda terminalde "ğŸš€  Server ready at: http://localhost:4000/" Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶rÃ¼rÃ¼z.
                </p>
                <p>
                  http://localhost:4000/ adresine gittiÄŸimizde bizi sorgu yapmak iÃ§in hazÄ±r bir arayÃ¼z ve dÃ¶kÃ¼mantasyon karÅŸÄ±lar.
                </p>
                <p> Bu arayÃ¼ze
                  <pre class="prettyprint ms-0">
  query ExampleQuery {
    books {
      title
    }
  }
                  </pre> yazarak datamÄ±zdaki kitap adlarÄ±na ulaÅŸabiliriz.
                </p> 
                <p>
                  Bu sayfada gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z arayÃ¼zÃ¼, daha sÄ±k kullanÄ±lan graphql playground arayÃ¼zÃ¼ ile deÄŸiÅŸtirmek iÃ§in <a href="https://www.apollographql.com/docs/apollo-server/api/plugin/landing-pages/#graphql-playground-landing-page">bu yÃ¶nerge</a> takip edilebilir ancak yapÄ±mcÄ±lar bunu Ã¶nermiyor.
                </p>
                <p>
                  Kodu her gÃ¼ncellediÄŸimizde serveri manuel restart etmemek iÃ§in nodemon kurduk. Bunun iÃ§in terminale <pre class="prettyprint ms-0">npm i --save-dev nodemon</pre> yazdÄ±k ve package.json>scripts alanÄ±na <pre class="prettyprint ms-0">"dev": "nodemon index.js",</pre> ekledik. Terminale <pre class="prettyprint ms-0">npm run dev</pre> yazarak serveri baÅŸlattÄ±ÄŸÄ±mÄ±zda her gÃ¼ncellemede kendini resetler.
                </p>
              </div>
              <div class="row" id="nonNullableFields">
                <h1>Non Nullable Fields</h1>
                <p>
                  GraphQL resolver tanÄ±mlarÄ±nÄ±z Ã¼zerinde null dÃ¶nmemesini istediÄŸiniz bir field veya tip varsa bunun iÃ§in bir tanÄ±m yapabilirsiniz. "!" ile ifade edilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  ...
  type Book {
      title: String!
      author: String
    }
  ...

                  </pre>
                  ifadesi title alanÄ±nÄ±n null dÃ¶nemeyeceÄŸini ifade eder.
                </p> 
                <p>
                  <pre class="prettyprint ms-0">
  ...
  type Query {
    books: [Book]!
  }
  ...
                  </pre>
                  ifadesi books sorgusunun null dÃ¶nemeyeceÄŸini ifade eder.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  ...
  type Query {
    books: [Book!]!
  }
  ...
                  </pre>
                  ifadesi books sorgusunu sonucunda gelen array iÃ§inde null eleman olamayacaÄŸÄ±nÄ± ifade eder.
                </p>
              </div>
              <div class="row" id="scalarTypes">
                <h1>Scalar Types</h1>
                <ul>GraphQL'nin varsayÄ±lan skaler tÃ¼rleri ÅŸunlardÄ±r:
                  <li>Int</li>
                  <li>Float</li>
                  <li>String</li>
                  <li>Boolean</li>
                  <li>ID</li>
                </ul>
                <p> Ã–rnek kullanÄ±m:
                  <pre class="prettyprint ms-0">
  ...
  type Book {
    id: ID!
    title: String!
    author: String
    score: Float
    isPublished: Boolean
  }
  ...
                  </pre>
                  <pre class="prettyprint ms-0">
  const books = [
    {
      id: 1,
      title: "The Awakening",
      author: "Kate Chopin",
      score: 6.9,
      isPublished: true
    },
  ...
                  </pre>
                </p>
              </div>
              <div class="row" id="customTypes">
                <h1>Custom Types</h1>
                <p>
                  Girilen verinin tipini girerken aÅŸaÄŸÄ±daki gibi tek tek girebiliriz:
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type Query {
      name: String!
      surname: String!
      age: Int
    }
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      name: () => "Murat",
      surname: () => "GÃ¶kduman",
      age: () => 29,
    },
  };
                  </pre> bunun yerine User iÃ§in bir tip tanÄ±mÄ± oluÅŸturup bunu da geÃ§ebiliriz.
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type User {
      name: String!
      surname: String!
      age: Int
    }
    type Query {
      user: User
    }
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      user: () => ({
        name: "Murat",
        surname: "GÃ¶kduman",
        age: 29,
      }),
    },
  };
                  </pre> bu yazÄ±mda User bir custom type'dÄ±r. Daha Ã¶nceki Ã¶rneklerdeki Book da bir custom type'dir.
                </p>
                <p>
                  Bu durumda yeni bir veri girmek istersek ancak User iÃ§ine dahil etmezsek veri ayrÄ±ca tiplendirilip resorve edilebilir.
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type User {
      name: String!
      surname: String!
      age: Int
    }
    type Query {
      user: User
      hello: String!
    }
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      user: () => ({
        name: "Murat",
        surname: "GÃ¶kduman",
        age: 29,
      }),
      hello: () => "world"
    },
  };
                  </pre>
                </p>
                <p>
                  localhost:4000 iÃ§inde aÅŸaÄŸÄ±daki sorgu yapÄ±ldÄ±ÄŸÄ±nda
                  <pre class="prettyprint ms-0">
  Query {
    hello
    user {
      name
      surname
    }
  }
                  </pre>
                  AÅŸaÄŸÄ±daki cevap alÄ±nÄ±r.
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "hello": "world",
      "user": {
        "name": "Murat",
        "surname": "GÃ¶kduman"
      }
    }
  }
                  </pre>
                </p>
                <p>
                  Custom type baÅŸka bir custom type iÃ§inde type olarak da kullanÄ±labilir.
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books: [Book!]
    }

    type Book {
      id: ID!
      title: String!
      author: Author!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      book: [Book]
    }
    
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      book: () => books,
    },
  };
                  </pre>
                </p>
              </div>
              <div class="row" id="argumans">
                <h1>ArgÃ¼manlar ile Ã‡alÄ±ÅŸmak</h1>
                <p>
                  HazÄ±rlÄ±k olarak Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z datalarÄ± data.js dosyasÄ±na taÅŸÄ±dÄ±k ve index.js iÃ§ine import ettik.
                </p>
                <p>
                  data.js
                  <pre class="prettyprint ms-0">
  export const authors = [
    {
      id: 3,
      name: "Kate Chopin",
      score: 8,
      books: [],
    },
    {
      id: 2,
      name: "Paul Auster",
      score: 3,
      books: [],
    },
    {
      id: 1,
      name: "Albert Camus",
      score: 5,
      books: [],
    },
  ];

  export const books = [
    {
      id: 1,
      title: "The Awakening",
      author: authors[0],
      score: 6.9,
      isPublished: true,
    },
    {
      id: 2,
      title: "City of Glass",
      author: authors[1],
      score: 7,
    },
    {
      id: 3,
      title: "YabancÄ±",
      author: authors[2],
      isPublished: false,
    },
  ];
                  </pre>
                </p>
                <p>
                  id den kitap sorgulama ve id den yazar sorgulama iÃ§in typeQuery alanÄ±na ilgili tip tanÄ±mlarÄ± yapÄ±ldÄ±. SonrasÄ±nda bu tip tanÄ±mlarÄ±na uygun resolve lar tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";

  // data:
  import { books, authors } from "./data.js";

  // Tip (type) tanÄ±mÄ±:
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books: [Book!]
    }

    type Book {
      id: ID!
      title: String!
      author: Author!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      books: [Book!]
      book(id: ID!): Book!
      
      authors: [Author!]
      author(id: ID!): Author!
    }
    
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      books: () => books,
      book: (parent, args) => {
        //4 parametre alÄ±r: 1. parent: iliÅŸkisel veri tabanÄ± oluÅŸtururken kullanacaÄŸÄ±z. 2. prametre istemciden gelen argÃ¼manÄ± verir.
        const data = books.find((book) => book.id == args.id);
        return data;
      },

      authors: () => authors,
      author: (parent, args) => {
        const data = authors.find((author) => author.id == args.id);
        return data;
      }
    },
  };

  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`ğŸš€  Server ready at: ${url}`);

                  </pre>
                </p>
                <p>
                  resolver alanÄ±nda alÄ±nan 2. parametre sorguda bize gÃ¶nderilen parametredir. Bundan faydalanarak bir find iÅŸlemi yapÄ±ldÄ± ve gelen veri dÃ¶nÃ¼ldÃ¼.
                </p>
                <p>
                  AÅŸaÄŸÄ±daki sorgu yapÄ±ldÄ±ÄŸÄ±nda
                  <pre class="prettyprint ms-0">
  query{
    author (id: 1){
      name
    }
    book(id: 3) {
      title
      author {
        name
      }
    }
  }
                  </pre>
                  aÅŸaÄŸÄ±daki sonuÃ§ alÄ±nÄ±r
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "author": {
        "name": "Albert Camus"
      },
      "book": {
        "title": "YabancÄ±",
        "author": {
          "name": "Albert Camus"
        }
      }
    }
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="iliskiselData">
                <h1>Ä°liÅŸkisel Veriler ile Ã‡alÄ±ÅŸmak</h1>
                <p>
                  Sorgu sÄ±rasÄ±nda birbiri ile alakalÄ± iki veriyi birbirine baÄŸlamak mÃ¼mkÃ¼n. Bunun iÃ§in aranacak karÅŸÄ±lÄ±k data alanÄ±ndan silinir. Daha sonra resolvers iÃ§inde iliÅŸkisi kurulur.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";

  // data:
  import { books, authors } from "./data.js";

  // Tip (type) tanÄ±mÄ±:
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books: [Book!]
    }

    type Book {
      id: ID!
      title: String!
      author: Author
      author_id: ID!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      books: [Book!]
      book(id: ID!): Book!
      
      authors: [Author!]
      author(id: ID!): Author!
    }
    
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      books: () => books,
      book: (parent, args) => books.find((book) => book.id === args.id),
      
      authors: () => authors,
      author: (parent, args) => authors.find((author) => author.id === args.id),
    },
    Book: {
      // Book tipi altÄ±ndaki author keyi iÃ§in girilen resolver.
      author: (
        parent, // parent sorgunun yapÄ±ldÄ±ÄŸÄ± parent tipin deÄŸerini dÃ¶ner.
        args 
      ) => authors.find((author) => author.id === parent.author_id),
    },
    Author: {
      books: (parent, args) =>
        books.filter((book) => book.author_id === parent.id),
    },
  };

  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`ğŸš€  Server ready at: ${url}`);

                  </pre>
                </p>
                <p>
                  tip alanÄ±nda istenilen veri keyi veri tipi ile baÄŸlantÄ±lanÄ±r.
                </p>
                <p>
                  resolver alanÄ±nda hangi tipin altÄ±nda hangi sorgu yapÄ±lÄ±rsa nasÄ±l bir verinin Ã§ekileceÄŸi tanÄ±mlanÄ±r.
                </p>
                <p>
                  Book altÄ±nda author sorgulandÄ±ÄŸÄ±nda parent alanÄ±ndan aldÄ±ÄŸÄ± author_id ile authors iÃ§inde data arar.
                </p>
                <p>
                  Author altÄ±nda books sorgulandÄ±ÄŸÄ±nda books iÃ§inde author_id deÄŸeri barent.id ile uyumlu olanlarÄ± filtreler.
                </p>
              </div>
              <div class="row" id="iliskiselDataArgumanlar">
                <h1>Ä°liÅŸkisel Ä°fadelerde ArgÃ¼manlar</h1>
                <p>
                  Author altÄ±nda books sorgusuna ilk harfe gÃ¶re filtreleme Ã¶zelliÄŸi eklemek iÃ§in aÅŸaÄŸÄ±daki Ã¶rneÄŸi yaptÄ±k.
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";

  // data:
  import { books, authors } from "./data.js";
                  </pre>
                  <pre class="prettyprint ms-0">
  // Tip (type) tanÄ±mÄ±:
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books(filter: String): [Book!] # filtreleme iÅŸlemi iÃ§in
    }
                  </pre> books iÃ§in parametre alabilme Ã¶zelliÄŸi ve alacaÄŸÄ± parametrenin veri tipi belirtildi.
                  <pre class="prettyprint ms-0">
  type Book {
      id: ID!
      title: String!
      author: Author
      author_id: ID!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      books: [Book!]
      book(id: ID!): Book!
      
      authors: [Author!]
      author(id: ID!): Author!
    }
    
  `;

  // resolvers (Ã§Ã¶zÃ¼cÃ¼):
  const resolvers = {
    Query: {
      books: () => books,
      book: (parent, args) => books.find((book) => book.id === args.id),

      authors: () => authors,
      author: (parent, args) => authors.find((author) => author.id === args.id),
    },
    Book: {
      author: (parent, args) =>
        authors.find((author) => author.id === parent.author_id),
    },
                  </pre>
                  <pre class="prettyprint ms-0">
  Author: {
      books: (parent, args) => {
        let filtered = books.filter((book) => book.author_id === parent.id);

        if (args.filter) { // sorguda filter var ise
          filtered = filtered.filter((book) =>
            book.title.toLowerCase().startsWith(args.filter.toLowerCase()) // args.filter verisine gÃ¶re filtreler.
          );
        }
        return filtered;
      },
    },
  };
                  </pre> sorguda book iÃ§in filter parametresi geÃ§ildiyse ilk harfe gÃ¶re filtreleme yapÄ±lÄ±r.
                  <pre class="prettyprint ms-0">
  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`ğŸš€  Server ready at: ${url}`);
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="mutations">
              <div class="row" id="whatIsMutation">
                <h1>Mutation Nedir? NasÄ±l YazÄ±lÄ±r?</h1>
                <p>
                  Mutation tanÄ±mÄ±, GraphQL sunucularÄ± Ã¼zerinde veri ekleme,silme veya gÃ¼ncelleme durumlarÄ±nda kullanÄ±lÄ±r.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid"; // user id iÃ§in gerekli
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
      type User {
          id: ID!
          fullName: String!
          posts: [Post]
          comments: [Comment]
      }
  
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
  
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
  
      type Query {
          users: [User!]!
          user(id: ID!): User!
  
          posts: [Post!]
          post(id: ID!): Post!
  
          comments: [Comment]
          comment(id: ID!): Comment!
      }
  
      type Mutation {
        createUser(fullName: String!): User! #createUser parametre olarak fullName keyi ile string alÄ±r. response olarak User dÃ¶ner.
        createPost(title: String!, user_id: ID!): Post!
        createComment(text: String!, post_id: ID!, user_id: ID!): Comment!
      }
  `;
  
  const resolvers = {
    Mutation: {
      createUser: (parent, args) => {
        // yeni user ekleme
        const user = {
          id: nanoid(),
          fullName: args.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      createPost: (parent, args) => {
        // yeni post ekleme
        const post = { id: nanoid(), title: args.title, user_id: args.user_id };
  
        posts.push(post);
  
        return post;
      },
      createComment: (parent, { text, post_id, user_id }) => {
        //args destruct edildi
        // yeni comment ekleme
        const comment = {
          id: nanoid(),
          text, // parametre key ve value aynÄ± olduÄŸundan tek kelimeyle yazÄ±labilir.
          post_id,
          user_id,
        };
  
        comments.push(comment);
  
        return comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`ğŸš€  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="inputType">
                <h1>Input Type</h1>
                <p>
                  Mutation iÃ§in yazÄ±lan parametre tanÄ±mlarÄ±, kdun temiz kalmasÄ± iÃ§in, baÅŸka bir alanda yazÄ±labilir. Bu alan input tanÄ±mÄ± ile baÅŸlar. Parametre iÃ§inde data ketyi ile karÅŸÄ±lanÄ±r.
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid"; // user id iÃ§in gerekli
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
  
      type User {
          id: ID!
          fullName: String!
          posts: [Post]
          comments: [Comment]
      }
  
      input CreateUserInput { # createUser mutationu iÃ§in parametre tanÄ±mlarÄ±.
        fullName: String!
      }
  
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
      input CreatePostInput { # createPost mutationu iÃ§in parametre tanÄ±mlarÄ±.
        title: String!
        user_id: ID!
      }
  
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
      input CreateCommetInput{
        text: String!
        post_id: ID!
        user_id: ID!
      }
  
      type Query {
          users: [User!]!
          user(id: ID!): User!
  
          posts: [Post!]
          post(id: ID!): Post!
  
          comments: [Comment]
          comment(id: ID!): Comment!
      }
  
      type Mutation {
        createUser(data: CreateUserInput!): User! #input type tanÄ±mÄ± data keyi ile geÃ§ilir.
        createPost(data: CreatePostInput!): Post!
        createComment(data: CreateCommetInput!): Comment!
      }
  `;
  
  const resolvers = {
    Mutation: {
      createUser: (parent, args) => {
        // yeni user ekleme
        const user = {
          id: nanoid(),
          fullName: args.data.fullName, // gelen arguman data altÄ±nda gelir.
        };
  
        users.push(user);
  
        return user;
      },
      createPost: (parent, { data: { title, user_id } }) => {
        //args.data destruct edildi
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data, // data iÃ§indeki veri obje olarak tamamen eklendi.
        };
  
        comments.push(comment);
  
        return comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`ğŸš€  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="updateMutations">
                <h1>Update Mutations</h1>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
    # User
    type User {
        id: ID!
        fullName: String!
        age: Int!
        posts: [Post]
        comments: [Comment]
    }
  
    input CreateUserInput { 
      fullName: String!
      age: Int!
    }
  
    input UpdateUserInput {
      fullName: String
      age: Int
    }
  
    # Post
    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { 
      title: String!
      user_id: ID!
    }
    input UpdatePostInput {
      title: String
      user_id: ID
    }
  
    # Comment
    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }
    input UpdateCommentInput{
      text: String
      post_id: ID
      user_id: ID
    }
  
    type Query {
        users: [User!]!
        user(id: ID!): User!
  
        posts: [Post!]
        post(id: ID!): Post!
  
        comments: [Comment]
        comment(id: ID!): Comment!
    }
  
    type Mutation {
      # User
      createUser(data: CreateUserInput!): User! 
      updateUser(id: ID!, data: UpdateUserInput!): User!
      # Post
      createPost(data: CreatePostInput!): Post!
      updatePost(id: ID!, data: UpdatePostInput!): Post
  
      # Comment
      createComment(data: CreateCommetInput!): Comment!
      updateComment(id: ID!, data: UpdateCommentInput!): Comment!
    }
  `;
  
  const resolvers = {
    Mutation: {
      // User
      createUser: (parent, args) => {
        const user = {
          id: nanoid(),
          fullName: args.data.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      updateUser: (parent, { id, data }) => {
        const user_index = users.findIndex((user) => user.id === id);
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const update_user = (users[user_index] = {
          ...users[user_index], // Ã¶nce mevcut tanÄ±mlarÄ± al
          ...data, // data altÄ±ndan gelenlerle merge et.
        });
  
        return update_user;
      },
      // Post
      createPost: (parent, { data: { title, user_id } }) => {
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      updatePost: (parent, { id, data }) => {
        const post_index = posts.findIndex((post) => post.id === id);
  
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const updated_post = (posts[post_index] = {
          ...posts[post_index],
          ...data,
        });
  
        return updated_post;
      },
      // Comment
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data,
        };
  
        comments.push(comment);
  
        return comment;
      },
      updateComment: (parent, { id, data }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
  
        if (comment_index === -1) {
          throw new Error("Comment not found.");
        }
  
        const updated_comment = (comments[comment_index] = {
          ...comments[comment_index],
          ...data,
        });
  
        return updated_comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`ğŸš€  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="deleteMutations">
                <h1>Delete Mutations</h1>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
    # User
    type User {
        id: ID!
        fullName: String!
        age: Int!
        posts: [Post]
        comments: [Comment]
    }
  
    input CreateUserInput { 
      fullName: String!
      age: Int!
    }
  
    input UpdateUserInput {
      fullName: String
      age: Int
    }
  
    # Post
    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { 
      title: String!
      user_id: ID!
    }
    input UpdatePostInput {
      title: String
      user_id: ID
    }
  
    # Comment
    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }
    input UpdateCommentInput{
      text: String
      post_id: ID
      user_id: ID
    }
  
    type Query {
        users: [User!]!
        user(id: ID!): User!
  
        posts: [Post!]
        post(id: ID!): Post!
  
        comments: [Comment]
        comment(id: ID!): Comment!
    }
  
    type Mutation {
      # User
      createUser(data: CreateUserInput!): User! 
      updateUser(id: ID!, data: UpdateUserInput!): User!
      deleteUser(id: ID!): User!
      # Post
      createPost(data: CreatePostInput!): Post!
      updatePost(id: ID!, data: UpdatePostInput!): Post!
      deletePost(id: ID!): Post!
  
      # Comment
      createComment(data: CreateCommetInput!): Comment!
      updateComment(id: ID!, data: UpdateCommentInput!): Comment!
      deleteComment(id: ID!): Comment!
    }
  `;
  
  const resolvers = {
    Mutation: {
      // User
      createUser: (parent, args) => {
        const user = {
          id: nanoid(),
          fullName: args.data.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      updateUser: (parent, { id, data }) => {
        const user_index = users.findIndex((user) => user.id === id);
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const update_user = (users[user_index] = {
          ...users[user_index],
          ...data,
        });
  
        return update_user;
      },
      deleteUser: (parent, { id }) => {
        // silme iÅŸlemi iÃ§in: 1. filter metodunda id si parent.id olmayanlarÄ± filtreleyip users'a atayabiliriz. 2. indexini bulup slice ile Ã§Ä±kartabiliriz.
        const user_index = users.findIndex((user) => user.id === id); // bu idye sahip kullanÄ±cÄ± var mÄ±?
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const deleted_user = users[user_index]; // silinecek olanÄ± ayrÄ± bir yere kaydettik
  
        users.splice(user_index, 1); //splice iki parametre alÄ±r. Silinecek olanÄ±n indexi ve indexten itibaren kaÃ§ eleman silineceÄŸi. 3 parametre olarak da yerine eklenecek Ã¶geyi alabilir.
  
        return deleted_user;
      },
      // Post
      createPost: (parent, { data: { title, user_id } }) => {
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      updatePost: (parent, { id, data }) => {
        const post_index = posts.findIndex((post) => post.id === id);
  
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const updated_post = (posts[post_index] = {
          ...posts[post_index],
          ...data,
        });
  
        return updated_post;
      },
      deletePost: (parent, { id }) => {
        const post_index = posts.findIndex((post) => post.id === id);
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const deleted_post = posts[post_index];
  
        posts.splice(post_index, 1);
  
        return deleted_post;
      },
  
      // Comment
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data,
        };
  
        comments.push(comment);
  
        return comment;
      },
      updateComment: (parent, { id, data }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
  
        if (comment_index === -1) {
          throw new Error("Comment not found.");
        }
  
        const updated_comment = (comments[comment_index] = {
          ...comments[comment_index],
          ...data,
        });
  
        return updated_comment;
      },
      deleteComment: (parent, { id }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
        if (comment_index === -1) {
          throw new Error("Comment not found");
        }
  
        const deleted_comment = comments[comment_index];
  
        comments.splice(comment_index, 1);
        
        return deleted_comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`ğŸš€  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="deleteAllMutations">
                <h1>Delete All Mutations</h1>
                <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
    # User
    type User {
        id: ID!
        fullName: String!
        age: Int!
        posts: [Post]
        comments: [Comment]
    }
  
    input CreateUserInput { 
      fullName: String!
      age: Int!
    }
  
    input UpdateUserInput {
      fullName: String
      age: Int
    }
  
    # Post
    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { 
      title: String!
      user_id: ID!
    }
    input UpdatePostInput {
      title: String
      user_id: ID
    }
  
    # Comment
    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }
    input UpdateCommentInput{
      text: String
      post_id: ID
      user_id: ID
    }
  
    type DeleteAllOutput {
      count: Int!
    }
  
    type Query {
        users: [User!]!
        user(id: ID!): User!
  
        posts: [Post!]
        post(id: ID!): Post!
  
        comments: [Comment]
        comment(id: ID!): Comment!
    }
  
    type Mutation {
      # User
      createUser(data: CreateUserInput!): User! 
      updateUser(id: ID!, data: UpdateUserInput!): User!
      deleteUser(id: ID!): User!
      deleteAllUsers: DeleteAllOutput!
      # Post
      createPost(data: CreatePostInput!): Post!
      updatePost(id: ID!, data: UpdatePostInput!): Post!
      deletePost(id: ID!): Post!
      deleteAllPosts: DeleteAllOutput!
  
      # Comment
      createComment(data: CreateCommetInput!): Comment!
      updateComment(id: ID!, data: UpdateCommentInput!): Comment!
      deleteComment(id: ID!): Comment!
      deleteAllComments: DeleteAllOutput!
    }
  `;
  
  const resolvers = {
    Mutation: {
      // User
      createUser: (parent, args) => {
        const user = {
          id: nanoid(),
          fullName: args.data.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      updateUser: (parent, { id, data }) => {
        const user_index = users.findIndex((user) => user.id === id);
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const update_user = (users[user_index] = {
          ...users[user_index],
          ...data,
        });
  
        return update_user;
      },
      deleteUser: (parent, { id }) => {
        const user_index = users.findIndex((user) => user.id === id); 
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const deleted_user = users[user_index]; 
  
        users.splice(user_index, 1); 
  
        return deleted_user;
      },
      deleteAllUsers: () => {
        const length = users.length;
        // users = []; // users tanÄ±mlanÄ±rken const ile tanÄ±mlandÄ±ÄŸÄ±ndan bu method Ã§alÄ±ÅŸmaz. Bunun Ã§alÄ±ÅŸabilmesi iÃ§iin const ifadesi let ile deÄŸiÅŸtirilebilir veya farklÄ± bir metod kullanÄ±labilir.
  
        users.splice(0, length); // 0 dan baÅŸlayÄ±p tÃ¼m elemanlarÄ± siler
  
        return {
          count: length,
        };
      },
      // Post
      createPost: (parent, { data: { title, user_id } }) => {
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      updatePost: (parent, { id, data }) => {
        const post_index = posts.findIndex((post) => post.id === id);
  
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const updated_post = (posts[post_index] = {
          ...posts[post_index],
          ...data,
        });
  
        return updated_post;
      },
      deletePost: (parent, { id }) => {
        const post_index = posts.findIndex((post) => post.id === id);
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const deleted_post = posts[post_index];
  
        posts.splice(post_index, 1);
  
        return deleted_post;
      },
      deleteAllPosts: () => {
        const length = posts.length;
  
        posts.splice(0, length);
  
        return {
          count: length,
        };
      },
  
      // Comment
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data,
        };
  
        comments.push(comment);
  
        return comment;
      },
      updateComment: (parent, { id, data }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
  
        if (comment_index === -1) {
          throw new Error("Comment not found.");
        }
  
        const updated_comment = (comments[comment_index] = {
          ...comments[comment_index],
          ...data,
        });
  
        return updated_comment;
      },
      deleteComment: (parent, { id }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
        if (comment_index === -1) {
          throw new Error("Comment not found");
        }
  
        const deleted_comment = comments[comment_index];
  
        comments.splice(comment_index, 1);
  
        return deleted_comment;
      },
      deleteAllComments: () => {
        const length = comments.length;
        comments.splice(0, length);
        return {
          count: length,
        };
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`ğŸš€  Server ready at: ${url}`);
  
                </pre>
              </div>
            </div>
            <div class="row" id="subscription">
              <div class="row" id="subscriptionServerSetup">
                <h1>Subscription Server Kurulumu</h1>
                <p>
                  Subscription tanÄ±mÄ± gerÃ§ekleÅŸen olaylardan(ekleme,silme,gÃ¼ncelleme vb.) gerÃ§ek zamanlÄ± olarak haberdar olabileceÄŸimiz WebSocket tabanlÄ± bir yapÄ±dÄ±r.
                </p>
                <p>
                  Apollo Server'Ä±n 3. versiyonu ile birlikte Subscription yapÄ±sÄ± core Ã¼zerinden kaldÄ±rÄ±ldÄ± ancak ek kÃ¼tÃ¼phaneler ekleyerek bunu yeniden aktifleÅŸtirebilirsiniz. Bu iÅŸlem sÄ±rasÄ±nda birden fazla kÃ¼tÃ¼phanenin kurulmasÄ± gerekiyor ve kod biraz daha karmaÅŸÄ±k gÃ¶rÃ¼nÃ¼yor. Bundan kurtulmak iÃ§in <a href="https://github.com/dotansimha/graphql-yoga">graphql yoga</a> adÄ±nda bir kÃ¼tÃ¼phaneden faydalanacaÄŸÄ±z.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">npm i graphql-yoga</pre> yazÄ±yoruz
                </p>
                <p>
                  Dersin videosu gÃ¼ncel deÄŸil. Biz kendi yolumuzu bulacaÄŸÄ±z. <a href="https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions">Bunu</a> uyguladÄ±k.
                </p>
                <p>
                  <a href="https://github.com/dotansimha/graphql-yoga/blob/main/examples/subscriptions/src/index.ts">Bu</a> da kullanÄ±labilir. AynÄ± methodun farklÄ± yazÄ±lmÄ±ÅŸÄ±.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga"; //graphql-yoga iÃ§inden gerekenler import edildi.
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub(); // YayÄ±n iÃ§in gereken middleware
  
  const yoga = createYoga({
    // ÅemayÄ± sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Ã–rnek iÃ§in
          userCreated: User!
        }
      `,
      resolvers: {
        Subscription: {
          // count: { // Ã–rnek
          //   subscribe: () => { // Her saniye deÄŸeri 1 arttÄ±rÄ±p iletir
          //     let count = 0;
  
          //     setInterval(() => {
          //       count++;
          //       pubSub.publish("count", {count});
          //     }, 1000);
  
          //     return pubSub.subscribe("count")
          //   }
          // }
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"), // kanala abone olduk.
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age
            };
  
            users.push(user);
            pubSub.publish("userCreated", {"userCreated": user}); // yayÄ±n yapÄ±ldÄ±.
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
  
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length); 
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
  
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
  
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="userCRUDsubs">
                <h1>User CRUD Subscriptions</h1>
                <p>
                  YukarÄ±daki iÅŸlemleri diÄŸer user Crud iÅŸlemlerine uyarladÄ±k.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // ÅemayÄ± sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Ã–rnek iÃ§in
  
          # User
          userCreated: User!
          userUpdated: User!
          userDeleted: User!
  
        }
      `,
      resolvers: {
        Subscription: {
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"),
          },
          userUpdated: {
            subscribe: () => pubSub.subscribe("userUpdated"), // yayÄ±na abone olundu
          },
          userDeleted: {
            subscribe: () => pubSub.subscribe("userDeleted"), // yayÄ±na abone olundu
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age,
            };
  
            users.push(user);
            pubSub.publish("userCreated", { userCreated: user });
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
            pubSub.publish("userUpdated", { userUpdated: update_user, }); //yayÄ±n yapÄ±ldÄ±
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            pubSub.publish("userDeleted", { userDeleted: deleted_user }); // yayÄ±n yapÄ±ldÄ±
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length);
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
  
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
  
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="postVeCommentCRUDsubs">
                <h1>Post ve Comment CRUD Subscriptions</h1>
                <p>
                  YukarÄ±daki iÅŸlemi post ve comment iÃ§in tekrarlÄ±yoruz.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // ÅemayÄ± sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Ã–rnek iÃ§in
  
          # User
          userCreated: User!
          userUpdated: User!
          userDeleted: User!
  
          # Post
          postCreated: Post!
          postUpdated: Post!
          postDeleted: Post!
          postsCount: Int!
  
          # Comment
          commentCreated: Comment!
          commentUpdated: Comment!
          commentDeleted: Comment!
        }
      `,
      resolvers: {
        Subscription: {
          // User
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"),
          },
          userUpdated: {
            subscribe: () => pubSub.subscribe("userUpdated"),
          },
          userDeleted: {
            subscribe: () => pubSub.subscribe("userDeleted"),
          },
  
          // Post
          postCreated: {
            subscribe: () => pubSub.subscribe("postCreated"),
          },
          postUpdated: {
            subscribe: () => pubSub.subscribe("postUpdated"),
          },
          postDeleted: {
            subscribe: () => pubSub.subscribe("postDeleted"),
          },
          postsCount: {
            subscribe: () => {
              setTimeout(() => {
                pubSub.publish("postsCount", { postsCount: posts.length })
              }); // publish iÅŸlemi subscribe iÅŸleminden sonra olmalÄ±. Bu nedenle geÃ§ikme koyduk
              return pubSub.subscribe("postsCount");
            },
          },
  
          // Comment
          commentCreated: {
            subscribe: () => pubSub.subscribe("commentCreated"),
          },
          commentUpdated: {
            subscribe: () => pubSub.subscribe("commentUpdated"),
          },
          commentDeleted: {
            subscribe: () => pubSub.subscribe("commentDeleted"),
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age,
            };
  
            users.push(user);
            pubSub.publish("userCreated", { userCreated: user });
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
            pubSub.publish("userUpdated", { userUpdated: update_user }); //yayÄ±n yapÄ±ldÄ±
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            pubSub.publish("userDeleted", { userDeleted: deleted_user }); // yayÄ±n yapÄ±ldÄ±
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length);
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            pubSub.publish("postCreated", { postCreated: post });
            pubSub.publish("postsCount", { postsCount: posts.length });
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            pubSub.publish("postUpdated", { postUpdated: updated_post });
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
            pubSub.publish("postDeleted", { postDeleted: deleted_post });
            pubSub.publish("postsCount", { postsCount: posts.length });
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
            pubSub.publish("postsCount", { postsCount: posts.length });
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            pubSub.publish("commentCreated", { commentCreated: comment });
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
            pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="withFilter">
                <h1>withFilter ile Subscription Filtreleme</h1>
                <p>
                  Subscription sÄ±rasÄ±nda paraametre ile filtreleme yapacaÄŸÄ±z.
                </p>
                <p>
                  biz v4 kullanÄ±yoruz. hocanÄ±n methodu bizde iÅŸe yaramÄ±yor. Bu nedenle dÃ¶kÃ¼mantasyondan <a href="https://the-guild.dev/graphql/yoga-server/docs/migration/migration-from-yoga-v1">buradan</a> ve <a href="https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions#filter-and-map-values">buradan</a> faydalanarak kendi kodumuzu yazÄ±yoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import {
    createYoga,
    createSchema,
    createPubSub,
    filter,
    pipe,
    map,
  } from "graphql-yoga"; //filter ve pipe subscription filtreleme iÃ§in import edildi.
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // ÅemayÄ± sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Ã–rnek iÃ§in
  
          # User
          userCreated: User!
          userUpdated: User!
          userDeleted: User!
  
          # Post
          postCreated(user_id: ID): Post! #postCreated parametre alacak ÅŸekilde dÃ¼zenlendi.
          postUpdated: Post!
          postDeleted: Post!
          postsCount: Int!
  
          # Comment
          commentCreated(post_id: ID): Comment!
          commentUpdated: Comment!
          commentDeleted: Comment!
        }
      `,
      resolvers: {
        Subscription: {
          // User
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"),
          },
          userUpdated: {
            subscribe: () => pubSub.subscribe("userUpdated"),
          },
          userDeleted: {
            subscribe: () => pubSub.subscribe("userDeleted"),
          },
  
          // Post
          postCreated: {
            subscribe: (parent, args) => {
              return pipe(
                // pipe 2 parametre alÄ±r.
                pubSub.subscribe("postCreated"), // 1. parametre yayÄ±na abone olmak iÃ§in kullanÄ±lan fonksiyon.
                filter((value) => // 2 parametre filter. iÃ§i true dÃ¶nerse deÄŸeri yakalar. yoksa es geÃ§er.
                  args.user_id // args.user_id varsa 
                  ? value.postCreated.user_id === args.user_id // bu kÄ±yaslama yapÄ±lÄ±r. 
                  : true // args.user_id yoksa parametre geÃ§ilmemiÅŸtir. true dÃ¶ner.
                )
              );
            },
          },
          postUpdated: {
            subscribe: () => pubSub.subscribe("postUpdated"),
          },
          postDeleted: {
            subscribe: () => pubSub.subscribe("postDeleted"),
          },
          postsCount: {
            subscribe: () => {
              setTimeout(() => {
                pubSub.publish("postsCount", { postsCount: posts.length });
              });
              return pubSub.subscribe("postsCount");
            },
          },
  
          // Comment
          commentCreated: {
            subscribe: (parent, args) => {
              return pipe( // YukarÄ±daki Ã¶rneÄŸin tekrarÄ±.
                pubSub.subscribe("commentCreated"),
                filter((value) =>
                  args.post_id
                    ? value.commentCreated.post_id === args.post_id
                    : true
                )
              );
            },
          },
          commentUpdated: {
            subscribe: () => pubSub.subscribe("commentUpdated"),
          },
          commentDeleted: {
            subscribe: () => pubSub.subscribe("commentDeleted"),
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age,
            };
  
            users.push(user);
            pubSub.publish("userCreated", { userCreated: user });
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
            pubSub.publish("userUpdated", { userUpdated: update_user });
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            pubSub.publish("userDeleted", { userDeleted: deleted_user });
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length);
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            pubSub.publish("postCreated", { postCreated: post });
            pubSub.publish("postsCount", { postsCount: posts.length });
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            pubSub.publish("postUpdated", { postUpdated: updated_post });
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
            pubSub.publish("postDeleted", { postDeleted: deleted_post });
            pubSub.publish("postsCount", { postsCount: posts.length });
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
            pubSub.publish("postsCount", { postsCount: posts.length });
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            pubSub.publish("commentCreated", { commentCreated: comment });
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
            pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="redisPubsub">
                <h1>Redis PubSub (Konu Ã§Ã¶zÃ¼lemedi.)</h1>
                <p>
                  Birden fazla sunucu kullanÄ±lmasÄ± gereken durumlarda pubSub iÅŸlemlerinin sunucuda olmasÄ± diÄŸer sunucularda yapÄ±lan iÅŸlemleri okuyamamasÄ±na neden olur. Bu nedenle pubSub iÅŸlemleri sunucu dÄ±ÅŸÄ±nda redis Ã¼zerinde tutulabilir.
                </p>
                <p>
                  <b>Redis:</b> bir veri yapÄ±sÄ± sunucusudur. AÃ§Ä±k kaynak, bellek kullanÄ±mlÄ±, anahtar-deÄŸer deposudur. Redis "Uzak SÃ¶zlÃ¼k Sunucusu" (Ä°ngilizce: "REmote DIctionary Server") anlamÄ±na gelmektedir. Ã‡eÅŸitli kaynaklara gÃ¶re en Ã§ok kullanÄ±lan anahtar-deÄŸer veritabanÄ±dÄ±r.
                </p>
                <p>
                  Bunun iÃ§in <a href="https://github.com/davidyaha/graphql-redis-subscriptions">graphql-redis-subscriptions</a> kullanacaÄŸÄ±z. <a href="https://github.com/davidyaha/graphql-redis-subscriptions#creating-a-redis-client">buradaki</a> Ã¶rneÄŸi baz alÄ±yoruz.
                </p>
                <p>
                  terminale: <pre class="prettyprint ms-0">npm i graphql-redis-subscriptions</pre> ve <pre class="prettyprint ms-0">npm i ioredis</pre> yazÄ±yoruz.
                </p>
                <p>
                  Hoca redis iÃ§in heroku kullanmÄ±ÅŸ. heruko artÄ±k free deÄŸil. Biz <a href="https://dashboard.render.com/">render</a> kullanacaÄŸÄ±z.
                </p>
                <p>
                  new > redis > create redis
                </p>
                <p>
                  projemizin kÃ¶k dizinine pubsub.js dosyasÄ± oluÅŸturulur. Ä°Ã§ine <a href="https://github.com/davidyaha/graphql-redis-subscriptions#creating-a-redis-client">buradaki</a> Ã¶rneÄŸi yapÄ±ÅŸtÄ±rÄ±yoruz. Ä°lgili alanlarÄ± da oluÅŸturduÄŸumuz redis serverÄ±na gÃ¶re dolduruyoruz. External redis url <pre class="prettyprint ms-0">rediss://username:password@host:port</pre> kalÄ±bÄ±na gÃ¶re oluÅŸturulmuÅŸtur. Buradaki veriler Ã¶rneÄŸe uygun olarak ayrÄ±ÅŸtÄ±rÄ±lÄ±r.
                </p>
                <p>
                  KullanÄ±lan teknolojilerde Ã§akÄ±ÅŸma var. Son sÃ¼rÃ¼mler Ã§alÄ±ÅŸmÄ±yor. Daha sonra tekrar denenecek.
                </p>
                <p style="color: rgb(6, 194, 6); background-color: black; padding: 10px; font-family: monospace;">
                  birden fazla metod denendi. 5. saatin sonunda konu daha sonra irdelenmek Ã¼zere bÄ±rakÄ±ldÄ±. KullanÄ±lan iki pakette Ã§akÄ±ÅŸma mevcut. 
                </p>
              </div>
              <div class="row" id="env">
                <h1>Ortam DeÄŸiÅŸkenleri</h1>
                <p>
                  Kaynak kodumuzda gÃ¶rÃ¼nmesini istemediÄŸimiz bilgiler iÃ§in .env adÄ±nda bir dosya oluÅŸturuyoruz. Bunun iÃ§inde <pre class="prettyprint ms-0">PASS="password1234"</pre> gibi tanÄ±mÄ±mÄ±zÄ± yapÄ±yoruz. Bu bilgileri kullanmak iÃ§in terminale <pre class="prettyprint ms-0">npm i dotenv</pre> yazarak ilgili paketi kuruyoruz.
                </p>
                <p>
                  Bu bilgiyi kullanmak istediÄŸimiz dosyada <code>dotenv</code> paketini import edip Ã§alÄ±ÅŸtÄ±rÄ±yoruz.
                  <pre class="prettyprint ms-0">
  import dotenv from "dotenv"
  dotenv.config()
                  </pre>
                  ArtÄ±k .env iÃ§indeki veriyi kullanabiliriz.
                  <pre class="prettyprint ms-0">
  ...
  password: process.env.PASS
  ...
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="folderSchemaStructure">
              <div class="row" id="folderSchemaStructure1">
                <h1>Folder/Schema Structure - 1</h1>
                <p>
                  Bu ksÄ±mda index.js iÃ§indeki kodun daha dÃ¼zenli ve okunaklÄ± gÃ¶rÃ¼nmesi iÃ§in bazÄ± kÄ±sÄ±mlarÄ± baÅŸka dosyalara yÃ¼kleyip import ettik. index.js ve data.js src klasÃ¶rÃ¼ne taÅŸÄ±ndÄ±. <br>
                  Son durumda: <br>
                  index.js:
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import * as fs from "fs";
  import * as path from "path";
  import { fileURLToPath } from "url";
  
  import db from "./data.js"; // veriler import edildi
  import resolvers from "./graphql/resolvers/index.js"; // resolvers import edildi
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // ÅemayÄ± sarmala
    schema: createSchema({
      typeDefs: fs.readFileSync( // datanÄ±n olduÄŸu dosyanÄ±n okunmasÄ±
        path.join(
          path.dirname(fileURLToPath(import.meta.url)), // data yolunun ifade edilmesi
          "graphql/schema.graphql"
        ),
        "utf-8"
      ),
      resolvers,
    }),
    context: {
      pubSub,
      db, // database context iÃ§inde geÃ§ildi.
    },
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
                <p>
                  typeDefs iÃ§in graphql/schema.qraphql dosyasÄ± oluÅŸturuldu.
                  <pre class="prettyprint ms-0">
  # User
  type User {
    id: ID!
    fullName: String!
    age: Int!
    posts: [Post]
    comments: [Comment]
  }
  
  input CreateUserInput {
    fullName: String!
    age: Int!
  }
  
  input UpdateUserInput {
    fullName: String
    age: Int
  }
  
  # Post
  type Post {
    id: ID!
    title: String!
    user_id: ID!
    comments: [Comment!]
    user: User!
  }
  input CreatePostInput {
    title: String!
    user_id: ID!
  }
  input UpdatePostInput {
    title: String
    user_id: ID
  }
  
  # Comment
  type Comment {
    id: ID!
    text: String!
    post_id: ID!
    post: Post!
    user: User!
  }
  input CreateCommetInput {
    text: String!
    post_id: ID!
    user_id: ID!
  }
  input UpdateCommentInput {
    text: String
    post_id: ID
    user_id: ID
  }
  
  type DeleteAllOutput {
    count: Int!
  }
  
  type Query {
    users: [User!]!
    user(id: ID!): User!
  
    posts: [Post!]
    post(id: ID!): Post!
  
    comments: [Comment]
    comment(id: ID!): Comment!
  }
  
  type Mutation {
    # User
    createUser(data: CreateUserInput!): User!
    updateUser(id: ID!, data: UpdateUserInput!): User!
    deleteUser(id: ID!): User!
    deleteAllUsers: DeleteAllOutput!
    # Post
    createPost(data: CreatePostInput!): Post!
    updatePost(id: ID!, data: UpdatePostInput!): Post!
    deletePost(id: ID!): Post!
    deleteAllPosts: DeleteAllOutput!
  
    # Comment
    createComment(data: CreateCommetInput!): Comment!
    updateComment(id: ID!, data: UpdateCommentInput!): Comment!
    deleteComment(id: ID!): Comment!
    deleteAllComments: DeleteAllOutput!
  }
  
  type Subscription {
    # count: Int! # Ã–rnek iÃ§in
  
    # User
    userCreated: User!
    userUpdated: User!
    userDeleted: User!
  
    # Post
    postCreated(user_id: ID): Post! #postCreated parametre alacak ÅŸekilde dÃ¼zenlendi.
    postUpdated: Post!
    postDeleted: Post!
    postsCount: Int!
  
    # Comment
    commentCreated(post_id: ID): Comment!
    commentUpdated: Comment!
    commentDeleted: Comment!
  }
  
                  </pre>
                </p>
                <p>
                  data.js db adÄ±yla import edildi ve pubSub ile birlikte context iÃ§inde geÃ§ildi. Bu sayede her resolver iÃ§in ulaÅŸÄ±labilir kÄ±lÄ±ndÄ±.
                </p>
                <p>
                  src/graphql/resolvers dosyasÄ±nda tÃ¼m resolver iÅŸlemleri ayrÄ± ayrÄ± tanÄ±mlandÄ±. TanÄ±mlarda data.js den gelen veri context.db Ã¼zerinden alÄ±ndÄ±. pubSub iÅŸlemleri contex.pubSub a gÃ¶re dÃ¼zenlendi. resolvers/index.js iÃ§ine import edilip oradan topluca export edildi. <br>
                  Ã¶rnek resolvers iÃ§in: <br>
                  src/graphql/resolvers/Mutation.js
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  const Mutation = {
    // User
    createUser: (_, args, { pubSub, db }) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
        age: args.data.age,
      };
  
      db.users.push(user);
      pubSub.publish("userCreated", { userCreated: user });
  
      return user;
    },
    updateUser: (_, { id, data }, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const update_user = (db.users[user_index] = {
        ...db.users[user_index],
        ...data,
      });
      pubSub.publish("userUpdated", { userUpdated: update_user });
      return update_user;
    },
    deleteUser: (_, __, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const deleted_user = db.users[user_index];
  
      db.users.splice(user_index, 1);
  
      pubSub.publish("userDeleted", { userDeleted: deleted_user });
      return deleted_user;
    },
    deleteAllUsers: (_, __, { db }) => {
      const length = db.users.length;
  
      db.users.splice(0, length);
  
      return {
        count: length,
      };
    },
    // Post
    createPost: (_, { data: { title, user_id } }, { pubSub, db }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };
  
      db.posts.push(post);
  
      pubSub.publish("postCreated", { postCreated: post });
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return post;
    },
    updatePost: (_, { id, data }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
  
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const updated_post = (db.posts[post_index] = {
        ...db.posts[post_index],
        ...data,
      });
  
      pubSub.publish("postUpdated", { postUpdated: updated_post });
      return updated_post;
    },
    deletePost: (_, { id }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const deleted_post = db.posts[post_index];
  
      db.posts.splice(post_index, 1);
      pubSub.publish("postDeleted", { postDeleted: deleted_post });
      pubSub.publish("postsCount", { postsCount: posts.length });
  
      return deleted_post;
    },
    deleteAllPosts: (_, __, { pubSub, db }) => {
      const length = db.posts.length;
  
      db.posts.splice(0, length);
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return {
        count: length,
      };
    },
  
    // Comment
    createComment: (_, { data }, { pubSub, db }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };
  
      db.comments.push(comment);
  
      pubSub.publish("commentCreated", { commentCreated: comment });
      return comment;
    },
    updateComment: (_, { id, data }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
  
      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }
  
      const updated_comment = (db.comments[comment_index] = {
        ...db.comments[comment_index],
        ...data,
      });
      pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
      return updated_comment;
    },
    deleteComment: (_, { id }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
      if (comment_index === -1) {
        throw new Error("Comment not found");
      }
  
      const deleted_comment = db.comments[comment_index];
  
      db.comments.splice(comment_index, 1);
  
      pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
      return deleted_comment;
    },
    deleteAllComments: (_, __, { db }) => {
      const length = db.comments.length;
      db.comments.splice(0, length);
      return {
        count: length,
      };
    },
  };
  
  export default Mutation;
  
                  </pre>
                  index.js:
                  <pre class="prettyprint ms-0">
  import Comment from "./Comment.js"
  import Mutation from "./Mutation.js"
  import Post from "./Post.js"
  import Query from "./Query.js"
  import Subscription from "./Subscription.js"
  import User from "./User.js"
  
  export default {
      Mutation,
      Comment,
      Post,
      Query,
      Subscription,
      User
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="folderSchemaStructure2">
                <h1>Folder/Schema Structure - 2 (File Loader)</h1>
                <p>
                  Bu kÄ±sÄ±mda tip tanÄ±mlarÄ±mÄ±zÄ± otomatik merge edeceÄŸiz. <a href="https://the-guild.dev/graphql/tools/docs/schema-merging">doc</a>
                </p>
                <p>
                  resolver iÃ§in de dÃ¶kÃ¼manda merge uygulamasÄ± var ancak es6 iÃ§in uygulanamÄ±yor. Babeli kurduktan sonraki kÄ±sÄ±mda resolver merge iÅŸlemini tekrar yaptÄ±k ğŸ˜„
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm i @graphql-tools/load-files @graphql-tools/merge</pre> yazÄ±p gereken paketleri yÃ¼klÃ¼yoruz.
                </p>
                <p>
                  dÃ¶kÃ¼mantasyondaki <code>__dir</code> ifadesi ES6 da Ã§alÄ±ÅŸmÄ±yor. <code>path.join(__dirname)</code> yerine <code>path.dirname(fileURLToPath(import.meta.url))</code> ifadesini kullanÄ±yoruz. Bunun Ã§alÄ±ÅŸmasÄ± iÃ§in ise 
                  <pre class="prettyprint ms-0">
  import * as path from "path";
  import { fileURLToPath } from "url";
                  </pre> 
                  import iÅŸlemlerinin yapÄ±lmasÄ± gerekiyor.
                </p>
                <p>
                  tip tanÄ±mlarÄ±nÄ± src/graphql/type-defs klasÃ¶rÃ¼nÃ¼n iÃ§ine yerleÅŸtirdik ve her bir veri tipi iÃ§in ilgili tip tanÄ±mÄ±nÄ± kendine ait bir dosyaya taÅŸÄ±dÄ±k.
                  <ul>
                    <li>User.graphql</li>
                    <li>Post.graphql</li>
                    <li>Comment.graphql</li>
                    <li>global.graphql</li>
                  </ul>
                </p>
                <p>
                  Ã–rnek olarak User.graphql
                  <pre class="prettyprint ms-0">
  type Query {
    users: [User!]!
    user(id: ID!): User!
  }
  
  type Mutation {
    createUser(data: CreateUserInput!): User!
    updateUser(id: ID!, data: UpdateUserInput!): User!
    deleteUser(id: ID!): User!
    deleteAllUsers: DeleteAllOutput!
  }
  
  type Subscription {
    userCreated: User!
    userUpdated: User!
    userDeleted: User!
  }
  
  type User {
    id: ID!
    fullName: String!
    age: Int!
    posts: [Post]
    comments: [Comment]
  }
  
  input CreateUserInput {
    fullName: String!
    age: Int!
  }
  
  input UpdateUserInput {
    fullName: String
    age: Int
  }
                  </pre>
                </p>
                <p>
                  Bu tanÄ±mlarÄ± birleÅŸtirmesi (merge) iÃ§ib src/type-defs/index.js iÃ§ine:
                  <pre class="prettyprint ms-0">
  import * as path from "path";
  import { fileURLToPath } from "url";
  import { loadFilesSync } from '@graphql-tools/load-files'
  import { mergeTypeDefs } from '@graphql-tools/merge'
   
  const typesArray = loadFilesSync(path.dirname(fileURLToPath(import.meta.url)), { extensions: ['graphql'] })
   
  export default mergeTypeDefs(typesArray)
                  </pre>
                </p>
                <p>
                  src index.js iÃ§inde import edilir ve kullanÄ±lÄ±r.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./data.js";
  import resolvers from "./graphql/resolvers/index.js";
  import typeDefs from "./graphql/type-defs/index.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db,
    },
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="babelComplier">
                <h1>Babel Compiler </h1>
                <p>
                  Build iÅŸlemini gerÃ§ekleÅŸtireceÄŸiz. Bunun iÃ§in <a href="https://babeljs.io/">babel</a> kullanacaÄŸÄ±z.
                </p>
                <p>
                  <strong>Babel nedir?</strong> Babel, ECMAScript 2015+ kodunu mevcut ve eski tarayÄ±cÄ±larda veya ortamlarda geriye dÃ¶nÃ¼k olarak uyumlu bir JavaScript sÃ¼rÃ¼mÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lan bir araÃ§tÄ±r.
                </p>
                <p>
                  Babel sayesinde daha Ã¶nce ES6 da Ã§alÄ±ÅŸmayan sÃ¶z dizimleri ile ES6 bir arada yazÄ±labilir. 
                </p>
                <p>
                  <a href="https://babeljs.io/">Babeljs.io</a> iÃ§inde setup>nodemon
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm install @babel/core @babel/node --save-dev</pre> ve <pre class="prettyprint ms-0">npm install @babel/preset-env --save-dev</pre> ve build iÃ§in:<pre class="prettyprint ms-0">npm install --save-dev @babel/cli</pre> 
                </p>
                <p>
                  package.json dosyasÄ±nda scripts>dev alanÄ± aÅŸaÄŸÄ±daki gibi gÃ¼ncellendi ve "type": "module" ifadesi kaldÄ±rÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  "scripts": {
      ...
      "dev": "nodemon --exec babel-node ./src/index.js",
      ...
    },
                  </pre>
                </p>
                <p>
                  kÃ¶k dizine .babelrc adÄ±nda bir dosya oluÅŸturuldu ve iÃ§ine:
                  <pre class="prettyprint ms-0">
  {
      "presets": ["@babel/preset-env"]
  }
                  </pre> eklendi.
                </p>
                <p>
                  son nanoid versiyonu ES6 dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸmÄ±yor. Bu nedenle Ã¶nceki bir sÃ¼rÃ¼m yoklendi.
                  <pre class="prettyprint ms-0">
  npm uninstall nanoid
  npm install nanoid@3.3.4
                  </pre>
                </p>
                <p>
                  ES6 dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸmayan kodlardan kurtulmak iÃ§in graphql/type-defs/index.js dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
  import * as path from "path";
  import { loadFilesSync } from '@graphql-tools/load-files'
  import { mergeTypeDefs } from '@graphql-tools/merge'
   
  // const typesArray = loadFilesSync(path.dirname(fileURLToPath(import.meta.url)), { extensions: ['graphql'] })
  const typesArray = loadFilesSync(path.join(__dirname), { extensions: ['graphql'] }) // dir ifadesi babel sayesinde Ã§alÄ±ÅŸÄ±yor.
  
  export default mergeTypeDefs(typesArray)
                  </pre>
                </p>
                <p>
                  package.json script alanÄ± dÃ¼zenlendi. package.json son hali:
                  <pre class="prettyprint ms-0">
  {
    "name": "comment-challenge",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "start": "node ./dist/index.js",
      "dev": "nodemon --exec babel-node ./src/index.js",
      "build": "babel ./src --out-dir dist --minified --copy-files"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "dependencies": {
      "@apollo/server": "^4.7.1",
      "@graphql-tools/load-files": "^7.0.0",
      "@graphql-tools/merge": "^9.0.0",
      "@graphql-yoga/node": "^3.9.1",
      "@graphql-yoga/redis-event-target": "2.0.0",
      "graphql": "^16.6.0",
      "graphql-redis-subscriptions": "^2.6.0",
      "graphql-subscriptions": "^2.0.0",
      "graphql-ws": "^5.13.1",
      "graphql-yoga": "^3.9.2-rc-20230524133912-835c7e3d",
      "ioredis": "5.3.2",
      "nanoid": "^3.3.4",
      "redis": "^4.6.7"
    },
    "devDependencies": {
      "@babel/cli": "^7.22.5",
      "@babel/core": "^7.22.5",
      "@babel/node": "^7.22.5",
      "@babel/preset-env": "^7.22.5",
      "babel-plugin-module-resolver": "^5.0.0",
      "nodemon": "^2.0.22"
    }
  }
                  </pre>
                </p>
                <p>
                  <code>"build": "babel ./src --out-dir dist --minified --copy-files"</code> kodunda <code>--minified</code> build edilen tÃ¼m dosyalarda kodu tek satÄ±ra toplar. <code>--copy-files</code> ise o olmadan kopyalanmayan nonjs dosyalarÄ± da build iÃ§ine kopyalar
                </p>
                <p>
                  build iÅŸlemi ile developer tarafÄ±ndaki Ã¼rÃ¼n product tarafÄ±na hazÄ±r hale getirilir. Bu iÅŸlem iÃ§in terminale <pre class="prettyprint ms-0">npm run build</pre> yazÄ±lÄ±r. disc adÄ±nda bir klasÃ¶re build oluÅŸturulur.
                </p>
  
                <h2>babel-plugin-module-resolver</h2>
                <p>
                  import sÄ±rasÄ±nda dosya dizini bulmayÄ± kolaylaÅŸtÄ±rmak iÃ§in dosya yollarÄ±na takma ad vermek  iÃ§in <a href="https://www.npmjs.com/package/babel-plugin-module-resolver">babel-plugin-module-resolver</a> kullanÄ±labilir. bunun iÃ§in terminale <pre class="prettyprint ms-0">npm install --save-dev babel-plugin-module-resolver</pre>
                </p>
                <p>
                  .babelrc iÃ§ine kÄ±sayollar tanÄ±mlanÄ±r. .babelrc son hali:
                  <pre class="prettyprint ms-0">
  {
      "presets": ["@babel/preset-env"],
      "plugins": [
          ["module-resolver", {
          "root": ["./src"],
          "alias": {
              "@graphql": "./src/graphql",
              "@resolvers": "./src/graphql/resolvers",
              "@type-defs": "./src/graphql/type-defs"
          }
          }]
      ]
  }
                  </pre>
                </p>
                <p>
                  Buna gÃ¶re src/index.js:
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./data.js";
  import resolvers from "@resolvers"; //
  import typeDefs from "@type-defs"; //
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db,
    },
  });
  
  const server = createServer(yoga); 
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
                  </pre>
                </p>
  
                <h2>Babel SonrasÄ± Resolver Merge</h2>
                <p>graphql/resolvers altÄ±na bir resolvers klasÃ¶rÃ¼ daha aÃ§Ä±lÄ±r ve index.js harici dosyalaor oraya taÅŸÄ±nÄ±r.</p>
                <p>
                  graphql/resolvers/index.js aÅŸaÄŸÄ±daki gibi dÃ¼zenlenir.
                  <pre class="prettyprint ms-0">
  import path from "path";
  import { mergeResolvers } from "@graphql-tools/merge";
  import { loadFilesSync } from "@graphql-tools/load-files";
  
  const resolversArray = loadFilesSync(path.join(__dirname, "/resolvers"), {
    extensions: ["js"],
    extractExports: (fileExport) => { // bu kod index.js ile aynÄ± dizinde resolverler olmasÄ± durumunda index.js dosyasÄ±nÄ± merge dÄ±ÅŸÄ±nda tutmak iÃ§in yazÄ±ldÄ± ama Ã§alÄ±ÅŸmÄ±yor. Bu nedenle resolverlar baÅŸka bir klasÃ¶re taÅŸÄ±ndÄ±.
      if (typeof fileExport === "function") {
        return fileExport("query_root");
      }
      return fileExport;
    },
  });
  
  export default mergeResolvers(resolversArray);
  
                  </pre>
                </p>
                <p>
                  merge iÅŸleminin dÃ¼zgÃ¼n yapÄ±labilmesi iÃ§in <code>export default ...</code> ifadesi yerine <code>export const ...</code> kalÄ±bÄ± kullanÄ±lÄ±r. Ã¶rnek: src/graphql/resolvers/resolvers/Mutation.js
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  export const Mutation = {
    // User
    createUser: (_, args, { pubSub, db }) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
        age: args.data.age,
      };
  
      db.users.push(user);
      pubSub.publish("userCreated", { userCreated: user });
  
      return user;
    },
    updateUser: (_, { id, data }, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const update_user = (db.users[user_index] = {
        ...db.users[user_index],
        ...data,
      });
      pubSub.publish("userUpdated", { userUpdated: update_user });
      return update_user;
    },
    deleteUser: (_, __, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const deleted_user = db.users[user_index];
  
      db.users.splice(user_index, 1);
  
      pubSub.publish("userDeleted", { userDeleted: deleted_user });
      return deleted_user;
    },
    deleteAllUsers: (_, __, { db }) => {
      const length = db.users.length;
  
      db.users.splice(0, length);
  
      return {
        count: length,
      };
    },
    // Post
    createPost: (_, { data: { title, user_id } }, { pubSub, db }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };
  
      db.posts.push(post);
  
      pubSub.publish("postCreated", { postCreated: post });
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return post;
    },
    updatePost: (_, { id, data }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
  
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const updated_post = (db.posts[post_index] = {
        ...db.posts[post_index],
        ...data,
      });
  
      pubSub.publish("postUpdated", { postUpdated: updated_post });
      return updated_post;
    },
    deletePost: (_, { id }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const deleted_post = db.posts[post_index];
  
      db.posts.splice(post_index, 1);
      pubSub.publish("postDeleted", { postDeleted: deleted_post });
      pubSub.publish("postsCount", { postsCount: posts.length });
  
      return deleted_post;
    },
    deleteAllPosts: (_, __, { pubSub, db }) => {
      const length = db.posts.length;
  
      db.posts.splice(0, length);
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return {
        count: length,
      };
    },
  
    // Comment
    createComment: (_, { data }, { pubSub, db }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };
  
      db.comments.push(comment);
  
      pubSub.publish("commentCreated", { commentCreated: comment });
      return comment;
    },
    updateComment: (_, { id, data }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
  
      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }
  
      const updated_comment = (db.comments[comment_index] = {
        ...db.comments[comment_index],
        ...data,
      });
      pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
      return updated_comment;
    },
    deleteComment: (_, { id }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
      if (comment_index === -1) {
        throw new Error("Comment not found");
      }
  
      const deleted_comment = db.comments[comment_index];
  
      db.comments.splice(comment_index, 1);
  
      pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
      return deleted_comment;
    },
    deleteAllComments: (_, __, { db }) => {
      const length = db.comments.length;
      db.comments.splice(0, length);
      return {
        count: length,
      };
    },
  };
  
  
                  </pre> 
                </p>
              </div>
            </div>
            <div class="row" id="apolloClientQueries">
              <div class="row" id="setupApolloClient">
                <h1>Apollo Client Kurulumu</h1>
                <p>
                  Daha Ã¶nceki tÃ¼m yapÄ±mÄ±zÄ± kÃ¶k dizindeki server dosyasÄ±na taÅŸÄ±dÄ±k.
                </p>
                <p>
                  KÃ¶k dizinde client dosyasÄ± iÃ§ine react kuruludu. Terminale <pre class="prettyprint ms-0">npx create-react-app .</pre>
                </p>
                <p>
                  Apollo Client, GraphQL ile uzak ve yerel verilerin yÃ¶netimini basitleÅŸtiren bir durum yÃ¶netimi kÃ¼tÃ¼phanesidir. Ã–zelliklerini zamanla Ã¶ÄŸreneceÄŸiz.
                </p>
                <p>
                  client iÃ§ine apollo client kuruldu. terminale <pre class="prettyprint ms-0">npm install @apollo/client graphql</pre>
                </p>
                <p>
                  apollo client'in client iÃ§ine importu iÃ§in <a href="https://www.apollographql.com/docs/react/get-started">bu dÃ¶kÃ¼man</a> uygulandÄ±.
                </p>
                <p>
                  client/src/index.js
                  <pre class="prettyprint ms-0">
  import React from "react";
  import ReactDOM from "react-dom/client";
  import "./index.css";
  import App from "./App";
  import {
    ApolloProvider
  } from "@apollo/client";
  import client from "./apollo";
  
  
  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    &lt;ApolloProvider client={client}>
      &lt;App />
    &lt;/ApolloProvider>,
  );
  
                  </pre>
                </p>
                <p>
                  client/src/apollo.js
                  <pre class="prettyprint ms-0">
  import { ApolloClient, InMemoryCache } from "@apollo/client";
  
  const client = new ApolloClient({
    uri: "http://localhost:4000/graphql", // server tarafÄ±nÄ±n verdiÄŸi endpoint
    cache: new InMemoryCache(),
  });
  
  export default client
                  </pre>
                </p>
                <p>
                  chore iÃ§in <a href="https://chrome.google.com/webstore/detail/apollo-client-devtools/jdkknkkbebbapilgoeccciglkfbmbnfm">apollo client devtools</a> eklentisi.
                </p>
              </div>
              <div class="row" id="ApolloClientVisual">
                <h1>Genel GÃ¶rÃ¼nÃ¼mÃ¼n AyarlanmasÄ±</h1>
                <p>
                  KullanÄ±cÄ± tarafÄ±nÄ±n gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼n ayarlanmasÄ±na baÅŸlandÄ±.
                </p>
                <p>
                  Bunun iÃ§in <a href="https://ant.design/">ant design</a> kullanacaÄŸÄ±z.
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm install antd</pre>
                </p>
                <p>
                  client/src/App.js dosyasÄ± client/src/components/App/index.js olarak gÃ¶Ã¼ncellendi. Ä°Ã§ine:
                  <pre class="prettyprint ms-0">
  import { Col, Row } from "antd";
  import styles from "./styles.module.css"; // stil tanÄ±mlarÄ±
  
  import { Avatar, List, Skeleton } from "antd";
  
  const data = [ // placeholder data
    {
      gender: "female",
      name: {
        title: "Miss",
        first: "Tanise",
        last: "Monteiro",
      },
      email: "tanise.monteiro@example.com",
      picture: {
        large: "https://randomuser.me/api/portraits/women/82.jpg",
        medium: "https://randomuser.me/api/portraits/med/women/82.jpg",
        thumbnail: "https://randomuser.me/api/portraits/thumb/women/82.jpg",
      },
      nat: "BR",
    },
  ];
  
  function App() {
    return (
      &lt;div className={styles.container}>
        &lt;Row justify="center">
          &lt;Col span={14} className={styles.content}>
            &lt;List
              className="demo-loadmore-list"
              loading={false}
              itemLayout="horizontal"
              // loadMore={loadMore}
              dataSource={data}
              renderItem={(item) => (
                &lt;List.Item>
                  &lt;Skeleton avatar title={false} loading={item.loading} active>
                    &lt;List.Item.Meta
                      avatar={&lt;Avatar src={item.picture.large} />}
                      title={&lt;a href="https://ant.design">{item.name?.last}&lt;/a>}
                      description="Ant Design, a design language for background applications, is refined by Ant UED Team"
                    />
                  &lt;/Skeleton>
                &lt;/List.Item>
              )}
            />
          &lt;/Col>
        &lt;/Row>
      &lt;/div>
    );
  }
  
  export default App;
  
                  </pre>
                </p>
                <p>
                  Stil tanÄ±mlarÄ± iÃ§in client/src/components/App/styles.module.css iÃ§i aÅŸaÄŸÄ±daki gibi dÃ¼zenlenir.
                  <pre class="prettyprint ms-0">
  .container{
      height: 100vh;
  }
  
  .content{
      background-color: #fff;
      padding: 24px;
      margin: 24px;
      border: solid 4px bisque;
  }
                  </pre>
                </p>
                <p>
                  App.js lokasyonundaki deÄŸiÅŸiklik src/index.js iÃ§indeki import satÄ±rÄ±nda gÃ¼ncellenir.
                  <pre class="prettyprint ms-0">
  ...
  import App from "./components/App";
  ...
                  </pre>
                </p>
                <p>
                  src/index.css
                  <pre class="prettyprint ms-0">
  body {
    background-color: #282c34;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="reactRouter">
                <h1>React Router</h1>
                <p>
                  terminale <pre class="prettyprint ms-0">npm i react-router-dom</pre>
                </p>
                <p>
                  hoca v5 Ã¼zerinden anlatÄ±yor. Biz v6 kullanÄ±yoruz. React notlarÄ±mda detay mevcut.
                </p>
                <p>
                  Router sarmalama iÅŸlemi App.js Ã¼zerinde yapÄ±labilir. Hoca index.js Ã¼zerinden yapmayÄ± tercih etti. 
                  <pre class="prettyprint ms-0">
  import React from "react";
  import ReactDOM from "react-dom/client";
  import "./index.css";
  import App from "./components/App";
  import { BrowserRouter as Router } from "react-router-dom";
  
  import { ApolloProvider } from "@apollo/client";
  import client from "./apollo";
  
  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    &lt;ApolloProvider client={client}>
      &lt;Router> 
        {/* Router sarmalamasÄ± App.js yerine burada yapÄ±ldÄ±.*/}
        &lt;App />
      &lt;/Router>
    &lt;/ApolloProvider>
  );
  
                  </pre>
                </p>
                <p>
                  Sayfa yapÄ±sÄ±nÄ± dÃ¼zenlemek iÃ§in src/pages altÄ±na Home/index.js ve NewPost/index.js oluÅŸturuldu. NewPost/index.js placeholder olarak bÄ±rakÄ±ldÄ±. Home/index.js iÃ§ine App/index.js iÃ§indeki List yapÄ±sÄ± taÅŸÄ±ndÄ±.
                  <pre class="prettyprint ms-0">
  import React from "react";
  
  import { Avatar, List, Skeleton } from "antd";
  
  const data = [
    // placeholder data
    {
      gender: "female",
      name: {
        title: "Miss",
        first: "Tanise",
        last: "Monteiro",
      },
      email: "tanise.monteiro@example.com",
      picture: {
        large: "https://randomuser.me/api/portraits/women/82.jpg",
        medium: "https://randomuser.me/api/portraits/med/women/82.jpg",
        thumbnail: "https://randomuser.me/api/portraits/thumb/women/82.jpg",
      },
      nat: "BR",
    },
  ];
  
  function Home() {
    return (
      &lt;div>
        &lt;List
          className="demo-loadmore-list"
          loading={false}
          itemLayout="horizontal"
          // loadMore={loadMore}
          dataSource={data}
          renderItem={(item) => (
            &lt;List.Item>
              &lt;Skeleton avatar title={false} loading={item.loading} active>
                &lt;List.Item.Meta
                  avatar={&lt;Avatar src={item.picture.large} />}
                  title={&lt;a href="https://ant.design">{item.name?.last}&lt;/a>}
                  description="Ant Design, a design language for background applications, is refined by Ant UED Team"
                />
              &lt;/Skeleton>
            &lt;/List.Item>
          )}
        />
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
                <p>
                  src/components/App/index.js dosyasÄ±da router yapÄ±sÄ± kuruldu.
                  <pre class="prettyprint ms-0">
  import { Col, Row } from "antd";
  import { Routes, Route } from "react-router-dom";
  import styles from "./styles.module.css";
  import HeaderMenu from "./HeaderMenu";
  
  // pages
  import Home from "pages/Home"; // react absolute path ile kÃ¶k dizin src olarak ayarlandÄ±.
  import NewPost from "pages/NewPost";
  
  function App() {
    return (
      &lt;div className={styles.container}>
        &lt;Row justify="center">
          &lt;Col span={14}>
            &lt;HeaderMenu />
            &lt;div className={styles.content}>
              &lt;Routes>
                &lt;Route path="/new" element={&lt;NewPost />} />
                &lt;Route path="/" element={&lt;Home />} />
              &lt;/Routes>
            &lt;/div>
          &lt;/Col>
        &lt;/Row>
      &lt;/div>
    );
  }
  
  export default App;
  
                  </pre>
                </p>
                <p>
                  kÃ¶k dizini src yapmak iÃ§in react absolute path yapÄ±sÄ± kurgulandÄ±. Bunun iÃ§in client/jsconfig.json dosyasÄ± oluÅŸturuldu. iÃ§ine 
                  <pre class="prettyprint ms-0">
  {
      "compilerOptions": {
        "baseUrl": "src"
      }
  }
                  </pre>
                </p>
                <p>
                  App/index.js iÃ§inde kullanÄ±lan HeaderMenu App/HeaderMenu.js iÃ§inde oluÅŸturuldu.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Menu } from "antd";
  import styles from "./styles.module.css";
  import { Link, useLocation } from "react-router-dom";
  
  const items = [
    {
      label: (
        &lt;Link to="/" className={styles.menuItem}>
          Home
        &lt;/Link>
      ),
      key: "/",
    },
    {
      label: (
        &lt;Link to="/new" className={styles.menuItem}>
          New
        &lt;/Link>
      ),
      key: "/new",
    },
  ];
  
  function HeaderMenu() {
    const location = useLocation(); // aÃ§Ä±k olan sayfanÄ±n bilgisini verir.
    return (
      &lt;Menu
        mode="horizontal"
        items={items}
        className={styles.headerMenu}
        selectedKeys={location.pathname}
      />
    );
  }
  
  export default HeaderMenu;
  
                  </pre>
                </p>
                <p>
                  stil tanÄ±mlarÄ± iÃ§in componenets/App/styles.module.css iÃ§inde:
                  <pre class="prettyprint ms-0">
  .container{
      height: 100vh;
  }
  
  .content{
      background-color: #fff;
      padding: 24px;
      /* margin: 24px; */
      border: solid 4px bisque;
  }
  
  .headerMenu{
      background: none;
      border: none;
  }
  
  .menuItem{
      font-weight: bold;
      font-size: 16px;
  }
                  </pre>
                  src/index.css iÃ§inde
                  <pre class="prettyprint ms-0">
  body {
    background-color: #282c34;
  }
  
  .ant-menu-item:hover::after{
    border-bottom-color: bisque !important
  }
  
  .ant-menu-item-selected::after{
    border-bottom-color: bisque !important
  }
  
  .ant-menu-item-selected .ant-menu-title-content a {
    color: bisque !important
  }
  
  .ant-menu-item:hover::after .ant-menu-title-content {
    color: #f8f8f8
  }
  
  .ant-menu-horizontal > .ant-menu-item a:hover {
    color: bisque;
  }
  
  .ant-menu-horizontal > .ant-menu-item a {
    color: #f8f8f8;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="postlarinListelenmesi">
                <h1>PostlarÄ±n Listelenmesi (useQuery)</h1>
                <p>
                  Client tarafÄ±nda daha iyi bir gÃ¶rsel yakalamak iÃ§in server tarafÄ±nda post datasÄ±nÄ±n ve type-def tanÄ±mÄ±nÄ±n iÃ§ine <q>description</q>, user fatasÄ±nÄ±n ve type-def tanÄ±mÄ±nÄ±n iÃ§ine <q>pfofile_photo</q> tanÄ±mlarÄ± eklendi
                </p>
                <p>
                  pages/Home/queries.js dosyasÄ± oluÅŸturuldu ve iÃ§inde sorgumuz tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_POSTS = gql`
    query getAllPosts {
      posts {
        id
        title
        description
        user {
          profile_photo
        }
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  pages/Home/index.js iÃ§inde useQuery ile sorgudan data alÄ±ndÄ± ve iÅŸlendi. useQuery data dÄ±ÅŸÄ±nda loading ve error durumlarÄ±nÄ± da bize veriyor. 
                  <pre class="prettyprint ms-0">
  import React from "react";
  
  import { Avatar, List } from "antd";
  
  import { useQuery } from "@apollo/client";
  import Loading from "components/Loading";
  import { GET_POSTS } from "./queries";
  
  function Home() {
    const { loading, error, data } = useQuery(GET_POSTS);
  
    if (loading) {
      return &lt;Loading />;
    }
  
    if (error) {
      return &lt;div>Error: {error.message}&lt;/div>;
    }
  
    console.log(data);
  
    return (
      &lt;div>
        &lt;List
          className="demo-loadmore-list"
          loading={false}
          itemLayout="horizontal"
          // loadMore={loadMore}
          dataSource={data.posts}
          renderItem={(item) => (
            &lt;List.Item>
              &lt;List.Item.Meta
                avatar={&lt;Avatar src={item.user.profile_photo} />}
                title={&lt;a href="https://ant.design">{item.title}&lt;/a>}
                description={item.description}
              />
            &lt;/List.Item>
          )}
        />
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
                <p>
                  components/Loading/index.js iÃ§inde loading durumunda gÃ¶sterilecek spinner tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { LoadingOutlined } from "@ant-design/icons";
  import { Spin } from "antd";
  
  import styles from "./styles.module.css"
  
  function Loading() {
    return (
      &lt;div className={styles.loading}>
        &lt;Spin indicator={&lt;LoadingOutlined style={{ fontSize: 32 }} spin />} />
      &lt;/div>
    );
  }
  
  export default Loading;
  
                  </pre>
                </p>
                <p>
                  component/Loading/styles.module.css iÃ§inde loading spinnerÄ± iÃ§in stil tanÄ±mÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  .loading{
      display: flex;
      align-items: center;
      justify-content: center;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="postDetail">
                <h1>Post DetaylarÄ±nÄ±n GÃ¶sterilmesi</h1>
                <p>
                  server tarafÄ±nda posts datasÄ±na ve type-defs kÄ±smÄ±na <q>cover</q> tanÄ±mlarÄ± eklendi.
                </p>
                <p>
                  App/index.js iÃ§inde Routes altÄ±nda yeni route oluÅŸturuldu.
                  <pre class="prettyprint ms-0">
  ... 
    &lt;Routes>
      &lt;Route path="/new" element={&lt;NewPost />} />
      &lt;Route path="/post/:id" element={&lt;Post />} />
      &lt;Route path="/" element={&lt;Home />} />
    &lt;/Routes>
  ...
                  </pre>
                </p>
                <p>
                  Home/index.js alanÄ±nda Link kompanenti ile baÄŸlantÄ±lar oluÅŸturuldu.
                  <pre class="prettyprint ms-0">
  ...
  import { Link } from "react-router-dom";
  ...
  
  function Home() {
    ...
  
    return (
      &lt;div>
        &lt;List
          className="demo-loadmore-list"
          loading={false}
          itemLayout="horizontal"
          // loadMore={loadMore}
          dataSource={data.posts}
          renderItem={(item) => (
            &lt;List.Item>
              &lt;List.Item.Meta
                avatar={&lt;Avatar src={item.user.profile_photo} />}
                title={
                  &lt;Link to={`/post/${item.id}`} className={styles.listTitle}>
                    {item.title}
                  &lt;/Link>
                }
                description={
                  &lt;Link to={`/post/${item.id}`} className={styles.listItem}>
                    {item.description}
                  &lt;/Link>
                }
              />
            &lt;/List.Item>
          )}
        />
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
                <p>
                  Home/styles.module.css iÃ§inde linlker iÃ§in stil tanÄ±mlarÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  .listItem{
      color: rgba(0, 0, 0, 0.45);
      font-size: 14px;
      line-height: 1,5715;
  }
  
  .listItem:hover{
      color: rgba(0, 0, 0, 0.6);
  }
  
  .listTitle{
      margin-bottom: 4px;
      color: rgba(0, 0, 0, 0.85);
      font-size: 14px;
      line-height: 1,5715;
  }
  
  .listTitle:hover{
      color: rgba(0, 0, 0, 0.9) !important;
  }
                  </pre>
                </p>
                <p>
                  pages/Post dosyasÄ± oluÅŸturuldu. Ä°Ã§inde index.js ve queries.js dosyasÄ± oluÅŸturuldu. <br>
                  queries.js iÃ§inde query tanÄ±mÄ± eklendi.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_POST = gql`
    query post($id: ID!) {
    post(id: $id) {
      id
      title
      description
      cover
      user {
        id
        fullName
      }
    }
  }
  `;
                  </pre>
                  index.js iÃ§inde de query import edildi ve useQuery ile variables girilerek kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import Loading from "components/Loading";
  import { useParams } from "react-router-dom";
  import { useQuery } from "@apollo/client";
  import { GET_POST } from "./queries";
  import { Typography, Image } from "antd";
  const { Title } = Typography;
  
  function Post() {
    const { id } = useParams();
  
    const { loading, error, data } = useQuery(GET_POST, {
      variables: {
        id,
      },
    });
  
    if (loading) {
      return &lt;Loading />;
    }
  
    if (error) {
      return &lt;div>Error: {error.message}&lt;/div>;
    }
  
    console.log(data);
  
    const { post } = data;
  
    return (
      &lt;div>
        &lt;Title level={3}>{post.title}&lt;/Title>
        &lt;Image
          src={post.cover}
        />
        &lt;div>{post.description}&lt;/div>
      &lt;/div>
    );
  }
  
  export default Post;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="shortDescField">
                <h1>Short Description Field'Ä±nÄ±n TanÄ±mlanmasÄ±</h1>
                <p>
                  post datasÄ± ve type-def tanÄ±mlarÄ±na <q>short_description</q> alanÄ± oluÅŸturuldu. Bu short_description client tarafÄ±nda Home iÃ§in query ile sorgulandÄ± ve gelen veri daha Ã¶nce description tanÄ±mÄ± olan yerde kullanÄ±ldÄ±.
                </p>
                <p>
                  Post detaylarÄ±nÄ±n olduÄŸu sayfada description alanÄ± iÃ§in stil tanÄ±mÄ± yapÄ±ldÄ±. Post/index.js
                  <pre class="prettyprint ms-0">
  import styles from "./styles.module.css";
  
  ...
  function Post() {
    ...
  
    return (
      ...
        &lt;div className={styles.description}>{post.description}&lt;/div>
      &lt;/div>
    );
  }
  
  export default Post;
                  </pre>
                  Post/styles.module.css
                  <pre class="prettyprint ms-0">
  .description{
      font-size: 1.1rem;
      margin: 10px;
      color: #666;
  }
                  </pre>
                </p>
                <p>
                  Genel gÃ¶rÃ¼nÃ¼mÃ¼ gÃ¼zelleÅŸtirmek iÃ§in App/index.js iÃ§in stil tanÄ±mÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  ...
  
  function App() {
    return (
      ...
        &lt;Row justify="center">
          &lt;Col span={14} className={styles.col}>
      ...
                  </pre>
                  App/styles.module.css
                  <pre class="prettyprint ms-0">
  ...
  .col{
    margin: 10px 0 30px 0
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="useLazyQuery">
                <h1>Post YorumlarÄ±nÄ±n Listelenmesi (useLazyQuery)</h1>
                <p>
                  Post sayfasÄ±nda yorumlarÄ±n sayfadaki <q>show comments</q> butonuna basÄ±lÄ±nca gÃ¶steileceÄŸi bir durum kurguladÄ±k.
                </p>
                <p>
                  Hoca butonu tÄ±klandÄ±ktan sonra kaybetmek iÃ§in farklÄ± bir yÃ¶ntem kullandÄ±. Ben daha farklÄ± yaptÄ±m.
                </p>
                <p>
                  Post/queries.js iÃ§ine ihtiyacÄ±mÄ±z olan bilgileri Ã§ekmek iÃ§in sorgu yazÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const GET_POST_COMMENTS = gql`
    query postComments($id: ID!) {
    post(id: $id) {
      comments {
        id
        text
        user {
          id
          fullName
          profile_photo
        }
      }
    }
  }
  `;
  
                  </pre>
                </p>
                <p>
                  Post/Comments.js dosyasÄ± oluÅŸturuldu. Ä°Ã§inde sorgu iÃ§in butonla tetiklenen useLazyQuery hooku kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import Loading from "components/Loading";
  import { Divider, Button } from "antd";
  import styles from "./styles.module.css";
  import { useLazyQuery } from "@apollo/client";
  import { GET_POST_COMMENTS } from "./queries";
  import { Avatar, List } from "antd";
  
  function Comments({ post_id }) {
    const [
      loadComments, // sorguyu baÅŸlatacak olan fonksiyon
      {
        called, // sorgu baÅŸladÄ± mÄ±?
        loading, // yÃ¼kleniyor mu?
        data, // gelen veri
      },
    ] = useLazyQuery(
      GET_POST_COMMENTS,
      { variables: { id: post_id } } // sorgu iÃ§in gÃ¶nderilen deÄŸiÅŸken
    );
  
    if (called && loading) return &lt;Loading />;
  
    return (
      &lt;>
        &lt;Divider>Comments&lt;/Divider>
        {!called && (
          &lt;div className={styles.showCommentsButton}>
            &lt;Button loading={loading} onClick={() => loadComments()}>
              Show Comments
            &lt;/Button>
          &lt;/div>
        )}
  
        {!loading && data && (
          &lt;div>
            &lt;List
              className="demo-loadmore-list"
              loading={false}
              itemLayout="horizontal"
              // loadMore={loadMore}
              dataSource={data.post.comments}
              renderItem={(item) => (
                &lt;List.Item>
                  &lt;List.Item.Meta
                    avatar={&lt;Avatar src={item.user.profile_photo} />}
                    title={item.user.fullName}
                    description={item.text}
                  />
                &lt;/List.Item>
              )}
            />
          &lt;/div>
        )}
      </>
    );
  }
  
  export default Comments;
  
                  </pre>
                </p>
                <p>
                  Comments.js iÃ§indeki butona styles.module.css iÃ§inde stil tanÄ±mÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  ...
  
  .showCommentsButton{
      text-align: center;
  }
                  </pre> 
                </p>
                <p>
                  Post/index.js iÃ§indeki kompanentin en altÄ±na Comments kompanenti yerleÅŸtirildi. Bu sÄ±rada props olarak gÃ¶nderilen veri Comments kompanentinde karÅŸÄ±landÄ± ve sorgu iÃ§in kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  ...
  import Comments from "./Comments";
  ...
  
  function Post() {
    ...
  
    return (
      &lt;div>
        ...
        &lt;Comments post_id={id}/>
      &lt;/div>
    );
  }
  
  export default Post;
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="apolloClientSubscriptions">
              <div class="row" id="subscribeToMore">
                <h1>PostlarÄ±n GerÃ§ek ZamanlÄ± Listelenmesi (subscribeToMore)</h1>
                <p>
                  Hoca websoket iÃ§in client/src/apollo.js iÃ§inde deÄŸiÅŸiklik yaptÄ±.
                </p>
                <p>
                  Apollo client sÃ¼rÃ¼m 3.7.11 ve sonrasÄ± iÃ§in HTTP Ã¼zerinden Ã§ok parÃ§alÄ± abonelikleri destekler. Bu nedenle apollo.js iÃ§inde deÄŸiÅŸiklik yapmaya gerek kalmaz.
                </p>
                <p>
                  server tarafÄ±nda resolvers kÄ±smÄ±nda createPost mutasyonuna verinin son haline uyumlu olmasÄ± iÃ§in modif yapÄ±ldÄ±.
                </p>
                <p>
                  Home/queries.js alanÄ±na <q>POSTS_SUBSCRIPTION</q> sorgusu eklendi.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const POSTS_SUBSCRIPTION = gql`
    subscription MySubscription {
      postCreated {
        id
        title
        short_description
        user {
          profile_photo
        }
      }
    }
  `;
  
                  </pre>
                </p>
                <p>
                  Home/index.js iÃ§inde aÅŸaÄŸÄ±daki gÃ¼ncellem ile subscription kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import { useEffect } from "react";
  ...
  
  import { GET_POSTS, POSTS_SUBSCRIPTION } from "./queries";
  ...
  
  function Home() {
    const {
      loading,
      error,
      data,
      subscribeToMore, // dinlemek iÃ§in gereken fonksiyon
    } = useQuery(GET_POSTS);
  
    useEffect(() => {
      // veri deÄŸiÅŸtiÄŸinde reactta kullanÄ±lmasÄ± iÃ§in useEffect hooku kullanÄ±ldÄ±.
      subscribeToMore({
        document: POSTS_SUBSCRIPTION, // dinlenilecek sorgu
        updateQuery: (
          prev, // mevcut durum
          { subscriptionData } // dinlenen kanaldan gelen
        ) => {
          if (!subscriptionData.data) return prev;
  
          return {
            posts: [subscriptionData.data.postCreated, ...prev.posts], // posts tanÄ±mÄ± cache olarak tutulan veri keyinden alÄ±ndÄ±
          };
        },
      });
    }, [subscribeToMore]);
  
    if (loading) {
      return &lt;Loading />;
    }
  
    if (error) {
      return &lt;div>Error: {error.message}&lt;/div>;
    }
  
    return (
      &lt;div>
        ...
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="useSubscription">
                <h1>Post SayÄ±sÄ±nÄ± GerÃ§ek ZamanlÄ± GÃ¶stermek (useSubscription)</h1>
                <p>
                  components/App/HeaderMenu.js kompanenti components/HeaderMenu/index.js olarak taÅŸÄ±ndÄ±. Gereken import ve style tanÄ±mlarÄ± dÃ¼zenlendi.
                </p>
                <p>
                  components/PostCounter/queries.js oluÅŸturuldu ve iÃ§ine subscription sorgusu eklendi.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const POST_COUNT_SUBSCRÄ°PTÄ°ON = gql`
    subscription {
      postsCount
    }
  `;
                  </pre>
                </p>
                <p>
                  components/PostCounter/index.js oluÅŸturuldu. queries.js iÃ§indeki sorgu import edildi ve <code>useSubscription()</code> hooku ile abone olundu.: 
                  <pre class="prettyprint ms-0">
  import styles from "./styles.module.css";
  import { Badge, Avatar } from "antd";
  import { useSubscription } from "@apollo/client";
  import { POST_COUNT_SUBSCRÄ°PTÄ°ON } from "./queries";
  
  function PostCounter() {
    const {loading, data} = useSubscription(POST_COUNT_SUBSCRÄ°PTÄ°ON);
    
    return (
      &lt;div className={styles.container}>
        &lt;Badge count={loading ? "?" : data.postsCount }>
          &lt;Avatar shape="square" size="medium">
              &lt;span className={styles.counterTitle}>Posts&lt;/span>
          &lt;/Avatar>
        &lt;/Badge>
      &lt;/div>
    );
  }
  
  export default PostCounter;
                  </pre>
                </p>
                <p>
                  App/index.js iÃ§inde daha Ã¶nce HeaderMenu kompanentinin tek baÅŸÄ±na yer aldÄ±ÄŸÄ± kÄ±sÄ±m Row/Col yapÄ±syla bÃ¶lÃ¼ndÃ¼ ve iÃ§ine PostCounter kompanenti eklendi.
                  <pre class="prettyprint ms-0">
  ...
  import PostCounter from "components/PostCounter";
  
  function App() {
    return (
      &lt;div className={styles.container}>
        &lt;Row justify="center">
          &lt;Col span={14} className={styles.col}>
            &lt;Row>
              &lt;Col span={18}>
                &lt;HeaderMenu />
              &lt;/Col>
              &lt;Col span={6}>
                &lt;PostCounter />
              &lt;/Col>
            &lt;/Row>
            ...
          &lt;/Col>
        &lt;/Row>
      &lt;/div>
    );
  }
  
  export default App;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="commentsRealTime">
                <h1>YorumlarÄ±n GerÃ§ek ZamanlÄ± GÃ¶sterilmesi</h1>
                <p>
                  Post iÃ§inde comment post_id parametresi ile abonelik oluÅŸturacak sorguyu Post/queries.js iÃ§ine ekledik.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const COMMENTS_SUBSCRIPTIONS = gql`
    subscription ($postId: ID) {
      commentCreated(post_id: $postId) {
        id
        text
        user {
          id
          fullName
          profile_photo
        }
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Post/Comments.js alanÄ±nda tÄ±klayÄ±nca sorgu baÅŸlatan <q>useLazyQuery</q> hooku iÃ§inden subscribeToMore fonksiyonunu Ã§ektik ve <q>useEffect</q> hooku ile kullandÄ±k. 
                  <pre class="prettyprint ms-0">
  import { useEffect } from "react";
  
  function Comments({ post_id }) {
  
    const [loadComments, { called, loading, data, subscribeToMore }] =
      useLazyQuery(GET_POST_COMMENTS, { variables: { id: post_id } });
  
    useEffect(() => {
      if (!loading && called) {
        subscribeToMore({
          document: COMMENTS_SUBSCRIPTIONS,
          updateQuery: (prev, { subscriptionData }) => {
            if (!subscriptionData.data) return prev;
  
            return {
              post: {
                ...prev.post,
                comments: [
                  ...prev.post.comments,
                  subscriptionData.data.commentCreated,
                ],
              },
            };
          },
        });
      }
    }, [loading, called, subscribeToMore]);
  
    if (called && loading) return &lt;Loading />;
  
    return (
      ...
    );
  }
  
  export default Comments;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="fragments">
                <h1>Fragments</h1>
                <p>
                  Birden fazla query iÃ§inde aynÄ± tanÄ±mlarÄ± Ã§ekmemiz gerekti. Ä°leride birini gÃ¼ncellememiz gerektiÄŸinde hepsini gÃ¼ncellememiz gerekecek. Bu gibi durumlarda aksaklÄ±k yaÅŸanmamasÄ± ve iÅŸin kolaylaÅŸmasÄ± iÃ§in sorgu parametreleri fragment yapÄ±larÄ±na alÄ±nabilir.
                </p>
                <p>
                  Post/queries.js iÃ§inde sorguda aynÄ± kullanÄ±lan parametreler fragment iÃ§inde toplandÄ±.
                  <pre class="prettyprint ms-0">
  const commentFragment = gql`
    fragment CommentFragment on Comment {
      # commentsFragment iÃ§inde CommentsFragment adÄ±yla aÅŸaÄŸÄ±daki parametreleri saklar.
      id
      text
      user {
        id
        fullName
        profile_photo
      }
    }
  `;
                  </pre>
                  Toplanan parametreler ilgili sorgulara import edildi ve kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  export const GET_POST_COMMENTS = gql`
    query postComments($id: ID!) {
      post(id: $id) {
        comments {
          ...CommentFragment
          # Bu kÄ±sÄ±m deÄŸiÅŸkenleri yerleÅŸtirmek iÃ§in
        }
      }
    }
    ${commentFragment}
    # bu kÄ±sÄ±m deÄŸiÅŸkeni import etmek iÃ§in
  `;
  
  export const COMMENTS_SUBSCRIPTIONS = gql`
    subscription ($postId: ID) {
      commentCreated(post_id: $postId) {
        ...CommentFragment
      }
    }
    ${commentFragment}
  `;
  
                  </pre>
                </p>
                <p>
                  AynÄ± uygulamanÄ±n Home/queries.js versiyonu
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  const postFragments = gql`
    fragment PostFragmens on Post {
      id
      title
      short_description
      user {
        profile_photo
      }
    }
  `;
  
  export const GET_POSTS = gql`
    query getAllPosts {
      posts {
        ...PostFragmens
      }
    }
    ${postFragments}
  `;
  
  export const POSTS_SUBSCRIPTION = gql`
    subscription MySubscription {
      postCreated {
        ...PostFragmens
      }
    }
    ${postFragments}
  `;
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="apolloClientMutations">
              <div class="row" id="createNewPostForm">
                <h1>New Post Formunun TasarlanmasÄ±</h1>
                <p>
                  pages/NewPost/NewPostForm.js dosyasÄ± oluÅŸturuldu. Ä°Ã§ine:
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Button, Checkbox, Form, Input, Select } from "antd";
  
  const { Option } = Select;
  
  function NewPostForm() {
    return (
      &lt;Form
        name="basic"
        initialValues={{
          remember: true,
        }}
        // onFinish={onFinish}
        // onFinishFailed={onFinishFailed}
        autoComplete="off"
      >
        &lt;Form.Item
          // label="Username"
          name="username"
          rules={[
            {
              required: true,
              message: "Please input your username!",
            },
          ]}
        >
          &lt;Input size="large" placeholder="Title" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="shortDescription">
          &lt;Input size="large" placeholder="Short description" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="description">
          &lt;Input.TextArea size="large" placeholder="Description" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="cover">
          &lt;Input size="large" placeholder="Cover" />
        &lt;/Form.Item>
  
        &lt;Form.Item
          name="user"
          rules={[
            {
              required: true,
              message: "Please select user!",
            },
          ]}
        >
          &lt;Select size="large" placeholder="Select your user">
            &lt;Option value="male">Male&lt;/Option>
            &lt;Option value="female">Female&lt;/Option>
            &lt;Option value="other">Other&lt;/Option>
          &lt;/Select>
        &lt;/Form.Item>
  
        &lt;Form.Item>
          &lt;Button type="primary" htmlType="submit">
            Submit
          &lt;/Button>
        &lt;/Form.Item>
        
      &lt;/Form>
    );
  }
  
  export default NewPostForm;
  
                  </pre>
                </p>
                <p>
                  OluÅŸturlan kompanent pages/NewPost/index.js iÃ§ine import edildi.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Typography } from "antd";
  import NewPostForm from "./NewPostForm";
  const { Title } = Typography;
  
  function NewPost() {
    return (
      &lt;div>
        &lt;Title level={3}>New Post&lt;/Title>
  
        &lt;NewPostForm />
      &lt;/div>
    );
  }
  
  export default NewPost;
                  </pre>
                </p>
                <p>
                  Formdaki satÄ±r arasÄ± boÅŸluklarÄ± azaltmak iÃ§in src/style.css iÃ§ine
                  <pre class="prettyprint ms-0">
  .ant-form-item{
    margin-bottom: 12px;
  }
                  </pre>
                  eklendi
                </p>
              </div>
              <div class="row" id="newPostFormUsers">
                <h1>KullanÄ±cÄ± Listesinin Ã‡ekilmesi</h1>
                <p>
                  pages\NewPost\queries.js iÃ§inde userlar iÃ§in gereken query tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_USER = gql`
    query {
      users {
        fullName
        id
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  TanÄ±mlanan query NewPost\NewPostForm.js iÃ§inde kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  ..
  import { useQuery } from "@apollo/client";
  import { GET_USER } from "./queries";
  import styles from "./styles.module.css"
  
  ..
  
  function NewPostForm() {
    const {
      loading: get_users_loading, // yeniden adlandÄ±rdÄ±k
      data: users_data,
    } = useQuery(GET_USER);
  
    return (
      ...
  
        &lt;Form.Item
          name="user"
          rules={[
            {
              required: true,
              message: "Please select user!",
            },
          ]}
        >
          &lt;Select
            disabled={get_users_loading}
            loading={get_users_loading}
            size="large"
            placeholder="Select your user"
          >
            {users_data &&
              users_data.users.map(item => (
                &lt;Option value={item.id} key={item.id}>
                  {item.fullName}
                &lt;/Option>
              ))}
          &lt;/Select>
        &lt;/Form.Item>
  
        &lt;Form.Item className={styles.buttons}>
          &lt;Button size="large" type="primary" htmlType="submit">
            Submit
          &lt;/Button>
        &lt;/Form.Item>
      &lt;/Form>
    );
  }
  
  export default NewPostForm;
  
                  </pre>
                </p>
                <p>
                  \NewPost\styles.module.css iÃ§inde butonlar iÃ§in stil tanÄ±mÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  .buttons{
      text-align: right;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="useMutation">
                <h1>Yeni Post Eklemek (useMutation)</h1>
                <p>
                  yani post iÃ§in mutation tanÄ±mÄ± pages\NewPost\queries.js dosyasÄ±na eklendi.
                  <pre class="prettyprint ms-0">
                    import { gql } from "@apollo/client";
  
                    ...
                    
                    export const NEW_POST_MUTATION = gql`
                      mutation ($data: CreatePostInput!) {
                        createPost(data: $data) {
                          id
                          title
                        }
                      }
                    `;
                  </pre>
                </p>
                <p>
                  HazÄ±rlanan mutation NewPost\NewPostForm.js iÃ§ine import edilip kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Button, Form, Input, Select, message } from "antd";
  import { useNavigate } from "react-router-dom";
  import { useQuery, useMutation } from "@apollo/client";
  import { GET_USER, NEW_POST_MUTATION } from "./queries";
  import styles from "./styles.module.css";
  
  const { Option } = Select;
  
  function NewPostForm() {
    const navigate = useNavigate()
  
    const [
      savePost, // bizim mutation fonksiyonuna verdiÄŸimiz ad.
      { loading, error }, // iÅŸlem sonunda dÃ¶nen data
    ] = useMutation(NEW_POST_MUTATION);
  
    const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);
  
    const handleSubmit = async (values) => {
      try {
        await savePost({
          variables: {
            data: values,
          },
        });
        message.success("Post saved", [4]);
        navigate("/")
  
      } catch (e) {
        message.error(`Post not saved!. Error: ${error.message}`, [10]);
      }
    };
  
    return (
      &lt;Form
        name="basic"
        initialValues={{
          remember: true,
        }}
        onFinish={handleSubmit}
        // onFinishFailed={onFinishFailed}
        autoComplete="off"
      >
        &lt;Form.Item
          name="title" // bu kÄ±sÄ±m value tanÄ±mÄ±nda key olarak gÃ¶nderilir. mutation iÃ§indeki key ile aynÄ± olmak zorunda.
          rules={[
            {
              required: true,
              message: "Please input a title!",
            },
          ]}
        >
          &lt;Input disabled={loading} size="large" placeholder="Title" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="short_description">
          &lt;Input
            disabled={loading}
            size="large"
            placeholder="Short description"
          />
        &lt;/Form.Item>
  
        &lt;Form.Item name="description">
          &lt;Input.TextArea
            disabled={loading}
            size="large"
            placeholder="Description"
          />
        &lt;/Form.Item>
  
        &lt;Form.Item name="cover">
          &lt;Input disabled={loading} size="large" placeholder="Cover" />
        &lt;/Form.Item>
  
        &lt;Form.Item
          name="user_id"
          rules={[
            {
              required: true,
              message: "Please select user!",
            },
          ]}
        >
          &lt;Select
            disabled={get_users_loading || loading}
            loading={get_users_loading}
            size="large"
            placeholder="Select your user"
          >
            {users_data &&
              users_data.users.map((item) => (
                &lt;Option value={item.id} key={item.id}>
                  {item.fullName}
                &lt;/Option>
              ))}
          &lt;/Select>
        &lt;/Form.Item>
  
        &lt;Form.Item className={styles.buttons}>
          &lt;Button loading={loading} size="large" type="primary" htmlType="submit">
            Submit
          &lt;/Button>
        &lt;/Form.Item>
      &lt;/Form>
    );
  }
  
  export default NewPostForm;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="createNewCommentForm">
                <h1>Yorum Formunun HazÄ±rlanmasÄ±</h1>
                <p>
                  Post altÄ±na Comment klasÃ¶rÃ¼ aÃ§Ä±ldÄ± ve CommentList.js altÄ±na taÅŸÄ±ndÄ±.
                </p>
                <p>
                  Yeni comment eklemek iÃ§in kullanacaÄŸÄ±mÄ±z formda yer almasÄ± iÃ§in user listesini almaya yarayacak query pages\Post\Comments\queries.js iÃ§inde tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_USER = gql`
    query {
      users {
        fullName
        id
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Comments\NewCommentForm.js dosyasÄ± iÃ§inde form tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Button, Col, Form, Input, Row, Select, message } from "antd";
  import { useQuery, useMutation } from "@apollo/client";
  import { GET_USER } from "./queries";
  import styles from "./styles.module.css";
  
  const { Option } = Select;
  
  function NewCommentForm() {
    const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);
    const handleSubmit = async (values) => {
      console.log(values);
    };
  
    return (
      &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off">
        &lt;Row gutter={24}>
          &lt;Col span={6}>
            &lt;Form.Item
              name="user_id"
              rules={[
                {
                  required: true,
                  message: "Please select user!",
                },
              ]}
            >
              &lt;Select
                disabled={get_users_loading}
                loading={get_users_loading}
                size="medium"
                placeholder="Select your user"
              >
                {users_data &&
                  users_data.users.map((item) => (
                    &lt;Option value={item.id} key={item.id}>
                      {item.fullName}
                    &lt;/Option>
                  ))}
              &lt;/Select>
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={14}>
            &lt;Form.Item
              name="text"
              rules={[
                {
                  required: true,
                  message: "Please enter a message!",
                },
              ]}
            >
              &lt;Input size="medium" placeholder="Message" />
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={4}>
            &lt;Form.Item className={styles.buttons}>
              &lt;Button size="medium" type="primary" htmlType="submit">
                Submit
              &lt;/Button>
            &lt;/Form.Item>
          &lt;/Col>
        &lt;/Row>
      &lt;/Form>
    );
  }
  
  export default NewCommentForm;
                  </pre>
                </p>
                OluÅŸturulan kompanent Comments\CommentsList.js iÃ§inde import edildi ve kullanÄ±ldÄ±.
                <pre class="prettyprint ms-0">
  ...
  import NewCommentForm from "./NewCommentForm";
  
  function CommentsList({ post_id }) {
    ...
  
    return (
      &lt;>
        &lt;Divider>Comments&lt;/Divider>
        {!called && (
          &lt;div className={styles.showCommentsButton}>
            &lt;Button loading={loading} onClick={() => loadComments()}>
              Show Comments
            &lt;/Button>
          &lt;/div>
        )}
  
        {!loading && data && (
          &lt;>
            &lt;List
              className="demo-loadmore-list"
              loading={false}
              itemLayout="horizontal"
              // loadMore={loadMore}
              dataSource={data.post.comments}
              renderItem={(item) => (
                &lt;List.Item>
                  &lt;List.Item.Meta
                    avatar={&lt;Avatar src={item.user.profile_photo} />}
                    title={item.user.fullName}
                    description={item.text}
                  />
                &lt;/List.Item>
              )}
            />
            &lt;Divider>New Comment&lt;/Divider>
            &lt;NewCommentForm />
          &lt;/>
        )}
      &lt;/>
    );
  }
  
  export default CommentsList;
  
                </pre>
              </div>
              <div class="row" id="mutationNewComment">
                <h1>Yeni Yorum Mutation'unun HazÄ±rlanmasÄ±</h1>
                <p>
                  yeni comment eklemek iÃ§in gereken mutation Post\Comments\queries.js iÃ§ine eklendi. 
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const CREATE_COMMENT_MUTATION = gql`
    mutation ($data: CreateCommetInput!) {
      createComment(data: $data) {
        id
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Mutation Ã§alÄ±ÅŸmasÄ± iÃ§in kullanÄ±lacak post_id verisi prop olarak Post\Comments\CommentsList.js iÃ§inden gÃ¶nderilir.
                  <pre class="prettyprint ms-0">
  ...
   &lt;NewCommentForm post_id={post_id} />
  ...
                  </pre>
                </p>
                <p>
                  formdaki veriler ve prop olarak gelen post_id kullanÄ±larak mutation fonksiyona tanÄ±mlandÄ± ve forma eklendi.
                  <pre class="prettyprint ms-0">
  import { useRef } from "react";
  import { Button, Col, Form, Input, Row, Select, message } from "antd";
  import { useQuery, useMutation } from "@apollo/client";
  import { GET_USER, CREATE_COMMENT_MUTATION } from "./queries";
  import styles from "./styles.module.css";
  
  const { Option } = Select;
  
  function NewCommentForm({ post_id }) {
    const [createComment, { loading }] = useMutation(
      CREATE_COMMENT_MUTATION
    );
    const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);
  
    const formRef = useRef(); // formu ilk haline getirmesi iÃ§in.
  
    const handleSubmit = async (values) => {
      try {
        await createComment({
          variables: {
            data: { ...values, post_id },
          },
        });
        message.success("Comment saved", [4]);
  
        formRef.current.resetFields(); // formu resetleyen fonksiyon
      } catch (e) {
        message.error(`Comment not saved!.`, [10]);
        
      }
    };
  
    return (
      &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off" ref={formRef}> 
      {/* resetleme iÃ§in ref iÃ§inde formRef verildi */}
        &lt;Row gutter={24}>
          &lt;Col span={6}>
            &lt;Form.Item
              name="user_id"
              rules={[
                {
                  required: true,
                  message: "Please select user!",
                },
              ]}
            >
              &lt;Select
                disabled={get_users_loading || loading}
                loading={get_users_loading}
                size="medium"
                placeholder="Select your user"
              >
                {users_data &&
                  users_data.users.map((item) => (
                    &lt;Option value={item.id} key={item.id}>
                      {item.fullName}
                    &lt;/Option>
                  ))}
              &lt;/Select>
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={14}>
            &lt;Form.Item
              name="text"
              rules={[
                {
                  required: true,
                  message: "Please enter a message!",
                },
              ]}
            >
              &lt;Input disabled={loading} size="medium" placeholder="Message" />
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={4}>
            &lt;Form.Item className={styles.buttons}>
              &lt;Button
                disabled={loading}
                size="medium"
                type="primary"
                htmlType="submit"
              >
                Add
              &lt;/Button>
            &lt;/Form.Item>
          &lt;/Col>
        &lt;/Row>
      &lt;/Form>
    );
  }
  
  export default NewCommentForm;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="spinnerDelay">
                <h1>Spinner Delay</h1>
                <p>
                  300 ms den kÄ±sa sÃ¼relerde olan iÅŸlemlerde loading spinerÄ±nÄ±n gÃ¶rÃ¼nmesi kullanÄ±cÄ± deneyimi iÃ§in olumsuz bir durumdur. Bu nedenle client\src\components\Loading\index.js iÃ§inde Spin etiketine delay (gecikme) eklendi.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { LoadingOutlined } from "@ant-design/icons";
  import { Spin } from "antd";
  
  import styles from "./styles.module.css"
  
  function Loading() {
    return (
      &lt;div className={styles.loading}>
        &lt;Spin delay={300} indicator={&lt;LoadingOutlined style={{ fontSize: 32 }} spin />} />
        {/* 300 milisn ve daha kÄ±sa sÃ¼ren durumlarda loading gÃ¶rÃ¼nmez. */}
      &lt;/div>
    );
  }
  
  export default Loading;
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="graphqlAndMondoDB">
              <div class="row" id="connectMongoDb">
                <h1>MongoDB BaÄŸlantÄ±sÄ±nÄ±n GerÃ§ekleÅŸtirilmesi</h1>
                <p>
                  sevrer tarafÄ±ndaki datalar mongoDB Ã¼zerine taÅŸÄ±nacak. Oradan okunup oraya yazÄ±lacak.
                </p>
                <p>
                  <a href="https://www.mongodb.com/atlas/database">MongoDB Atlas</a>'a Ã¼ye olup giriÅŸ yapÄ±yoruz. New Project > Create Project > New Database
                </p>
                <p>
                  mongoDB compass uygulamasÄ±nÄ± yÃ¼kledik (bizde zaten yÃ¼klÃ¼).
                </p>
                <p>
                  MongoDB Atlasta kurduÄŸumuz server sayfasÄ±nda connect'i tÄ±kladÄ±k. "Allow Access from Anywhere" > IP deÄŸiÅŸtirilmeden onayla > Username: "root" password: "1234" > "Create Database User" > "Choose a connection method" > "Compass" > Bu iÅŸlemde aldÄ±ÄŸÄ±mÄ±z link mongoDB compass uygulamasÄ±nda kullanÄ±ldÄ±. (linkteki &lt;password> kÄ±smÄ±na parolamÄ±z girildi.) 
                </p>
                <p>
                  nodejs tarafÄ±nda mongoose paketini kullanacaÄŸÄ±z. server tarafÄ±nda terminale <pre class="prettyprint ms-0">npm i mongoose</pre>
                </p>
                <p>
                  server/.env oluÅŸturuldu
                  <pre class="prettyprint ms-0">
  MONGO_URI=mongodb+srv://root:1234@cluster0.83fcihf.mongodb.net/?retryWrites=true&w=majority
                  </pre>
                </p>
                <p>
                  src\db.js oluÅŸturuldu
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  import dotenv from "dotenv";
  
  dotenv.config(); // .env dosyasÄ±ndan ortam deÄŸiÅŸkeni almak iÃ§in kullanÄ±ldÄ±. "process.env.MONGO_URI" bu ÅŸekilde Ã§aÄŸÄ±rÄ±ldÄ±.
  
  export default () => {
    mongoose.connect(
      process.env.MONGO_URI,
      {
        useUnifiedTopology: true,
      }
    );
  
    mongoose.connection.on(`open`, () =>
      console.log(`MongoDB: Connected`)
    );
    mongoose.connection.on(`error`, (e) =>
      console.log(`MongoDB: Not Connected!`, e)
    );
  };
  
                  </pre>
                </p>
                <p>
                  server\src\index.js iÃ§inde mongodb baÄŸlantÄ±sÄ± import edilip eklendi.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers"; 
  import typeDefs from "@type-defs"; 
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data,
    },
  });
  
  const server = createServer(yoga); 
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="createUserModel">
                <h1>User Modelinin OluÅŸturulmasÄ±</h1>
                <p>
                  server\src\models\User.js iÃ§inde User modelini oluÅŸturduk.
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const UserSchema = new Schema({
    fullName: {
      type: String, // veri tipi
      required: true, // zorunlu alan mÄ±?
    },
    age: {
      type: Number,
      required: true,
    },
    profile_photo: String,
  });
  
  export default mongoose.model("User", UserSchema);
                  </pre>
                </p>
                <p>
                  OluÅŸturduÄŸumuz User modelini server\src\index.js iÃ§inde import edip context ile gÃ¶nderdik.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  import User from "./models/User";
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers";
  import typeDefs from "@type-defs";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data, // fake DB
      _db: { // mongoDB
        User,
      }
    },
  });
  
  const server = createServer(yoga);
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
                  </pre>
                </p>
                <p>
                  context iÃ§indeki <code>_db: User</code> ifadesini server\src\graphql\resolvers\resolvers\Query.js iÃ§inde kullandÄ±k.
                  <pre class="prettyprint ms-0">
  export const Query = {
    users: async (_, __, { _db }) => { // database baÄŸlantÄ±sÄ± bekleneceÄŸinden fonksiyon asenkron tanÄ±mlandÄ±.
      const users = await _db.User.find(); // db iÃ§indeki tÃ¼m user kÄ±smÄ± Ã§ekildi.
      return users;
    },
    user: async (_, args, { _db }) => {
      const user = _db.User.findById(args.id);
      if (!user) {
        return new Error("User not found");
      }
  
      return user;
    },
  
    posts: (_, __, { db }) => db.posts,
    post: (parent, args, { db }) => db.posts.find((post) => post.id === args.id),
  
    comments: (_, __, { db }) => db.comments,
    comment: (_, args, { db }) =>
      db.comments.find((comment) => comment.id === args.id),
  };
                  </pre>
                </p>
                <p>
                  mongodb atlas Ã¼zerinden bir user ekledik. "browse Collections" > users > "INSERT DOCUMENT"
                </p>
              </div>
              <div class="row" id="createPostModel">
                <h1>Post Modelinin OluÅŸturulmasÄ±</h1>
                <p>
                  YukarÄ±daki iÅŸlemin aynÄ±sÄ±nÄ± Post iÃ§in yapÄ±yoruz.
                </p>
                <p>
                  server\src\models\Post.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const PostSchema = new Schema({
    title: {
      type: String,
      required: true,
    },
    description: String,
    short_description: String,
    cover: String,
  });
  
  export default mongoose.model("Post", PostSchema)
                  </pre>
                </p>
                <p>
                  server\src\index.js
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  //Models
  import User from "./models/User";
  import Post from "./models/Post";
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers";
  import typeDefs from "@type-defs";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data, // fake DB
      _db: { // mongoDB
        User,
        Post,
      }
    },
  });
  
  const server = createServer(yoga);
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Query.js
                  <pre class="prettyprint ms-0">
  export const Query = {
    users: async (_, __, { _db }) => {
      const users = await _db.User.find();
      return users;
    },
    user: async (_, args, { _db }) => {
      const user = _db.User.findById(args.id);
      if (!user) {
        return new Error("User not found");
      }
  
      return user;
    },
  
    posts: async (_, __, { _db }) => {
      const posts = await _db.Post.find();
      return posts;
    },
    post: async (_, args, { _db }) => {
      const post = await _db.Post.findById(args.id);
      return post
    },
  
    comments: (_, __, { db }) => db.comments,
    comment: (_, args, { db }) =>
      db.comments.find((comment) => comment.id === args.id),
  };
  
                  </pre>
                </p>
                <p>
                  YapÄ±yÄ± test etmek iÃ§in mongoDB atlas iÃ§inde post datasÄ± oluÅŸturuldu.
                </p>
              </div>
              <div class="row" id="createCommentModel">
                <h1>Comment Modelinin OluÅŸturulmasÄ±</h1>
                <p>
                  YukarÄ±daki iÅŸlemin aynÄ±sÄ±nÄ± Comment iÃ§in yapÄ±yoruz.
                </p>
                <p>
                  server\src\models\Comment.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const CommentSchema = new Schema({
    text: {
      type: String,
      required: true,
    },
  });
  
  export default mongoose.model("Comment", CommentSchema);
  
                  </pre>
                </p>
                <p>
                  server\src\index.js
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  //Models
  import User from "./models/User";
  import Post from "./models/Post";
  import Comment from "./models/Comment";
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers";
  import typeDefs from "@type-defs";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data, // fake DB
      _db: {
        // mongoDB
        User,
        Post,
        Comment,
      },
    },
  });
  
  const server = createServer(yoga);
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Query.js
                  <pre class="prettyprint ms-0">
  export const Query = {
    users: async (_, __, { _db }) => {
      const users = await _db.User.find();
      return users;
    },
    user: async (_, args, { _db }) => {
      const user = _db.User.findById(args.id);
      if (!user) {
        return new Error("User not found");
      }
  
      return user;
    },
  
    posts: async (_, __, { _db }) => {
      const posts = await _db.Post.find();
      return posts;
    },
    post: async (_, args, { _db }) => {
      const post = await _db.Post.findById(args.id);
      return post;
    },
  
    comments: async (_, __, { _db }) => {
      const comments = await _db.Comment.find();
      return comments;
    },
    comment: async (_, args, { _db }) => {
      const comment = await _db.Comment.findById(args.id);
      return comment;
    },
  };
  
                  </pre>
                </p>
                <p>
                  YapÄ±yÄ± test etmek iÃ§in mongoDB atlas iÃ§inde comment datasÄ± oluÅŸturuldu.
                </p>
              </div>
              <div class="row" id="relationshipMongoDb">
                <h1>MongoDB Ä°liÅŸkileri</h1>
                <p>
                  Verileri iliÅŸkilendirmek iÃ§in: 
                  <pre class="prettyprint ms-0">
  {
        type: Schema.Types.ObjectId,
        ref: "Comment"
      }
                  </pre>
                  yapÄ±sÄ±nÄ± kullanacaÄŸÄ±z. Ä°liÅŸkilendireceÄŸimiz veri array ise <q>[]</q> iÃ§ine alacaÄŸÄ±z.
                </p>
                <p>
                  server\src\models\User.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const UserSchema = new Schema({
    fullName: {
      type: String, // veri tipi
      required: true, // zorunlu alan mÄ±?
    },
    age: {
      type: Number,
      required: true,
    },
    profile_photo: String,
    posts: [
      {
        type: Schema.Types.ObjectId,
        ref: "Post",
      },
    ],
    comments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment"
      }
    ]
  });
  
  export default mongoose.model("User", UserSchema);
  
                  </pre>
                </p>
                <p>
                  server\src\models\Comment.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const CommentSchema = new Schema({
    text: {
      type: String,
      required: true,
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: "User"
    },
    post: {
      type: Schema.Types.ObjectId,
      ref: "Post"
    }
  });
  
  export default mongoose.model("Comment", CommentSchema);
  
                  </pre>
                </p>
                <p>
                  server\src\models\Post.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const PostSchema = new Schema({
    title: {
      type: String,
      required: true,
    },
    description: String,
    short_description: String,
    cover: String,
    user: {
      type: Schema.Types.ObjectId,
      ref: "User",
    },
    comments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment",
      },
    ],
  });
  
  export default mongoose.model("Post", PostSchema);
  
                  </pre>
                </p>
                <p>
                  resolvers yapÄ±larÄ±nÄ± modellere uygun hale getiriyoruz.
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\User.js
                  <pre class="prettyprint ms-0">
  export const User = {
    posts: async (parent, __, { _db }) =>
      await _db.Post.find({ user: parent.id }),
    comments: async (parent, __, { _db }) =>
      await _db.Comment.find({ user: parent.id }),
  };
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Comment.js
                  <pre class="prettyprint ms-0">
  export const Comment = {
    post: async (parent, __, { _db }) => await _db.Post.findById(parent.post),
    user: async (parent, __, { _db }) => await _db.User.findById(parent.user),
  };
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Post.js
                  <pre class="prettyprint ms-0">
  export const Post = {
    comments: async (parent, __, { _db }) =>
      await _db.Comment.find({post: parent.id}),
    user: async (parent, __, { _db }) =>
      await _db.User.findById(parent.user),
  };
                  </pre>
                </p>
                <p>
                  type-defs iÃ§indeki tanÄ±mlarda artÄ±k veri tabanÄ±nda kullanÄ±lmayanlarÄ± siliyoruz.
                </p>
                <ul>Veri tabanÄ±:
                  <li>users:<ul>
                    <li>id: ObjectId</li>
                    <li>fullName: String</li>
                    <li>age: String</li>
                    <li>profile_photo: String</li>
                    <li>posts: Array<ul>
                      <li>ObjectId</li>
                    </ul></li>
                    <li>comments: Array<ul>
                      <li>ObjectId</li>
                    </ul></li>
                  </ul></li>
                  <li>posts: <ul>
                    <li>id: ObjectId</li>
                    <li>title: String</li>
                    <li>short_description: String</li>
                    <li>description: String</li>
                    <li>cover: String</li>
                    <li>user: ObjectId</li>
                    <li>comments: Array<ul>
                      <li>ObjectId</li>
                    </ul></li>
                  </ul></li>
                  <li>comments: <ul>
                    <li>id: ObjectId</li>
                    <li>text: String</li>
                    <li>user: ObjectId</li>
                    <li>post: ObjectId</li>
                  </ul></li>
                </ul>
              </div>
              <div class="row" id="refactoringUserMutation">
                <h1>Refactoring User Mutations</h1>
                <p>
                  Mutation iÅŸlemlerimizi mongoose Ã¼zerinden yapmak iÃ§in server\src\graphql\resolvers\resolvers\Mutation.js klasÃ¶rÃ¼ user alanÄ± aÅŸaÄŸÄ±daki gibi dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  export const Mutation = {
    // User
    createUser: async (_, { data }, { pubSub, _db }) => {
      const newUser = new _db.User({
        ...data,
      });
  
      const user = await newUser.save();
      
      pubSub.publish("userCreated", { userCreated: user });
  
      return user;
    },
    updateUser: async (_, { id, data }, { pubSub, _db }) => {
      const is_user_exist = await _db.User.findById(id);
      if (!is_user_exist) {
        throw new Error("User not found.");
      }
  
      const update_user = await _db.User.findByIdAndUpdate(id, data, {
        new: true, // bize gÃ¼ncellenen kullanÄ±cÄ±nÄ±n datasÄ±nÄ± dÃ¶nmesi iÃ§in yazÄ±ldÄ±.
      })
      pubSub.publish("userUpdated", { userUpdated: update_user });
      return update_user;
    },
    deleteUser: async (_, { id }, { pubSub, _db }) => {
      const is_user_exist = await _db.User.findById(id);
      if (!is_user_exist) {
        throw new Error("User not found.");
      }
  
      const deleted_user = await _db.User.findByIdAndDelete(id)
  
      pubSub.publish("userDeleted", { userDeleted: deleted_user });
      return deleted_user;
    },
    deleteAllUsers: async (_, __, { _db }) => {
      const delete_users = await _db.User.deleteMany({});
  
      return {
        count: delete_users.deletedCount,
      };
    },
    // Post
    ...
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="refactoringPostMutation">
                <h1>Refactoring Post Mutations</h1>
                <p>
                  Mutation iÅŸlemlerimizi mongoose Ã¼zerinden yapmak iÃ§in server\src\graphql\resolvers\resolvers\Mutation.js klasÃ¶rÃ¼ post alanÄ± aÅŸaÄŸÄ±daki gibi dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  export const Mutation = {
    ...
    // Post
    createPost: async (_, { data }, { pubSub, _db }) => {
      const newPost = new _db.Post({
        ...data,
      });
  
      const post = await newPost.save();
  
      const user = await _db.User.findById(data.user);
      user.posts.push(post.id);
      user.save(); // bu Ã¼Ã§ satÄ±r post bilgisini ilgili usera eklemek iÃ§in
  
      const postsCount = await _db.Post.countDocuments();
  
      pubSub.publish("postCreated", { postCreated: post });
      pubSub.publish("postsCount", { postsCount });
      return post;
    },
    updatePost: async (_, { id, data }, { pubSub, _db }) => {
      const is_post_exist = await _db.Post.findById(id);
      if (!is_post_exist) {
        throw new Error("Post not found.");
      }
  
      const updated_post = await _db.Post.findByIdAndUpdate(id, data, {
        new: true, // bize gÃ¼ncellenen kullanÄ±cÄ±nÄ±n datasÄ±nÄ± dÃ¶nmesi iÃ§in yazÄ±ldÄ±.
      });
  
      pubSub.publish("postUpdated", { postUpdated: updated_post });
      return updated_post;
    },
    deletePost: async (_, { id }, { pubSub, _db }) => {
      const is_post_exist = await _db.Post.findById(id);
      if (!is_post_exist) {
        throw new Error("User not found.");
      }
  
      const postDeleted = await _db.Post.findByIdAndDelete(id);
  
      const postsCount = await _db.Post.countDocuments();
  
      pubSub.publish("postDeleted", { postDeleted });
      pubSub.publish("postsCount", { postsCount });
  
      return postDeleted;
    },
    deleteAllPosts: async (_, __, { pubSub, _db }) => {
      const deleted_posts = await _db.Post.deleteMany({});
  
      pubSub.publish("postsCount", { postsCount: 0 });
      return {
        count: deleted_posts.deletedCount,
      };
    },
  
    ...
  };
  
                  </pre>
                </p>
                <p>
                  server\src\graphql\type-defs\Post.graphql de aÅŸaÄŸÄ±daki deÄŸiÅŸiklik yapÄ±ldÄ±
                  <pre class="prettyprint ms-0">
  ...
  }
  input CreatePostInput {
    title: String!
    description: String
    short_description: String
    cover: String
    user: ID! # user_id yerine user yazÄ±ldÄ±.
  }
  input UpdatePostInput {
    title: String
    description: String
    short_description: String
    cover: String
    user: ID
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="refactoringCommentMutation">
                <h1>Refactoring Comment Mutations</h1>
                <p>
                  Mutation iÅŸlemlerimizi mongoose Ã¼zerinden yapmak iÃ§in server\src\graphql\resolvers\resolvers\Mutation.js klasÃ¶rÃ¼ comment alanÄ± aÅŸaÄŸÄ±daki gibi dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
  export const Mutation = {
    ...
  
    // Comment
    createComment: async (_, { data }, { pubSub, _db }) => {
      const newComment = new _db.Comment(data);
      const createdComment = await newComment.save();
  
      const post = await _db.Post.findById(data.post);
      const user = await _db.User.findById(data.user);
  
      post.comments.push(createdComment.id);
      user.comments.push(createdComment.id);
  
      await post.save();
      await user.save();
  
      pubSub.publish("commentCreated", { commentCreated: createdComment });
      return createdComment;
    },
    updateComment: async (_, { id, data }, { pubSub, _db }) => {
      const is_comment_exist = await _db.Comment.findById(id);
      if (!is_comment_exist) {
        throw new Error("Comment not found.");
      }
  
      const updated_comment = await _db.Comment.findByIdAndUpdate(id, data, {
        new: true, // bize gÃ¼ncellenen kullanÄ±cÄ±nÄ±n datasÄ±nÄ± dÃ¶nmesi iÃ§in yazÄ±ldÄ±.
      });
  
      pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
  
      return updated_comment;
    },
    deleteComment: async (_, { id }, { pubSub, _db }) => {
      const is_commet_exist = await _db.Comment.findById(id);
      if (!is_commet_exist) {
        throw new Error("Comment not found.");
      }
  
      const commentDeleted = await _db.Comment.findByIdAndDelete(id);
  
      pubSub.publish("commentDeleted", { commentDeleted });
      return commentDeleted;
    },
    deleteAllComments: async (_, __, { _db }) => {
      const deleted_comment = await _db.Comment.deleteMany({});
      
      return {
        count: deleted_comment.deletedCount,
      };
    },
  };
  
                  </pre>
                </p>
                <p>
                  server\src\graphql\type-defs\Comment.graphql iÃ§indeki user_id ve post_id <q>user</q> ve <q>post</q> olarak gÃ¼ncellendi.
                  <pre class="prettyprint ms-0">
  type Comment {
    id: ID!
    text: String!
    post: Post!
    user: User!
  }
  input CreateCommetInput {
    text: String!
    post: ID!
    user: ID!
  }
  input UpdateCommentInput {
    text: String
    post: ID
    user: ID
  }
  
  ...
  
                  </pre>
                </p>
              </div>
              <div class="row" id="refactoringSubscriptions">
                <h1>Refactoring Subscriptions</h1>
                <p>
                  server\src\graphql\resolvers\resolvers\Subscription.js dosyasÄ±nda aÅŸaÄŸÄ±daki deÄŸiÅŸiklikler yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import { filter, pipe } from "graphql-yoga";
  
  export const Subscription = {
    ...
  
    // Post
    postCreated: {
      subscribe: (_, args, { pubSub }) => {
        return pipe(
          pubSub.subscribe("postCreated"), 
          filter(
            (
              value 
            ) =>
              args.user_id 
                ? value.postCreated.user == args.user_id // value.postCreated.user_id deÄŸiÅŸtirildi
                : true 
          )
        );
      },
    },
  
    ...
    postsCount: {
      subscribe: async (_, __, { pubSub, _db }) => {
        const postsCount = await _db.Post.countDocuments(); // mevcut post sayÄ±sÄ± Ã§ekildi.
  
        setTimeout(() => {
          pubSub.publish("postsCount", { postsCount });
        });
        return pubSub.subscribe("postsCount");
      },
    },
  
    ...
    // Comment
    commentCreated: {
      subscribe: (_, args, { pubSub }) => {
        return pipe(
          pubSub.subscribe("commentCreated"),
          filter((value) =>
            args.post_id ? value.commentCreated.post == args.post_id : true // value.commentCreated.post_id deÄŸiÅŸtirildi
          )
        );
      },
    },
    ...
  };
                  </pre>
                </p>
                <p>
                  server\src\graphql\type-defs alanÄ±ndaki tip tanÄ±mlarÄ±nda <code>type User</code>, <code>type Post</code> ve <code>type Comment</code> alanlarÄ±ndaki <code>id</code> parametresi <code>_id</code> olarak gÃ¼ncellendi.
                </p>
              </div>
              <div class="row" id="apolloClientUpdates">
                <h1>Apollo Client GÃ¼ncellemeleri</h1>
                <p>
                  client tarafÄ±nda queries.js dosyalarÄ±nda <code>id</code> ifadeleri <code>_id</code> olarak gÃ¼ncellendi.
                </p>
                <p>
                  client\src\pages\Home\index.js dosyasÄ±nda <code>item.id</code> ifadeleri <code>item._id</code> olarak gÃ¼ncellendi.
                </p>
                <p>
                  client\src\pages\Post\Comments\NewCommentForm.js dosyasÄ±nda <code>item.id</code> ifadeleri <code>item._id</code> olarak gÃ¼ncellendi. <code>user_id</code> ifadesi <code>user</code> olarak gÃ¼ncellendi. <code>variables</code> altÄ±nda <code>data</code> olarak gÃ¶nderilen ifade <code>data: { ...values, post_id }</code> yerine <code>data: { ...values, post: post_id }</code> olarak gÃ¼ncellendi.
                </p>
                <p>
                  client\src\pages\NewPost\NewPostForm.js iÃ§inde <code>item.id</code> ifadesi <code>item._id</code> olarak gÃ¼ncellendi. <code>user_id</code> ifadesi <code>user</code> olarak gÃ¼ncellendi.
                </p>
                <p>
                  Postlar listelenirken en gÃ¼nceli en Ã¼stte olmasÄ± iÃ§in server tarafÄ±nda server\src\graphql\resolvers\resolvers\Query.js dosyasÄ±nda aÅŸaÄŸÄ±daki gÃ¼ncelleme yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  export const Query = {
    ...
  
    posts: async (_, __, { _db }) => {
      const posts = await _db.Post.find().sort({ _id: -1 });
      return posts;
    },
    ...
  };
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="hasura">
              <div class="row" id="enterToHasura">
                <h1>Hasura'ya GiriÅŸ ve Query</h1>
                <p>
                  GraphQl backendleri geliÅŸtirebileceÄŸimiz bir ortam. <a href="https://hasura.io/">hasura.io</a>. Alternatif olarak <a href="https://www.prisma.io/graphql">prisma.io/graphql</a>
                </p>
                <p>
                  Hasura.io>"login">"project">"new project">"create free project"
                </p>
                <p>
                  Yeni proje iÃ§inden "launch console" tÄ±klandÄ± Gelen ekranda "Data" > "postgres" > "neon" > "connect neon database" denilerek yeni database oluÅŸturuldu 
                </p>
                <p>
                  OluÅŸan database iÃ§inde public altÄ±nda "new table" denildi. Gelen form dolduruldu. Tablo doldururma dÃ¼zeni SQL ile aynÄ±. YardÄ±m gerekirse SQL notlarÄ±na bakÄ±labilir. "add table" ile tablomuz kaydedildi
                </p>
                <p>
                  database alanÄ±nda users tÄ±klanarak oluÅŸturduÄŸumuz database'e ulaÅŸÄ±p iÅŸlem yapabiliriz.
                </p>
                <p>
                  "DATA" alanÄ±na users tablosunu oluÅŸturduktan sonra "API" alanÄ±na dÃ¶ndÃ¼ÄŸÃ¼mÃ¼zde bizi:
                  <ul>Ã¼Ã§ adet hazÄ±r query
                    <li><b>users(
                      distinct_on: [users_select_column!]
                      limit: Int
                      offset: Int
                      order_by: [users_order_by!]
                      where: users_bool_exp
                      )</b>: tÃ¼m userlarÄ± sorgular</li>
                    <li><b>users_aggregate(
                      distinct_on: [users_select_column!]
                      limit: Int
                      offset: Int
                      order_by: [users_order_by!]
                      where: users_bool_exp
                      )</b>: toplam user sayÄ±sÄ±</li>
                    <li><b>user_by_pk(id: Int)</b> id ye gÃ¶re tekli user sorgular.</li>
                  </ul>
                  <ul>yedi adet hazÄ±r mutation:
                    <li><b>delete_users(where: users_bool_exp!)</b>: tÃ¼m userlarÄ± silmek iÃ§in</li>
                    <li><b>delete_users_by_pk(id: Int!)</b>: id ye gÃ¶re bir user silmek iÃ§in</li>
                    <li><b>insert_users(objects: [users_insert_input!]!on_conflict: users_on_conflict)</b>: birden fazla user eklemek iÃ§in</li>
                    <li><b>insert_users_one(object: users_insert_input!on_conflict: users_on_conflict)</b>: bir user eklemek iÃ§in</li>
                    <li><b>update_users(
                      _inc: users_inc_input
                      _set: users_set_input
                      where: users_bool_exp!
                      )</b>: tÃ¼m userlarÄ± gÃ¼ncellemek iÃ§in</li>
                    <li><b>update_users_by_pk(
                      _inc: users_inc_input
                      _set: users_set_input
                      pk_columns: users_pk_columns_input!
                      )</b>: id ye gÃ¶re bir user gÃ¼ncellemek iÃ§in</li>
                    <li><b>update_users_many(updates: [users_updates!]!)</b>: birden fazla user gÃ¼ncellemek iÃ§in</li>
                  </ul>
                  <ul>dÃ¶rt hazÄ±r subscription
                    <li><b>users</b>: tablodaki her deÄŸiÅŸiklik iÃ§in</li>
                    <li><b>users_aggregate(
                      distinct_on: [users_select_column!]
                      limit: Int
                      offset: Int
                      order_by: [users_order_by!]
                      where: users_bool_exp
                      )</b>: tablodaki sayÄ±sal her deÄŸiÅŸiklik iÃ§in</li>
                    <li><b>users_by_pk(id: Int!)</b>: id ye gÃ¶re bir userda her deÄŸiÅŸiklik iÃ§in</li>
                    <li><b>users_stream(
                      batch_size: Int!
                      cursor: [users_stream_cursor_input]!
                      where: users_bool_exp
                      )</b></li>
                  </ul>
                </p>
                <p>
                  query sorgularÄ± SQL ile uyumlu. Sayfa iÃ§indeki "Explorer" sekmesi bÃ¼tÃ¼n sorgulanabilir parametreleri iÃ§eriyor.
                </p>
              </div>
              <div class="row" id="hasuraMutations">
                <h1>Hasura Mutations</h1>
                <p>
                  Mutationlar genel anlamda bildiÄŸimiz gibi. SQL sorgusu yapÄ±sÄ±yla kurallar ekleyebiliyoruz. "Explorer" kÄ±smÄ±nda hepsi var
                </p>
                <p>
                  insert_users ile birden fazla user eklemek iÃ§in object iÃ§ine array iÃ§inde object yapÄ±sÄ±yla bu userlar yerleÅŸtirilir.
                </p>
              </div>
              <div class="row" id="hasuraSubscriptions">
                <h1>Hasura Subscriptions</h1>
                <p>
                  "Explorer" sekmesi ile Ã§ok rahat keÅŸfedilebiliyor.
                </p>
                <p>
                  Hasura databasete olan her deÄŸiÅŸikliÄŸi subscribe edebiliyor.
                </p>
                <p>
                  SQL tipi limitlemeler konulabiliyor.
                </p>
              </div>
              <div class="row" id="hasuraRelationships">
                <h1>Relationships</h1>
                <p>
                  database altÄ±nda todos adÄ±nda bir tablo oluÅŸturduk. Tablonun user_id parametresini "Foreign Keys" yapÄ±sÄ± ile user tablosundaki id ile eÅŸleÅŸtirdik. Bu sÄ±rada "On Delete Violation": "cascade" olarak seÃ§ildi. Bu durumda bir user silindiÄŸinde ona baÄŸlÄ± tÃ¼m todo elemanlarÄ± da silinecek.
                </p>
                <p>
                  users tablosunda "Relationships" sekmesinde bize bir array relationship Ã¶neriyor. Bunu ekleyip adÄ±nÄ± "todos" olarak seÃ§tik.
                </p>
                <p>
                  todos tablosunda "Relationships" sekmesinde bize bir object relationship Ã¶neriyor. Bunu ekleyip adÄ±nÄ± "user" olarak seÃ§tik.
                </p>
                <p>
                  YaptÄ±ÄŸÄ±mÄ±z iÅŸlem sonucunda user sorgusu altÄ±nda todo, todo sorgusu altÄ±nda da user otomatik olarak yer alÄ±yor.
                </p>
              </div>
              <div class="row" id="hasuraCustomActions">
                <h1>Custom Actions</h1>
                <p>
                  Hasurada "ACTIONS" sekmesi altÄ±ndan ulaÅŸÄ±lÄ±yor. HasuranÄ±n hazÄ±r verdikleri dÄ±ÅŸÄ±nda yapmak istediÄŸimiz iÅŸlemler iÃ§in kullanÄ±yoruz.
                </p>
                <p>
                  "Action Defination" alanÄ±na yeni dahil edeceÄŸimiz query veya mutation yazÄ±lÄ±r.
                  <pre class="prettyprint ms-0">
  type Query {
    hello: HelloOutput!
  }
                  </pre>
                </p>
                <p>
                  "Type Configuration" alanÄ±na yukarÄ±daki iÅŸlem iÃ§in gereken yeni tip tanÄ±mÄ± yapÄ±lÄ±r
                  <pre class="prettyprint ms-0">
  type HelloOutput {
   message: String!
  }
                  </pre>
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" verinin Ã§ekileceÄŸi yeri belirtir. (Åimdilik <q>http://host.docker.internal:3000</q> yazdÄ±k)
                </p>
                <p>
                  "Create Action" dediÄŸimizde yeni bir query tanÄ±mlamÄ±ÅŸ olduk.
                </p>
                <p>
                  Actions>hello tÄ±klanarak "Codegen" sekmesi aÃ§Ä±ldÄ±ÄŸÄ±nda backendde Ã§alÄ±ÅŸmasÄ± gereken fonksiyon gÃ¶rÃ¼nÃ¼r. "try on glich" denilerek kod <a href="https://glitch.com/">glitch.com</a> Ã¼zerinde aÃ§Ä±ldÄ±. Bu bize backend oluÅŸturmadan actionumuzu deneme fÄ±rsatÄ± sunar. 
                </p>
                <p>
                  Glitch iÃ§inde src/server.js de dÃ¶nen response <code>message: "world"</code> olarak dÃ¼zenlendi. "preview" sekmesi sayesinde glitch projesinin linli alÄ±ndÄ±. Bu linki kendi actionumuzda handler alanÄ±na <code>.../hello</code> endpointi ile gireceÄŸiz.
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" alanÄ± glitch serverÄ±ndaki yÃ¶nlendirme ile deÄŸiÅŸtirildi:  <q>https://vintage-abalone-manuscript.glitch.me/hello</q>
                </p>
                <p>
                  API alanÄ±na 
                  <pre class="prettyprint ms-0">
  query helloQuery {
    hello {
      message
    }
  }
                  </pre>
                  yazdÄ±ÄŸÄ±mÄ±zda
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "hello": {
        "message": "world"
      }
    }
  }
                  </pre> Ã§Ä±ktÄ±sÄ± alÄ±nÄ±yor.
                </p>
  
                <h2>Ã–rnek 2</h2>
                <p>
                  "Action Defination"
                  <pre class="prettyprint ms-0">
  type Query {
    hello(data: HelloInput): HelloOutput!
  }
                  </pre>
                  "Type Configuration" > "Declare New Types"
                  <pre class="prettyprint ms-0">
  type HelloOutput {
    message: String!
  }
  
  input HelloInput{
    name: String!
  }
                  </pre>
                </p>
                <p>
                  Glitch iÃ§inde src/server.js
                  <pre class="prettyprint ms-0">
  const express = require("express");
  const bodyParser = require("body-parser");
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  // paste the code from codegen here
  
  app.post("/hello", async (req, res) => {
    const { name } = req.body.input.data;
  
    return res.json({
      message: `hello ${name}`,
    });
  });
  
  app.listen(PORT);
                  </pre>
                </p>
                <p>
                  API alanÄ±na 
                  <pre class="prettyprint ms-0">
  query helloQuery {
    hello(data: {name: "Murat"}) {
      message
    }
  }
                  </pre>
                  yazdÄ±ÄŸÄ±mÄ±zda
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "hello": {
        "message": "hello Murat"
      }
    }
  }
                  </pre> Ã§Ä±ktÄ±sÄ± alÄ±nÄ±yor.
                </p>
  
                <h2>Ã–rnek 3</h2>
                <p>
                  "Action Defination"
                  <pre class="prettyprint ms-0">
  type Mutation {
    singUp (data: SingUpInput!): SingUpOutput!
  }
                  </pre>
                  "Type Configuration" > "Declare New Types"
                  <pre class="prettyprint ms-0">
  type SingUpOutput {
    accessToken: String!
  }
  
  input SingUpInput {
    email: String!
  }
                  </pre>
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" e ÅŸimdilik <q>http://host.docker.internal:3000</q> yazdÄ±k.
                </p>
                <p>
                  "Create Action"
                </p>
                <p>
                  Actions>singUp>"Codegen">"Try on glitch"
                </p>
                <p>
                  Glitch iÃ§inde src/server.js
                  <pre class="prettyprint ms-0">
  const express = require("express");
  const bodyParser = require("body-parser");
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  app.post("/singUp", async (req, res) => {
    const { email } = req.body.input.data;
  
    return res.json({
      accessToken: `thisIsAnAccessTokenFor${email}`,
    });
  });
  
  app.listen(PORT);
  
                  </pre>
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" alanÄ± glitch serverÄ±ndaki yÃ¶nlendirme ile deÄŸiÅŸtirildi:  <q>https://vintage-abalone-manuscript.glitch.me/singUp</q>
                </p>
                <p>
                  API alanÄ±na 
                  <pre class="prettyprint ms-0">
  mutation SingUp {
    singUp(data: {email: "drmuratgokduman@gmail.com"}) {
      accessToken
    }
  }
                  </pre>
                  yazdÄ±ÄŸÄ±mÄ±zda
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "singUp": {
        "accessToken": "thisIsAAccessTokenFordrmuratgokduman@gmail.com"
      }
    }
  }
                  </pre> Ã§Ä±ktÄ±sÄ± alÄ±nÄ±yor.
                </p>
  
                <h2>Ã–rnek 4</h2>
                <p>
                  Ã–rnek 3 Ã¼zerinden devam ediyoruz.
                </p>
                <p>
                  YaptÄ±ÄŸÄ±mÄ±z iÅŸlemin hasura Ã¼zerindeki databasee iÅŸlem yapabilmesi iÃ§in "Hasura Cloud" iÃ§inde proje sayfamÄ±zdaki "Env vars" alanÄ±ndaki <q>HASURA_GRAPHQL_ADMIN_SECRET</q> alanÄ±na ihtiyacÄ±mÄ±z var. Biz onu ÅŸimdilik <code>123456</code> olarak belirledik.
                </p>
                <p>
                  Glitch tarafÄ±nda bu iÅŸlemi yapabilmek iÃ§in iki pakete ihtiyacÄ±mÄ±z var. "+ ADD PACKAGE" ile "grapgql" ve "graphql-request" kuruldu. "graphql-request" gÃ¼ncel versiyon Ã§alÄ±ÅŸmadÄ± biz de package.json iÃ§inde "graphql-request": "^3.3.0" yazÄ±p eski versiyonu kurdurduk. Glitch node versiyonu gÃ¼ncel halini Ã§alÄ±ÅŸtÄ±ramÄ±yor.
                </p>
                <p>
                  src/clients/hasura.js oluÅŸturuldu.
                  <pre class="prettyprint ms-0">
  import { GraphQLClient } from "graphql-request";
  
  const headers = {
    "Content-Type": "application/json",
    "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
  };
  
  const client = new GraphQLClient(process.env.HASURA_ENDPOINT, { headers });
  
  export default client;
                  </pre>
                  .env iÃ§inde "HASURA_ENDPOINT" ve "HASURA_ADMIN_SECRET" oluÅŸturuldu. <br>
                  src/queries.js oluÅŸturuldu. ve iÃ§ine istediÄŸimiz iÅŸi yapacak sorgu eklendi.
                  <pre class="prettyprint ms-0">
  export const INSERT_USER_MUTATION = `
  mutation AddUser($input: users_insert_input!) {
    insert_users_one(
      object: $input
    ) {
      id
      email
      fullName
    }
  }
  `;
                  </pre>
                  tÃ¼m eklenenler src/server.js iÃ§ine import edilip kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
  import express from "express";
  import bodyParser from "body-parser";
  import Hasura from "./clients/hasura";
  import { INSERT_USER_MUTATION } from "./queries";
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  app.post("/singUp", async (req, res) => {
    const { email, fullName } = req.body.input.data;
  
    const { insert_users_one } = await Hasura.request(INSERT_USER_MUTATION, {
      input: {
        fullName,
        email,
      },
    });
  
    return res.json({
      id: insert_users_one.id,
    });
  });
  
  app.listen(PORT);
                  </pre>
                </p>
                <p>
                  actions>singUp (aksiyonumuz)>"Relationship">"Add a relationship" deyip tabloyu dolduruyoruz. BÃ¶ylece response olarak dÃ¶nen id bilgisini users tablosuna baÄŸlÄ±yoruz.
                </p>
                <p>
                  Hasura Ã¼zerinden aÅŸaÄŸÄ±daki mutation gerÃ§ekleÅŸince
                  <pre class="prettyprint ms-0">
  mutation MyMutation {
    singUp(data: {email: "mx@m", fullName: "Murat 3"}) {
      id
      user {
        fullName
        email
        age
        created_at
        todos {
          id
          text
        }
      }
    }
  }
                  </pre>
                  aÅŸaÄŸÄ±daki sonuÃ§ alÄ±nÄ±r.
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "singUp": {
        "id": 22,
        "user": {
          "fullName": "Murat 3",
          "email": "mx@m",
          "age": null,
          "created_at": "2023-07-22T18:04:09.612366+00:00",
          "todos": []
        }
      }
    }
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraRemoteSchemas">
                <h1>Remote Schemas</h1>
                <p>
                  Graphql yapÄ±sÄ± ile hazÄ±rlanmÄ±ÅŸ baÅŸka bir projeyi kendi hasura projemize dahil etmek iÃ§in tek gereken eklemek istediÄŸimiz projenin endpointi.
                </p>
                <p>
                  Hasura iÃ§inde "Remote Schemas">"Add" dedikten sonra "GraphQL Service URL" alanÄ±na eklemek istediÄŸimiz endpointi yerleÅŸtirip formu dolduruyoruz ve "Add Remote Schemas" diyoruz.
                </p>
                <p>
                  Ã–rnek graphql api iÃ§in <a href="https://github.com/graphql-kit/graphql-apis">https://github.com/graphql-kit/graphql-apis</a>
                </p>
              </div>
              <div class="row" id="hasuraEventTriggers">
                <h1>Event Triggers</h1>
                <p>
                  Veri tabanÄ±nda bir deÄŸiÅŸiklik olduÄŸunda bir olay baÅŸlatmak iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin yeni bir kullanÄ±cÄ± eklendiÄŸinde o kullanÄ±cÄ±ya hoÅŸgeldiniz maili gÃ¶ndermek gibi.
                </p>
                <p>
                  <b>Cron trigers</b> kÄ±smÄ±nda da zamana baÄŸlÄ± tetiklenen aksiyonlar yazÄ±labilir.
                </p>
                <p>
                  <b>One-off Scheduled Events</b> spesifik bir zamanda Ã§alÄ±ÅŸacak aksiyonlar yazÄ±labilir. Ã–rneÄŸin meeting uygulamasÄ± geliÅŸtirirken toplantÄ±dan 30 dk Ã¶nce tÃ¼m katÄ±lÄ±mcÄ±lara mesaj at vs.
                </p>
  
                <h2>Ã–rnek</h2>
                <p>
                  <b>Senaryo:</b> Yeni bir kullanÄ±cÄ± eklendiÄŸinde kullanÄ±cÄ±ya hoÅŸgeldin maili gÃ¶nder.
                </p>
                <p>
                  "Event Triggers">"Create"> ile gelen formu dolduruyoruz. Åimdilik Webhook (HTTP/S) Handler alanÄ±na <a href="https://requestcatcher.com/">requestcatcher.com</a> sitesinde yarattÄ±ÄŸÄ±mÄ±z <q>https://hasura.requestcatcher.com/test</q> adresini giriyoruz. Bu durumda hasurada event tetiklendiÄŸinde giden requesti gÃ¶receÄŸiz. Sonra "Create Event Trigger" deyip eventi ekliyoruz.
                </p>
                <p>
                  DATA alanÄ±na elle bir kullanÄ±cÄ± ekledik. Bunun sonucunda https://hasura.requestcatcher.com/ sayfasÄ±nda
                  <pre class="prettyprint ms-0">
  POST /test HTTP/1.1
  Host: hasura.requestcatcher.com
  Accept-Encoding: gzip
  Content-Length: 570
  Content-Type: application/json
  User-Agent: hasura-graphql-engine/v2.30.0-cloud.1
  X-B3-Parentspanid: 6462ab0e7396c73e
  X-B3-Sampled: 1
  X-B3-Spanid: f36b8d8071646d5f
  X-B3-Traceid: 178ea92cb8a666af9c790c407ac51580
  
  {"created_at":"2023-07-24T04:55:44.799386","delivery_info":{"current_retry":0,"max_retries":0},"event":{"data":{"new":{"age":5,"created_at":"2023-07-24T04:55:44.799386+00:00","email":"bora@bora.com","fullName":"Bora GÃ¶kduman","id":23,"updated_at":"2023-07-24T04:55:44.799386+00:00"},"old":null},"op":"INSERT","session_variables":{"x-hasura-role":"admin"},"trace_context":{"span_id":"412a8a544a7f6506","trace_id":"178ea92cb8a666af9c790c407ac51580"}},"id":"a2946095-c160-40a4-b8b3-14c5db415a05","table":{"name":"users","schema":"public"},"trigger":{"name":"insert_user"}}
                  </pre>
                  Ã§Ä±ktÄ±sÄ± alÄ±ndÄ±.
                </p>
                <p>
                  Daha Ã¶nce kullandÄ±ÄŸÄ±mÄ±z glitch serverina geri dÃ¶nÃ¼p iÅŸlemlerimize <a href="https://glitch.com/edit/#!/vintage-abalone-manuscript">oradan</a> devam edeceÄŸiz. Mail gÃ¶nderimi iÃ§in "nodemailer" paketi projeye eklendi.
                </p>
                <p>
                  server.js
                  <pre class="prettyprint ms-0">
  import express from "express";
  import bodyParser from "body-parser";
  import Hasura from "./clients/hasura";
  import { INSERT_USER_MUTATION } from "./queries";
  
  import nodemailer from "nodemailer";
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  ...
  
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: "myhasurabackendd@gmail.com",
      pass: "efuvzfpjocfdemnc",
    },
  });
  
  app.post("/send-email", async (req, res) => {
    const { email, fullName } = await req.body.event.data.new;
  
    const mailOptions = {
      from: "myhasurabackendd@gmail.com",
      to: email,
      subject: "AramÄ±za hoÅŸgeldin",
      text: `AramÄ±za hoÅŸgeldin ${fullName}`,
    };
    
    transporter.sendMail(mailOptions, (e, i) => {
      if(e){
        throw new Error("Error while sending email")
      }
      
      res.json({
        message: "Email sent ->" + email
      })
    })
  });
  
  app.listen(PORT);
  
                  </pre>
                </p>
                <p>
                  Gmail hesabÄ±nÄ±n Ã¼Ã§Ã¼ncÃ¼ taraf uygulamasÄ±na kendi adÄ±na mail izni vermesi iÃ§in 2 aÅŸamalÄ± doÄŸrulama aÃ§Ä±lmalÄ± ve o kÄ±smÄ±n iÃ§inden uygulama ÅŸifresi oluÅŸturuldu.
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" alanÄ± glitch serverÄ±ndaki yÃ¶nlendirme ile deÄŸiÅŸtirildi:  <q>https://vintage-abalone-manuscript.glitch.me/send-email</q>
                </p>
                <p>
                  Bu durumda her yeni kullanÄ±cÄ± oluÅŸtuÄŸunda kullanÄ±cÄ±ya mail atÄ±lÄ±r.
                </p>
              </div>
            </div>
            <div class="row" id="commentAppWithHasura">
              <div class="row" id="commentHasuraDocker">
                <h1>Hasura Docker YapÄ±landÄ±rmasÄ±</h1>
                <p>
                  Bu bÃ¶lÃ¼mde daha Ã¶nce yaptÄ±ÄŸÄ±mÄ±z comment uygulamasÄ±nÄ±n backendini hasura ile yazacaÄŸÄ±z.
                </p>
                <p>
                  Lokalde hasura Ã§alÄ±ÅŸturmak iÃ§in <a href="https://hasura.io/docs/latest/getting-started/docker-simple/">Quickstart with Hasura using Docker</a> dÃ¶kÃ¼manÄ±nÄ± kullanacaÄŸÄ±z. Bunun iÃ§in <a href="https://docs.docker.com/get-docker/">Docker</a> ve <a href="https://docs.docker.com/compose/install/">Docker Compose version 2.0 or higher</a> ilgili adreslerden indirilip kurulur. Docker Compose yeni versiyonlard DocÅŸker iÃ§inde gelmektedir. Bu nedenle ayrÄ±ca kurmaya gerek yoktur.
                </p>
                <p>
                  Yeni bir proje klasÃ¶rÃ¼ oluÅŸturduk: "comment-challenge-with-hasura" ve altÄ±na server klasÃ¶rÃ¼ oluÅŸturduk. Terminalde bu server klasÃ¶rÃ¼ne gidip <pre class="prettyprint ms-0">curl https://raw.githubusercontent.com/hasura/graphql-engine/stable/install-manifests/docker-compose/docker-compose.yaml -o docker-compose.yml</pre> dedik ve cevap olarak server iÃ§inde <q>docker-compose.yml</q> dosyasÄ± oluÅŸtu. 
                </p>
                <p>
                  docker desktop yÃ¶netici olarak aÃ§Ä±ldÄ± ve girildi. Docker'Ä±n aÃ§Ä±lmasÄ± iÃ§in bilgisayara WSL kuruldu ve WSL 2 ye updaye edildi. Bunun iÃ§in <a href="https://learn.microsoft.com/tr-tr/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">bu dÃ¶kÃ¼man</a> kullanÄ±ldÄ± 
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker-compose up</pre> yazmak gerekir ancak bu iÅŸlev yÃ¶netici yetkisi olmadan iÅŸ bilgisayarÄ±nda aÃ§Ä±lmÄ±yor. Bu nedenle server klasÃ¶rÃ¼nde dosya>"windows powersheli aÃ§">"windows powersheli yÃ¶netici olarak aÃ§" denir ve burada konut girilir.
                </p>
                <p>
                  "docker-compose up" iÃ§in "postgres:15" ve "hasura/graphql-engine:v2.30.0"ve "hasura/graphql-data-connector:v2.30.0" image dosyalarÄ± gerekiyor. BunlarÄ± kendisi indiriyor. Sonra server <a href="http://localhost:8080/">http://localhost:8080/</a> ayaÄŸa kalkÄ±yor. Burada hasura arayÃ¼zÃ¼ bizi karÅŸÄ±lÄ±yor. 
                </p>
                <p>
                  DATA altÄ±ndan "Connect Database" kÄ±smÄ±nda "Connect Existing Database" denilir ve Database URL kÄ±smÄ±nda server\docker-compose.yml dosyasÄ±nda "HASURA_GRAPHQL_METADATA_DATABASE_URL": karÅŸÄ±sÄ±ndaki url yazÄ±lÄ±r.
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">hasura consol</pre> yazÄ±p Ã§alÄ±ÅŸtÄ±rmak iÃ§in Hasura CLI bilgisayara kuruldu ve Hasura'yÄ± global olarak eriÅŸilebilir kÄ±lmak iÃ§in yolu PATH ortam deÄŸiÅŸkenine ekledik. sonra terminale <pre class="prettyprint ms-0">hasura init</pre> yazdÄ±k ve enter yaptÄ±k. server altÄ±nda hasura adlÄ± bir dizin oluÅŸtu. Bunun iÃ§indeki metadata hasurada oluÅŸturduÄŸumuz actionlarÄ± vs, migration tablo oluÅŸturmak iÃ§in kullanÄ±lan sql konutlarÄ±nÄ±, seeds iÃ§inde de tanÄ±mlarÄ± saklar. 
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  cd hasura
  hasura console
                  </pre>
                  yazÄ±nca <a href="http://localhost:9695/">http://localhost:9695/</a> portunda hasura aÃ§Ä±ldÄ±. Burada yaptÄ±ÄŸÄ±mÄ±z her dÃ¼zenleme hasura dizininde kaydedilir.
                </p>
                <p>
                  localhost:8080 tarafÄ±nda yaptÄ±ÄŸÄ±mÄ±z iÅŸlemler kaydedilmeyeceÄŸinden bu kÄ±sÄ±mda Ã§alÄ±ÅŸmamÄ±za gerek yok. Buraya giriÅŸi engellemek iÃ§in server\docker-compose.yml iÃ§indeki environment altÄ±nda <code>HASURA_GRAPHQL_ENABLE_CONSOLE:</code> ifadesi false yapÄ±lÄ±r. ve terminal server'dayken <pre class="prettyprint ms-0">docker-compose up --build</pre> denilerek deÄŸiÅŸiklikler devreye alÄ±nÄ±r.
                </p>
                <p>
                  hasura, <code>hasura console</code> tanÄ±mÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken ÅŸifre istesin istiyorsak server\docker-compose.yml iÃ§indeki environment altÄ±nda <code>HASURA_GRAPHQL_ADMIN_SECRET:</code> karÅŸÄ±sÄ±na bir deÄŸer eklenir ve hasura tekrar build edilir. Production ortamÄ± iÃ§in gerekli. development ortamÄ± iÃ§in olmasÄ±na gerek yok.
                </p>
              </div>
              <div class="row" id="commentHasuraData">
                <h1>VeritabanÄ± Mimarisinin OluÅŸturulmasÄ±</h1>
                <p>
                  Bu kÄ±sÄ±mda lokalde Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z Hasura kullanÄ±ldÄ±. Daha Ã¶nceki hasura derslerindeki yol ile "DATA" altÄ±nda users, posts ve comments tablolarÄ± "DATA" oluÅŸturuldu. AralarÄ±nda forign key yapÄ±sÄ± ile baÄŸ kuruldu. "Relationship" ile de Ã¼Ã§ tablo birbirine baÄŸlandÄ±.
                </p>
              </div>
              <div class="row" id="commentHasuraClient1">
                <h1>Client Entegrasyonu - 1</h1>
                <p>
                  Daha Ã¶nce comment-app olarak oluÅŸturduÄŸumuz client bu projeye kopyalandÄ±. Bunun Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ±z
                </p>
                <p>
                  porjemiz graphql-yoga tarafÄ±ndayken subscription web soket paketine ihtiyaÃ§ olmadan alÄ±nÄ±yordu. Hasura backendinde apolloclient bu pakete ihtiyaÃ§ duyuyor. Bunun iÃ§in client iÃ§inden terminale <pre class="prettyprint ms-0">npm i subscriptions-transport-ws</pre> yazÄ±lÄ±r. Ve client\src\apollo.js dosyasÄ± aÅŸaÄŸÄ±daki ÅŸekilde dÃ¼zenlenir.
                  <pre class="prettyprint ms-0">
import { ApolloClient, InMemoryCache, split, HttpLink } from "@apollo/client";
import { WebSocketLink } from "@apollo/client/link/ws";
import { getMainDefinition } from "@apollo/client/utilities";

const wsLink = new WebSocketLink({
  uri: "ws://localhost:8080/v1/graphql",
  options: {
    reconnect: true
  }
})

const httpLink = new HttpLink({
  uri: "http://localhost:8080/v1/graphql"
})

const splitLink = split(
  ({query }) => {
    const defination = getMainDefinition(query)
    return defination.kind === 'OperationDefinition' && defination.operation === "subscription"
  },
  wsLink,
  httpLink
)

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

export default client;
                  </pre>
                </p>
                <p>
                  client\src\components\PostCounter\queries.js adresindeki postlarÄ± sayan subscriptionu hasuraya gÃ¶re gÃ¼ncelledik.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const POST_COUNT_SUBSCRIPTION = gql`
  subscription postCount {
    posts_aggregate {
      aggregate {
        count
      }
    }
  }
`;
                  </pre>
                  yeni veri yapÄ±sÄ±na uygun olarak subscriptiondan veri Ã§ekip client\src\components\PostCounter\index.js iÃ§inde kullandÄ±k.
                  <pre class="prettyprint ms-0">
import styles from "./styles.module.css";
import { Badge } from "antd";
import { useSubscription } from "@apollo/client";
import { POST_COUNT_SUBSCRIPTION } from "./queries";

function PostCounter() {
  const {loading, data} = useSubscription(POST_COUNT_SUBSCRIPTION);

  const postCount = data?.posts_aggregate?.aggregate?.count
  
  return (
    &lt;div className={styles.container}>
      &lt;Badge count={loading ? "?" : postCount }>
        &lt;span className={styles.counterTitle}>Post{loading ? "" : postCount > 1 && "s"}&lt;/span>
      &lt;/Badge>
    &lt;/div>
  );
}

export default PostCounter;

                  </pre>
                </p>
                <p>
                  Hasura iÃ§inde bÃ¼tÃ¼n postlarÄ± getiren ve deÄŸiÅŸikliÄŸini takip eden bir subscription var. Biz daha Ã¶nce query ile postlarÄ± Ã§ekip gÃ¼ncellemeyi subscription ile takip ediyorduk. Yeni halinde direk subscription kullandÄ±k. client\src\pages\Home\queries.js:
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const POSTS_SUBSCRIPTION = gql`
  subscription posts {
    posts(order_by: { id: desc }) {
      id
      title
      short_description
      user {
        profile_photo
      }
    }
  }
`;
                  </pre>
                  client\src\pages\Home\index.js
                  <pre class="prettyprint ms-0">
import { Avatar, List } from "antd";
import { useSubscription } from "@apollo/client";
import Loading from "components/Loading";
import { POSTS_SUBSCRIPTION } from "./queries";
import { Link } from "react-router-dom";
import styles from "./styles.module.css";

function Home() {
  const { loading, error, data } = useSubscription(POSTS_SUBSCRIPTION);

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;div>Error: {error.message}&lt;/div>;
  }
  return (
    &lt;div>
      &lt;List
        className="demo-loadmore-list"
        loading={false}
        itemLayout="horizontal"
        // loadMore={loadMore}
        dataSource={data.posts}
        renderItem={(item) => (
          &lt;List.Item key={item._id}>
            &lt;List.Item.Meta
              avatar={&lt;Avatar src={item.user.profile_photo} />}
              title={
                &lt;Link to={`/post/${item.id}`} className={styles.listTitle}>
                  {item.title}
                &lt;/Link>
              }
              description={
                &lt;Link to={`/post/${item.id}`} className={styles.listItem}>
                  {item.short_description}
                &lt;/Link>
              }
            />
          &lt;/List.Item>
        )}
      />
    &lt;/div>
  );
}

export default Home;

                  </pre>
                </p>
              </div>
              <div class="row" id="commentHasuraClient2">
                <h1>Client Entegrasyonu - 2</h1>
                <p>
                  client\src\pages\Post\queries.js dosyasÄ±nda tekil post detayÄ± veren sorgu gÃ¼ncellendi.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const GET_POST = gql`
  query post($id: Int!) {
    posts_by_pk(id: $id) {
      id
      title
      description
      cover
      user {
        id
        fullName
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\index.js dosyasÄ±nda gelen veriyi almak iÃ§in gereken dÃ¼zenleme yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import styles from "./styles.module.css";

import Loading from "components/Loading";
import { useParams } from "react-router-dom";
import { useQuery } from "@apollo/client";
import { GET_POST } from "./queries";
import { Typography, Image } from "antd";
import CommentsList from "./Comments/CommentsList";
const { Title } = Typography;

function Post() {
  const { id } = useParams();

  const { loading, error, data } = useQuery(GET_POST, {
    variables: {
      id,
    },
  });

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;div>Error: {error.message}&lt;/div>;
  }

  const { posts_by_pk: post } = data;

  return (
    &lt;div>
      &lt;Title level={3}>{post.title}&lt;/Title>
      &lt;Image src={post.cover} />
      &lt;div className={styles.description}>{post.description}&lt;/div>
      &lt;CommentsList post_id={id}/>
    &lt;/div>
  );
}

export default Post;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\Comments\queries.js dosyasÄ±nda commentleri listeleyen ve yeni comment oluÅŸturan sorgular dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const GET_USER = gql`
  query {
    users {
      fullName
      id
    }
  }
`;

export const CREATE_COMMENT_MUTATION = gql`
  mutation createComment($input: comments_insert_input!) {
    insert_comments_one(object: $input) {
      id
    }
  }
`;

export const COMMENTS_SUBSCRIPTION = gql`
  subscription getComment($post_id: Int!) {
    comments(where: { post_id: { _eq: $post_id } }) {
      id
      text
      user {
        fullName
        profile_photo
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\Comments\CommentsList.js dosyasÄ±nda listeleme iÃ§in gereken dÃ¼zenlemeler yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import Loading from "components/Loading";
import { Divider } from "antd";
import { useSubscription } from "@apollo/client";
import { COMMENTS_SUBSCRIPTION } from "./queries";
import { Avatar, List } from "antd";
import NewCommentForm from "./NewCommentForm";

function CommentsList({ post_id }) {
  const { data, error, loading } = useSubscription(COMMENTS_SUBSCRIPTION, {
    variables: {
      post_id,
    },
  });
  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;div>Error: {error.message}&lt;/div>;
  }

  return (
    &lt;>
      &lt;Divider>Comments&lt;/Divider>

      {!loading && data && (
        &lt;>
          &lt;List
            className="demo-loadmore-list"
            loading={false}
            itemLayout="horizontal"
            // loadMore={loadMore}
            dataSource={data.comments}
            renderItem={(item) => (
              &lt;List.Item key={item.id}>
                &lt;List.Item.Meta
                  avatar={&lt;Avatar src={item.user.profile_photo} />}
                  title={item.user.fullName}
                  description={item.text}
                />
              &lt;/List.Item>
            )}
          />
          &lt;Divider>New Comment&lt;/Divider>
          &lt;NewCommentForm post_id={post_id} />
        &lt;/>
      )}
    &lt;/>
  );
}

export default CommentsList;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\Comments\NewCommentForm.js dosyasÄ±nda yeni comment eklenmesi iÃ§in gereken dÃ¼zenlemeler yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import { useRef } from "react";
import { Button, Col, Form, Input, Row, Select, message } from "antd";
import { useQuery, useMutation } from "@apollo/client";
import { GET_USER, CREATE_COMMENT_MUTATION } from "./queries";
import styles from "./styles.module.css";

const { Option } = Select;

function NewCommentForm({ post_id }) {
  const [createComment, { loading }] = useMutation(CREATE_COMMENT_MUTATION);
  const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);

  const formRef = useRef(); // formu ilk haline getirmesi iÃ§in.

  const handleSubmit = async (values) => {
    try {
      await createComment({
        variables: {
          input: { ...values, post_id },
        },
      });
      message.success("Comment saved", [4]);

      formRef.current.resetFields(); // formu resetleyen fonksiyon
    } catch (e) {
      message.error(`Comment not saved!.`, [10]);
    }
  };

  return (
    &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off" ref={formRef}>
      {/* resetleme iÃ§in ref iÃ§inde formRef verildi */}
      &lt;Row gutter={24}>
        &lt;Col span={6}>
          &lt;Form.Item
            name="user_id"
            rules={[
              {
                required: true,
                message: "Please select user!",
              },
            ]}
          >
            &lt;Select
              disabled={get_users_loading || loading}
              loading={get_users_loading}
              size="medium"
              placeholder="Select your user"
            >
              {users_data &&
                users_data.users.map((item) => (
                  &lt;Option value={item.id} key={item.id}>
                    {item.fullName}
                  &lt;/Option>
                ))}
            &lt;/Select>
          &lt;/Form.Item>
        &lt;/Col>
        &lt;Col span={14}>
          &lt;Form.Item
            name="text"
            rules={[
              {
                required: true,
                message: "Please enter a message!",
              },
            ]}
          >
            &lt;Input disabled={loading} size="medium" placeholder="Message" />
          &lt;/Form.Item>
        &lt;/Col>
        &lt;Col span={4}>
          &lt;Form.Item className={styles.buttons}>
            &lt;Button
              disabled={loading}
              size="medium"
              type="primary"
              htmlType="submit"
            >
              Add
            &lt;/Button>
          &lt;/Form.Item>
        &lt;/Col>
      &lt;/Row>
    &lt;/Form>
  );
}

export default NewCommentForm;
                  </pre>
                </p>
              </div>
              <div class="row" id="commentHasuraClient3">
                <h1>Client Entegrasyonu - 3</h1>
                <p>
                  client\src\pages\NewPost\queries.js dosyasÄ±nda yeni post oluÅŸturan mutation gÃ¼ncellendi.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const GET_USER = gql`
  query {
    users {
      fullName
      id
    }
  }
`;

export const NEW_POST_MUTATION = gql`
  mutation createPost($data: posts_insert_input!) {
    insert_posts_one(object: $data) {
      id
      title
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\NewPost\NewPostForm.js dosyasÄ±nda gereken dÃ¼zenlemeler yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import React from "react";
import { Button, Form, Input, Select, message } from "antd";
import { useNavigate } from "react-router-dom";
import { useQuery, useMutation } from "@apollo/client";
import { GET_USER, NEW_POST_MUTATION } from "./queries";
import styles from "./styles.module.css";

const { Option } = Select;

function NewPostForm() {
  const navigate = useNavigate();

  const [
    savePost, // bizim mutation fonksiyonuna verdiÄŸimiz ad.
    { loading, error }, // iÅŸlem sonunda dÃ¶nen data
  ] = useMutation(NEW_POST_MUTATION);

  const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);

  const handleSubmit = async (values) => {
    try {
      await savePost({
        variables: {
          data: values,
        },
      });
      message.success("Post saved", [4]);
      navigate("/");
    } catch (e) {
      message.error(`Post not saved!. Error: ${error.message}`, [10]);
    }
  };

  return (
    &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off">
      &lt;Form.Item
        name="title" // bu kÄ±sÄ±m value tanÄ±mÄ±nda key olarak gÃ¶nderilir. mutation iÃ§indeki key ile aynÄ± olmak zorunda.
        rules={[
          {
            required: true,
            message: "Please input a title!",
          },
        ]}
      >
        &lt;Input disabled={loading} size="large" placeholder="Title" />
      &lt;/Form.Item>

      &lt;Form.Item name="short_description">
        &lt;Input
          disabled={loading}
          size="large"
          placeholder="Short description"
        />
      &lt;/Form.Item>

      &lt;Form.Item name="description">
        &lt;Input.TextArea
          disabled={loading}
          size="large"
          placeholder="Description"
        />
      &lt;/Form.Item>

      &lt;Form.Item name="cover">
        &lt;Input disabled={loading} size="large" placeholder="Cover" />
      &lt;/Form.Item>

      &lt;Form.Item
        name="user_id"
        rules={[
          {
            required: true,
            message: "Please select user!",
          },
        ]}
      >
        &lt;Select
          disabled={get_users_loading || loading}
          loading={get_users_loading}
          size="large"
          placeholder="Select your user"
        >
          {users_data &&
            users_data.users.map((item) => (
              &lt;Option value={item.id} key={item.id}>
                {item.fullName}
              &lt;/Option>
            ))}
        &lt;/Select>
      &lt;/Form.Item>

      &lt;Form.Item className={styles.buttons}>
        &lt;Button loading={loading} size="large" type="primary" htmlType="submit">
          Submit
        &lt;/Button>
      &lt;/Form.Item>
    &lt;/Form>
  );
}

export default NewPostForm;

                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="voting">
              <div class="row" id="votingHasuraBackend">
                <h1>Hasura Backend'in OluÅŸturulmasÄ±</h1>
                <p>
                  proje klasÃ¶rÃ¼ iÃ§inde terminale
                  <pre class="prettyprint ms-0">
mkdir backend
cd backend
curl https://raw.githubusercontent.com/hasura/graphql-engine/stable/install-manifests/docker-compose/docker-compose.yaml -o docker-compose.yml
hasura init
                  </pre>
                </p>
                <p>
                  backend\docker-compose.yml iÃ§inde "HASURA_GRAPHQL_ENABLE_CONSOLE": false yapÄ±ldÄ±. 
                </p>
                <p>
                  backend klasÃ¶rÃ¼ iÃ§inde "powershell" yÃ¶netici olarak aÃ§Ä±ldÄ± ve iÃ§ine <pre class="prettyprint ms-0">docker-compose up</pre> yazÄ±larak server ayaÄŸa kaldÄ±rÄ±ldÄ±.
                </p>
                <p>
                  backend\hasura konumunda terminale <pre class="prettyprint ms-0">hasura console</pre> yazÄ±lÄ±r. Hasura <a href="http://localhost:9695/">http://localhost:9695/</a> portunda aÃ§Ä±ldÄ±.
                </p>
                <p>
                  backend\docker-compose.yml iÃ§inde HASURA_GRAPHQL_METADATA_DATABASE_URL: keyine karÅŸÄ±lÄ±k gelen "postgres://postgres:postgrespassword@postgres:5432/postgres" urli DATA iÃ§inde database eklerken kullandÄ±k. AltÄ±na da 3 tane tablo aÃ§tÄ±k.
                  <ul>
                    <li>questions<ul>
                      <li>id: integer(auto-increment), primary key</li>
                      <li>title: text</li>
                    </ul></li>
                    <li>options<ul>
                      <li>id: integer(auto-increment), primary key</li>
                      <li>title: text</li>
                      <li>question_id: foreign key -> questions(table) -> id</li>
                    </ul></li>
                    <li>votes<ul>
                      <li>id: integer(auto-increment), primary key</li>
                      <li>option_id: foreign key -> options(table) -> id</li>
                    </ul></li>
                  </ul> 
                  
                </p>
                <p>
                  "Relationship" kÄ±smÄ±nda iliÅŸkiler belirtildi.
                </p>
              </div>
              <div class="row" id="votingApolloClientAndReactRouter">
                <h1>Apollo Client ve React Router Kurulumu</h1>
                <p>
                  Terminale
                  <pre class="prettyprint ms-0">
mkdir client
cd client
npx create-react-app .
                  </pre>
                  Kurulumun ardÄ±ndan terminale
                  <pre class="prettyprint ms-0">
npm install @apollo/client graphql
                  </pre> 
                  Kurulumun ardÄ±ndan terminale
                  <pre class="prettyprint ms-0">
npm i react-router-dom
                  </pre>
                </p>
                <p>
                  client\src\index.js iÃ§i aÅŸaÄŸÄ±daki gibi gÃ¼ncellendi.
                  <pre class="prettyprint ms-0">
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import { ApolloProvider } from "@apollo/client";
import client from "./apollo";

import { BrowserRouter as Router } from "react-router-dom";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  &lt;ApolloProvider client={client}>
    &lt;Router> 
      {/* Router sarmalamasÄ± App.js yerine burada yapÄ±ldÄ±.*/}
      &lt;App />
    &lt;/Router>
  &lt;/ApolloProvider>
);
                  </pre>
                  Hem "apollo client"in hem de "react router dom"un providerleri ile proje sarmalandÄ±.
                </p>
                <p>
                  "apollo provider"de kullanÄ±dÄŸÄ±mÄ±z ve bizim backende baÄŸlanmamÄ±zÄ± saÄŸlayan client tanÄ±mÄ± client\src\apollo.js dosyasÄ±nda oluÅŸturuldu.
                  <pre class="prettyprint ms-0">
import { ApolloClient, InMemoryCache, split, HttpLink } from "@apollo/client";
import { WebSocketLink } from "@apollo/client/link/ws";
import { getMainDefinition } from "@apollo/client/utilities";

const wsLink = new WebSocketLink({
  uri: "ws://localhost:8080/v1/graphql",
  options: {
    reconnect: true
  }
})

const httpLink = new HttpLink({
  uri: "http://localhost:8080/v1/graphql"
})

const splitLink = split(
  ({query }) => {
    const defination = getMainDefinition(query)
    return defination.kind === 'OperationDefinition' && defination.operation === "subscription"
  },
  wsLink,
  httpLink
)

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

export default client;
                  </pre>
                  Bu tanÄ±m iÃ§in gereken paketi yÃ¼klemek iÃ§in terminale
                  <pre class="prettyprint ms-0">
npm i subscriptions-transport-ws
                  </pre>
                </p>
                <p>
                  client\src\App.js iÃ§inde routing yapÄ±sÄ± kuruldu.
                  <pre class="prettyprint ms-0">
import { Routes, Route, Link } from "react-router-dom";
import Questions from "./pages/Questions";
import NewQuestion from "./pages/New";

function App() {
  return (
    &lt;div className="App">
      &lt;nav>
        &lt;Link to="/">Questions&lt;/Link>
        &lt;Link to="/new">New Question&lt;/Link>
      &lt;/nav>
      &lt;hr />
      &lt;Routes>
        &lt;Route path="/" element={&lt;Questions />} />
        &lt;Route path="/new" element={&lt;NewQuestion />} />
      &lt;/Routes>
    &lt;/div>
  );
}

export default App;
                  </pre>
                  Bu yapÄ±da kullanÄ±lan kompanentler yer tutucu olarak oluÅŸturuldu.
                </p>
                client\src\index.css iÃ§ine stil tanÄ±mlarÄ± yapÄ±ldÄ±.
                <pre class="prettyprint ms-0">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

.App {
  padding: 20px;
}

nav > a {
  padding: 0 10px 10px 0;
  color: #000;
  text-decoration: none;
}

nav > a:hover {
  text-decoration: underline;
}
                </pre>
              </div>
              <div class="row" id="votingRealTimeListing">
                <h1>OylamalarÄ±n GerÃ§ek ZamanlÄ± Listelenmesi</h1>
                <p>
                  SorularÄ± listeleyecek subscription hasurada belirlendi ve client\src\pages\Questions\queries.js dosyasÄ±nda yazÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const QUESTIONS_SUBSCRIPTION = gql`
  subscription {
    questions(order_by: { id: desc }) {
      id
      title
    }
  }
`;
                  </pre>
                </p>
                <p>
                  YazÄ±lan subscription client\src\pages\Questions\index.js dosyasÄ±nda kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import React from "react";
import { useSubscription } from "@apollo/client";
import { QUESTIONS_SUBSCRIPTION } from "./queries";
import Loading from "../../components/Loading";
import { Link } from "react-router-dom";

function Questions() {
  const { loading, data } = useSubscription(QUESTIONS_SUBSCRIPTION);

  if (loading) {
    return &lt;Loading />;
  }

  return (
    &lt;div>
      {data.questions.map((question) => (
        &lt;div key={question.id}>
          &lt;Link to={`/q/${question.id}`}>{question.title}&lt;/Link>
        &lt;/div>
      ))}
    &lt;/div>
  );
}

export default Questions;

                  </pre>
                </p>
                <p>
                  loading durumunda kullanÄ±lan kompanent client\src\components\Loading\index.js dosyasÄ±na yazÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
client\src\components\Loading\index.js
                  </pre>
                </p>
              </div>
              <div class="row" id="votingNewVoting1">
                <h1>Yeni Oylama OluÅŸturma EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 1</h1>
                <p>
                  client\src\pages\New\index.js iÃ§inde form tanÄ±mlarÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import { useState } from "react";

const initialOptions = [{ title: "" }, { title: "" }];

function NewQuestion() {
  const [title, setTitle] = useState();
  const [options, setOptions] = useState(initialOptions);

  const handleChangeOption = ({target}) => {
    const newArray = options;
    newArray[target.id].title = target.value

    setOptions([...newArray])
  }

  return (
    &lt;div>
      &lt;h2>Question&lt;/h2>
      &lt;input
        placeholder="Type your question..."
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />

      &lt;h2>Options&lt;/h2>
      {options.map((option, i) => (
        &lt;div key={i}>
          &lt;input
            placeholder="Type your option..."
            value={option.title}
            id={i}
            onChange={handleChangeOption}
          />
        &lt;/div>
      ))}
      &lt;button onClick={() => setOptions([...options, { title: "" }])}>
        New Option
      &lt;/button>

      &lt;button>Save&lt;/button>
    &lt;/div>
  );
}

export default NewQuestion;
                  </pre>
                </p>
                <p>
                  client\src\index.css iÃ§inde input ve button iÃ§in stil tanÄ±mÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
...
input{
  padding: 6px;
  font-size: 18px;
}

button{
  padding: 6px;
  margin-top: 10px;
}
                  </pre>
                </p>
              </div>
              <div class="row" id="votingNewVoting2">
                <h1>Yeni Oylama OluÅŸturma EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 2</h1>
                <p>
                  Hasura iÃ§inde yeni question ve options eklemek iÃ§in gereken mutation tanÄ±mlandÄ± ve client\src\pages\New\queries.js dosyasÄ±nda kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const NEW_QUESTION_MUTATION = gql`
  mutation newQuestion($input: questions_insert_input!) {
    insert_questions_one(object: $input) {
      id
      title
    }
  }
`;
                  </pre>
                </p>
                <p>
                  Ä°lgili mutation client\src\pages\New\index.js dosyasÄ±nda formdan gelen veriler ile kullanÄ±ldÄ±. 
                  <pre class="prettyprint ms-0">
import { useState } from "react";

import { useMutation } from "@apollo/client";
import { NEW_QUESTION_MUTATION } from "./queries";

const initialOptions = [{ title: "" }, { title: "" }];

function NewQuestion() {
  const [addQuestion, { loading }] = useMutation(NEW_QUESTION_MUTATION);

  const [title, setTitle] = useState();
  const [options, setOptions] = useState(initialOptions);

  const handleChangeOption = ({ target }) => {
    const newArray = options;
    newArray[target.id].title = target.value;

    setOptions([...newArray]);
  };

  const handleSave = () => {
    const filledOptions = options.filter((option) => option.title !== ""); // BoÅŸlarÄ± database e gÃ¶ndermemek iÃ§in optionlardan sadece title deÄŸeri olanlarÄ± filtreledi.

    if (title === null || filledOptions.length < 2) return false;

    addQuestion({
      variables: {
        input: {
          title,
          options: {
            data: filledOptions,
          },
        },
      },
    });

    setOptions(initialOptions);
    setTitle("");
  };

  return (
    &lt;div>
      &lt;h2>Question&lt;/h2>
      &lt;input
        placeholder="Type your question..."
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        disabled={loading}
      />

      &lt;h2>Options&lt;/h2>
      {options.map((option, i) => (
        &lt;div key={i}>
          &lt;input
            placeholder="Type your option..."
            value={option.title}
            id={i}
            onChange={handleChangeOption}
            disabled={loading}
          />
        &lt;/div>
      ))}
      &lt;button
        onClick={() => setOptions([...options, { title: "" }])}
        disabled={loading}
      >
        New Option
      &lt;/button>

      &lt;button onClick={handleSave} disabled={loading}>
        Save
      &lt;/button>
    &lt;/div>
  );
}

export default NewQuestion;

                  </pre>
                </p>
              </div>
              <div class="row" id="votingVotingDetail1">
                <h1>Oylama Detay EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 1</h1>
                <p>
                  client\src\App.js iÃ§inde route yapÄ±sÄ± dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
import { Routes, Route, Link } from "react-router-dom";
import Questions from "./pages/Questions";
import NewQuestion from "./pages/New";
import Detail from "./pages/Detail";

function App() {
  return (
    &lt;div className="App">
      &lt;nav>
        &lt;Link to="/">Questions&lt;/Link>
        &lt;Link to="/new">New Question&lt;/Link>
      &lt;/nav>
      &lt;hr />
      &lt;Routes>
        &lt;Route path="/" element={&lt;Questions />} />
        &lt;Route path="/new" element={&lt;NewQuestion />} />
        &lt;Route path="/q/:id" element={&lt;Detail />} />
      &lt;/Routes>
    &lt;/div>
  );
}

export default App;
                  </pre>
                </p>
                <p>
                  client\src\pages\Detail\queries.js iÃ§inde question detaylarÄ±nÄ± Ã§eken subscription ve yeni oy ekleyen mutation kullanÄ±ldÄ±. 
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const QUESTION_DETAIL_SUBSCRIPTION = gql`
  subscription questionDetail($id: Int!) {
    questions_by_pk(id: $id) {
      id
      title
      options {
        id
        title
        votes_aggregate {
          aggregate {
            count
          }
        }
      }
    }
  }
`;

export const NEW_VOTE_MUTATIONS = gql`
  mutation newVote($id: Int) {
    insert_votes_one(object: { option_id: $id }) {
      id
      option {
        title
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\Detail\index.js dosyasÄ±nda bu sorgular kullanÄ±ldÄ±. 
                  <pre class="prettyprint ms-0">
import { useState } from "react";
import { useParams } from "react-router-dom";
import { useMutation, useSubscription } from "@apollo/client";
import { NEW_VOTE_MUTATIONS, QUESTION_DETAIL_SUBSCRIPTION } from "./queries";
import Loading from "../../components/Loading";
import Error from "../../components/Error";

function Detail() {
  const { id } = useParams();

  const [selectedOptionId, setSelectedOptionId] = useState();

  const { data, loading, error } = useSubscription(
    QUESTION_DETAIL_SUBSCRIPTION,
    {
      variables: {
        id,
      },
    }
  );

  const [newVote, { loading: loadingVote }] = useMutation(NEW_VOTE_MUTATIONS);

  const handleClickVote = () => {
    newVote({
        variables: {
            id: selectedOptionId
        }
    })
  };

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;Error message={error.message} />;
  }

  const {
    questions_by_pk: { options, title },
  } = data;
  console.log(data.questions_by_pk);
  return (
    &lt;div>
      &lt;h2>{title}&lt;/h2>

      {options.map((option, i) => (
        &lt;label htmlFor={i} key={i}>
          &lt;input
            type="radio"
            name="selected"
            value={option.id}
            onChange={({ target }) => setSelectedOptionId(target.value)}
          />
          &lt;span>{option.title}&lt;/span>
        &lt;/label>
      ))}

      &lt;button disabled={loadingVote} onClick={handleClickVote}>Vote&lt;/button>
    &lt;/div>
  );
}

export default Detail;
                  </pre>
                </p>
                <p>
                  Error kompanenti client\src\components\Error\index.js dosyasÄ±nda oluÅŸturuldu. 
                  <pre class="prettyprint ms-0">
import React from 'react'

function Error({message}) {
  return (
    &lt;div>Error: {message}&lt;/div>
  )
}

export default Error
                  </pre>
                </p>
                <p>
                  client\src\index.css iÃ§ine label stil tanÄ±mÄ± eklendi. 
                  <pre class="prettyprint ms-0">
label{
  display: block;
  margin-bottom: 8px;
}
                  </pre>
                </p>
              </div>
              <div class="row" id="votingVotingDetail2">
                <h1>Oylama Detay EkranÄ±nÄ±n HazÄ±rlanmasÄ± - 2</h1>
                <p>
                  OylarÄ±n daÄŸÄ±lÄ±mÄ±nÄ± gÃ¶steren progress tagÄ±nÄ± kullandÄ±k. Oy verme durumunda butonu ortadan kaldÄ±rÄ±p gÃ¼ncel oy sayÄ±larÄ±nÄ± gÃ¶sterdik. 
                </p>
                <p>
                  client\src\pages\Detail\index.js dosyasÄ±nÄ±n son hali: 
                  <pre class="prettyprint ms-0">
import { useState } from "react";
import { useParams } from "react-router-dom";
import { useMutation, useSubscription } from "@apollo/client";
import { NEW_VOTE_MUTATIONS, QUESTION_DETAIL_SUBSCRIPTION } from "./queries";
import Loading from "../../components/Loading";
import Error from "../../components/Error";

function Detail() {
  const { id } = useParams();

  const [isVoted, setIsVoted] = useState(false);
  const [selectedOptionId, setSelectedOptionId] = useState();

  const { data, loading, error } = useSubscription(
    QUESTION_DETAIL_SUBSCRIPTION,
    {
      variables: {
        id,
      },
    }
  );

  const [newVote, { loading: loadingVote }] = useMutation(NEW_VOTE_MUTATIONS, {
    onCompleted: () => {
      // iÅŸlem tamamlandÄ±ÄŸÄ±nda
      setIsVoted(true); // bunu Ã§alÄ±ÅŸtÄ±r
    },
  });

  const handleClickVote = () => {
    newVote({
      variables: {
        id: selectedOptionId,
      },
    });
  };

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;Error message={error.message} />;
  }

  const {
    questions_by_pk: { options, title },
  } = data;

  const total = options.reduce(
    (t, value) => t + value.votes_aggregate.aggregate.count,
    0
  ); // 0 dan baÅŸlayarak tÃ¼m deÄŸerleri toplar

  return (
    &lt;div>
      &lt;h2>{title}&lt;/h2>

      {options.map((option, i) => (
        &lt;div key={i}>
          &lt;label htmlFor={i}>
            &lt;input
              type="radio"
              name="selected"
              id={i}
              value={option.id}
              onChange={({ target }) => setSelectedOptionId(target.value)}
            />
            &lt;span>{option.title}&lt;/span>
            {isVoted && (
              &lt;span className="vote_count">
                (%
                {(
                  (option.votes_aggregate.aggregate.count /
                    (total === 0 ? 1 : total)) *
                  100
                ).toFixed(2)}
                ){/* virgÃ¼lden sonra 2 karakter gÃ¶sterilmesini saÄŸlar. */}
              &lt;/span>
            )}
          &lt;/label>

          {isVoted && (
            &lt;div>
              &lt;progress
                value={option.votes_aggregate.aggregate.count}
                max={total}
              />
            &lt;/div>
          )}
        &lt;/div>
      ))}

      {!isVoted && (
        &lt;button disabled={loadingVote} onClick={handleClickVote}>
          Vote
        &lt;/button>
      )}
    &lt;/div>
  );
}

export default Detail;
                  </pre>
                </p>
                <p>
                  client\src\index.css dosyasÄ±nÄ±n son hali:
                  <pre class="prettyprint ms-0">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

.App {
  padding: 20px;
}

nav > a {
  padding: 0 10px 10px 0;
  color: #000;
  text-decoration: none;
}

nav > a:hover {
  text-decoration: underline;
}

input {
  padding: 6px;
  font-size: 18px;
}

button {
  padding: 6px;
  margin-top: 10px;
}

label {
  display: block;
  margin-bottom: 4px;
}

.vote_count {
  font-size: 16;
  margin-left: 4px;
}

progress {
  margin-bottom: 8px;
}
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="hasuraDeployment">
              <div class="row" id="hasuraDigitalOceanDeployment">
                <h1>Hasura DigitalOcean Deployment</h1>
                <p>
                  Docker'Ä±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± herhangi bir sunucuda hasura backendimiz de Ã§alÄ±ÅŸÄ±r. <a href="https://hasura.io/docs/latest/deployment/deployment-guides/index/">Bu dÃ¶kÃ¼mandan faydalandÄ±k.</a>
                </p>
                <p>
                  Biz <a href="https://www.digitalocean.com/">DigitalOcean</a> kullanacaÄŸÄ±z. DigitalOcean aws Ã¼zerinden bir makina aÃ§Ä±p kullanÄ±mÄ±za sunuyor. 
                </p>
                <p>
                  DigitalOcean'a kayÄ±t yapÄ±p giriÅŸ yapÄ±yoruz. "Create">"Create Droplets">"Ubuntu"
                </p>
                <p>
                  "Choose Region" da en yakÄ±n yeri seÃ§tik. DevamÄ±nda en ucuz makineyi seÃ§iyoruz. Formun devamÄ±nÄ± dolduruyoruz. Parola belirliyoruz vs. En son "Create" deyip sunucuyu oluÅŸturuyoruz. 
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">ssh root@&lt;host-id></pre> ile baÄŸlanÄ±yoruz. Host id digitalOcean iÃ§inden alÄ±yoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
sudo apt-get update
sudo apt-get install ca-certificates curl gnupg
apt install docker.io
apt install docker-compose
                  </pre>
                  ile gerekli olan ÅŸeyleri kuruyoruz. (detaylar docker dersinde)
                </p>
                <p>
                  <pre class="prettyprint ms-0">systemctl status docker</pre> dockerÄ±n Ã§alÄ±ÅŸma durumunu sorguluyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
cd /tmp
mkdir hasura
cd hasura
                  </pre>
                  ile temp iÃ§inde hasura klasÃ¶rÃ¼ oluÅŸturup iÃ§ine giriyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">curl https://raw.githubusercontent.com/hasura/graphql-engine/stable/install-manifests/docker-compose/docker-compose.yaml -o docker-compose.yml</pre>
                  ile hasurayÄ± ayaÄŸa kaldÄ±racak olan docker-compose.yml dosyasÄ±nÄ± indiriyoruz.
                </p> 
                <p>
                  <pre class="prettyprint ms-0">docker-compose up</pre> ile docker ayaÄŸa kaldÄ±rÄ±ldÄ±.
                </p>
                <p>
                  host-ip:8080 ile ayaÄŸa kalkan projenin konsoluna ulaÅŸabiliriz. Burada DATA alanÄ±nda docker-compose.yml iÃ§indeki endpoint ile makineye hasura kurulurken kurulan postgreSQL endpointini kullanarak database baÄŸlantÄ±sÄ±nÄ± saÄŸladÄ±k.
                </p>
                <p>
                  Proje dizinimizde terminale <pre class="prettyprint ms-0">cd backend/hasura</pre> yazarak migration tanÄ±mlarÄ±nÄ± olduÄŸu klasÃ¶re geldik. <pre class="prettyprint ms-0">hasura metadata apply --endpoint --adminsecret</pre> sintaxÄ±nda endpointten sonra kendi endpointimizi girdik. Bizde: <pre class="prettyprint ms-0">hasura metadata apply --endpoint http://134.122.78.209:8080</pre> admin secret olmadÄ±ÄŸÄ±ndan gÃ¶nderilmedi.
                </p>
                <p>
                  Ä°ÅŸlem tamamlanÄ±nca deploy edilen tarafÄ±n arayÃ¼zÃ¼nde bizi karÅŸÄ±layan ekranda "reload metadata" diyoruz.
                </p>
                <p>
                  TablolarÄ±mÄ±z geldi. Åimdi de migration iÅŸlemini yapacaÄŸÄ±z.
                </p>
                <p>
                  <pre class="prettyprint ms-0">hasura migrate apply --endpoint --adminsecret</pre> sintaxÄ±nda endpointten sonra kendi endpointimizi girdik. Bizde: <pre class="prettyprint ms-0">hasura migrate apply --endpoint http://134.122.78.209:8080</pre> admin secret olmadÄ±ÄŸÄ±ndan gÃ¶nderilmedi.
                </p>
                <p>
                  Ä°ÅŸlem tamamlanÄ±nca deploy edilen tarafÄ±n arayÃ¼zÃ¼nde bizi karÅŸÄ±layan ekranda "Reload all databases" i seÃ§ip "reload metadata" diyoruz.
                </p>
              </div>
              <div class="row" id="reactClientNetlifyDeployment">
                <h1>React Client Netlify Deployment</h1>
                <p>
                  Netlfy kayÄ±t ol ve giriÅŸ yap. Git repomuzu kaydettik.
                </p>
                <p>
                  Client bir git reposuna alÄ±ndÄ±.
                </p>
                <p>
                  Netlify>new site> ilgili repo seÃ§ilir. Form kontrol edilir ve deploy tÄ±klanÄ±r.
                </p>
                <p>
                  client\src\apollo.js iÃ§inde hala local endpointlerimiz var. BunlarÄ± deploy ettiÄŸimiz hasuranÄ±n endpointi ile gÃ¼ncelliyoruz. Tekrar git push yapÄ±yoruz ki deÄŸiÅŸiklikler netlifyde uygulansÄ±n.
                </p>
                <p>
                  hasura docker-compose ile yÃ¼klendiÄŸinde https/wss yapÄ±sÄ±nÄ± desteklemiyor. Bu nedenle de websoket tarafÄ±nda sorun yaÅŸÄ±yoruz. Bu kÄ±smÄ± daha sonra tekrar zorlarÄ±z.

                </p>
                <p>
                  KÃ¶k dizin dÄ±ÅŸÄ±ndan aÃ§ma ve sayfa yenileme iÅŸlemlerinde sorun yaÅŸamamak iÃ§in client\public\_redirects dosyasÄ± oluÅŸturuldu ve iÃ§ine <pre class="prettyprint ms-0">/*    /index.html   200</pre> yazÄ±ldÄ±.
                </p>
              </div>
            </div>
            <div class="row" id="hasuraMeetingApp">
              <div class="row" id="hasuraMeetingDb">
                <h1>Hasura Kurulumu ve DB YapÄ±sÄ±nÄ±n OluÅŸturulmasÄ±</h1>
                <p>
                  ToplantÄ± planlama uygulamasÄ±. GÃ¶rÃ¼ÅŸmeye birileri davet edilebilecek. Kabul edenlere son 1 saat kala yeni bir mail gelecek.
                </p>
                <p>
                  Hoca docker ile lokal kurup ilerliyor. Biz hasura cloud ile ilerleyeceÄŸiz. Ã‡Ã¼nkÃ¼ daha sonra digitalocean ile deploy etmeye Ã§alÄ±ÅŸÄ±nca hata alÄ±yoruz.
                </p>
                <p>
                  hasura cloud Ã¼zerinde yeni bir server oluÅŸturduk. DB olarak postgreSQL baÄŸladÄ±k.
                </p>
                <p>
                  users adÄ±nda bir tablo oluÅŸturduk.
                  <ol>
                    <li><b>id:</b> integer, primary key, unique, default: nextval('users_id_seq'::regclass)</li>
                    <li><b>email:</b>text, unique</li>
                    <li><b>name:</b> text</li>
                    <li><b>surname:</b> text</li>
                    <li><b>password:</b> text</li>
                  </ol>
                </p>
                <p>
                  meetings adÄ±nda bir tablo oluÅŸturduk.
                  <ol>
                    <li><b>id:</b> integer, primary key, unique, default: nextval('meetings_id_seq'::regclass)</li>
                    <li><b>title:</b> text</li>
                    <li><b>meeting_date:</b> date</li>
                    <li><b>created_at:</b> timestamp with time zone, default: now()</li>
                    <li><b>updated_at:</b> timestamp with time zone, default: now()</li>
                    <li><b>user_id:</b>integer, foreign key(user_id â†’ users.id) On Delete Violation: cascade</li>
                  </ol>
                  Bu tabloda relationship kÄ±smÄ±nda user adÄ±nda object tipinde bir iliÅŸki kuruldu. users tablosunda da meetings adÄ±nda array tipinde bir iliÅŸki kuruldu.
                </p>
                <p>
                  participants adÄ±nda bir tablo oluÅŸturduk.
                  <ol>
                    <li><b>id: </b>integer, primary key, unique, default: nextval('participants_id_seq'::regclass)</li>
                    <li><b>user_id:</b> integer, foreign key (user_id â†’ users . id) On Delete Violation: cascade</li>
                    <li><b>meeting_id:</b> integer, foreign key (meeting_id â†’ meetings . id ) On Delete Violation: cascade</li>
                  </ol>
                  Bu tabloda relationship kÄ±smÄ±nda user ve meeting adÄ±nda object tipinde iki iliÅŸki kuruldu. meeting tablosunda participants adÄ±nda array tipinde bir iliÅŸki kuruldu. Users tablosunda iliÅŸki kurulmadÄ±.
                </p>
                <p>
                  Ã–rnek veriler girildi ve test edildi.
                </p>
              </div>
              <div class="row" id="hasuraExpressBackend">
                <h1>Express Backending HazÄ±rlanmasÄ±</h1>
                <p>
                  Login, register vs iÃ§in kullanÄ±lacak backendi hazÄ±rlayacaÄŸÄ±z.
                </p>
                <p>
                  proje dosyasÄ±nda terminale
                  <pre class="prettyprint ms-0">
cd backend
npm init -y
                  </pre>
                  ile npm baÅŸlatÄ±ldÄ±.
                </p>
                <p>
                  <pre class="prettyprint ms-0">npm i express</pre> ile express indirildi. <pre class="prettyprint ms-0">npm i --save-d nodemon</pre> ile nodemon dev dependencies olarak kuruldu.
                </p>
                <p>
                  backend\src\app.js
                  <pre class="prettyprint ms-0">
const express = require("express");
const app = express();
const port = process.env.PORT || 3001;

app.use(express.json());

app.post("/register", (req, res) => {
  const input = req.body.input.data;
  console.log(input);

  res.json({
    accessToken: "accessToken",
  });
});

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));
                  </pre>
                </p>
                <p>
                  backend\package.json script alanÄ±na nodemon eklendi (gerÃ§i Ã§ok da iÅŸimize yaramadÄ±.)
                  <pre class="prettyprint ms-0">
"scripts": {
    "dev": "nodemon ./src/app.js"
  },
                  </pre>
                </p>
                <p>
                  Hasura cloud Ã¼zerinden action>create>new action
                </p>
                <p>
                  Action Definition
                  <pre class="prettyprint ms-0">
type Mutation {
  register (data: RegisterInput!): RegisterOutput
}
                  </pre>
                  Type Configuration
                  <pre class="prettyprint ms-0">
type RegisterOutput {
  accessToken: String!
}

input RegisterInput {
  email: String!
  password: String!
}
                  </pre>
                </p>
                <p>
                  hoca new action iÃ§in webhook iÅŸlemini lokalde docker-compose Ã¼zerinden env olarak yapÄ±yor. Biz online serverda Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zdan backendimizi de deta.space ile online'a aldÄ±k. <br>
                  Webhook (HTTP/S) Handler: https://backend-1-m7357908.deta.app/register
                </p>
                <p>
                  Online'a almak iÃ§in backend\Spacefile 
                  <pre class="prettyprint ms-0">
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: backend
    src: ./
    engine: nodejs16
    primary: true
    run: node ./src/app.js
    public: true
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraSucraseHasuraClientRoutingErrorHandling">
                <h1>hasuraSucraseHasuraClientRoutingErrorHandling</h1>
                <p>
                  YapÄ±mÄ±zda EC6 kullanabilmek iÃ§in sucrase isimli bir araÃ§ kullanacaÄŸÄ±z. Sucrase bir babel alternatifi. Terminale <pre class="prettyprint ms-0">npm i sucrase</pre> yazÄ±larak kuruldu.
                </p>
                <p>
                  artÄ±k app.js iÃ§inde EC6 sÃ¶z dizimini kullanabilriz.
                  <pre class="prettyprint ms-0">
import express from "express";
const app = express();
const port = process.env.PORT || 3001;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.post("/register", (req, res) => {
  const input = req.body.input.data;
  console.log(input);

  res.json({
    accessToken: "accessToken",
  });
});

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));
                  </pre>
                </p>
                <p>
                  nodemon kullanÄ±lÄ±rken de sucrase nin Ã§alÄ±ÅŸmasÄ± iÃ§in backend\nodemon.json dosyasÄ± oluÅŸturuldu ve iÃ§ine
                  <pre class="prettyprint ms-0">
{
    "execMap": {
        "js": "node -r sucrase/register"
    }
}
                  </pre>
                  yazÄ±ldÄ±.
                </p>
                <p>
                  backend\package.json dosyasÄ±nda scripts alanÄ± dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
"scripts": {
    "dev": "nodemon ./src/app.js",
    "build": "sucrase ./src -d ./dist --transforms imports"
  },
                  </pre>
                  terminale <pre class="prettyprint ms-0">npm run build</pre> yazÄ±larak build alÄ±ndÄ±. AlÄ±nan buildi bir tÃ¼rlÃ¼ deta.space iÃ§ine dahil edemeyince ben de kopyalayÄ±p test adlÄ± bir klasÃ¶re koydum. Buna baÄŸlÄ± olarak da backend\Spacefile dosyasÄ± gÃ¼ncellendi.
                  <pre class="prettyprint ms-0">
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: backend
    src: ./
    engine: nodejs16
    primary: true
    public: true
    run: node test/app.js
                  </pre>
                </p>
                <p>
                  route tanÄ±mlarÄ±nÄ± app.js iÃ§inden ayrÄ± bir yere taÅŸÄ±dÄ±k. Bunun iÃ§in backend\src\routes\auth\index.js dosyasÄ± oluÅŸturduk ve iÃ§ine
                  <pre class="prettyprint ms-0">
import express from "express";
const router = express.Router();

router.post("/register", (req, res) => {
  const input = req.body.input.data;
  res.json({ accessToken: "accessToken" });
});

export default router;
                  </pre>
                  yazdÄ±k. Bu routerÄ± backend\src\app.js iÃ§inde import edip kullandÄ±k.
                  <pre class="prettyprint ms-0">
import express from "express";
const app = express();

import auth from "./routes/auth";

const port = process.env.PORT || 3001;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.use("/auth", auth);

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));
                  </pre>
                </p>
                <p>
                  Bu hali ile hasura cloud Ã¼zerindeki action endpointimiz kÃ¶kdizin/register -> kÃ¶kdizin/auth/register haline geldi. Bu gÃ¼ncellemeyi de hasura claud Ã¼zerinde yaptÄ±k.
                </p>
                <p>
                  package.json Ã¼zerindeki dist tanÄ±mÄ±nÄ± da test ile deÄŸiÅŸtirdik ki buildler bizim oluÅŸturduÄŸumuz test klasÃ¶rÃ¼ne gelsin :D
                  <pre class="prettyprint ms-0">
"scripts": {
    "dev": "nodemon ./src/app.js",
    "build": "sucrase ./src -d ./test --transforms imports"
  },
                  </pre>
                </p>
                <p>
                  Hasuraya baÄŸlanabilmek iÃ§in terminale <pre class="prettyprint ms-0">npm i graphql-request</pre> yazarak gerekli kÃ¼tÃ¼phaneyi kurduk.
                </p>
                <p>
                  backend\src\clients\hasura.js dosyasÄ±nÄ± oluÅŸturup hasura baÄŸlantÄ±sÄ±nÄ± saÄŸladÄ±k.
                  <pre class="prettyprint ms-0">
import { GraphQLClient } from "graphql-request";

const headers = {
  "Content-Type": "application/json",
  "x-hasura-admin-secret": "test1234",
};

export default new GraphQLClient(
  "https://meeting-app-server.hasura.app/v1/graphql",
  {
    headers,
  }
);

                  </pre>
                </p>
                <p>
                  Hata olduÄŸunda onu gÃ¶ndermek iÃ§in bir kÃ¼tÃ¼phane kurduk. <pre class="prettyprint ms-0">npm i boom</pre>
                </p>
                <p>
                  backend\src\app.js Ã¼zerinde error catching tanÄ±mlarÄ±nÄ± girdik.
                  <pre class="prettyprint ms-0">
import express from "express";
import Boom from "boom";
import auth from "./routes/auth";

const app = express();

const port = process.env.PORT || 3001;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.use("/auth", auth);

//route tanÄ±mÄ± olmayan bir sayfaya istek yapÄ±ldÄ±ÄŸÄ±nda:
app.use((req, res, next) => {
  return next(Boom.notFound("Not Found"));
});

//hata gÃ¶nderildiÄŸinde:
app.use((err, req, res, next) => {
  if (err) {
    if (err.output) {
      return res.status(err.output.statusCode || 500).json(err.output.payload);
    }
  }

  return res.status(500).json(err);
});

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));

                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\index.js iÃ§inde ilk validasyon iÅŸlemimizi tanÄ±mladÄ±k.
                  <pre class="prettyprint ms-0">
import Boom from "boom";
import express from "express";
const router = express.Router();

router.post("/register", (req, res, next) => {
  const input = req.body.input.data;

  if (!input.email || !input.password) {
    return next(Boom.badRequest("Email and Password are requared!"));
  }
  res.json({ accessToken: "accessToken" });
});

export default router;
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraUserRegisterRoute">
                <h1>User Register Route</h1>
                <p>
                  <pre class="prettyprint ms-0">npm i graphql</pre>
                </p>
                <p>
                  hasura cloud Ã¼zerinde action>register>Type Configuration alanÄ± name ve surname almasÄ± iÃ§in aÅŸaÄŸÄ±daki gibi dÃ¼zenlendi.
                  <pre class="prettyprint ms-0">
input RegisterInput {
  email: String!
  name: String!
  surname: String!
  password: String!
}

type RegisterOutput {
  accessToken: String!
}
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\queries.js altÄ±nda gerekli sorgular yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
// KullanÄ±cÄ±nÄ±n varlÄ±ÄŸÄ±nÄ± sorgulayan query
export const IS_EXIST_USER = `
  query isExist($email: String!) {
    users(where: {email: {_eq: $email}}) {
      id
    }
  }
`;

// KullanÄ±cÄ± ekleyen mutation
export const INSERT_USER_MUTATION = `
  mutation insertUser ($input: users_insert_input!){
    insert_users_one(object: $input) {
      id
      name
    }
  }
`;
                  </pre>
                  Bu sorgular backend\src\routes\auth\index.js iÃ§inde kullanÄ±lacak.
                </p>
                <p>
                  Validasyon iÃ§in <pre class="prettyprint ms-0">npm install joi</pre> kuruldu
                </p>
                <p>
                  backend\src\routes\auth\validations.js iÃ§inde validasyon tanÄ±mlarÄ± yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import Joi from "joi";

export const registerSchema = Joi.object({
  email: Joi.string().email().required(),
  name: Joi.string().min(1).max(60).required(),
  surname: Joi.string().min(1).max(60).required(),
  password: Joi.string().min(6).max(60).required(),
});
                  </pre>
                  Bu tanÄ±m backend\src\routes\auth\index.js iÃ§inde kullanÄ±lacak.
                </p>
                <p>
                  ParolalarÄ± ÅŸifrelemek iÃ§in: <pre class="prettyprint ms-0">npm i bcryptjs</pre> kuruldu.
                </p>
                <p>
                  backend\src\routes\auth\index.js
                  <pre class="prettyprint ms-0">
import express from "express";
import Boom from "boom";
import bcrypt from "bcryptjs";
import Hasura from "../../clients/hasura";
import { IS_EXIST_USER, INSERT_USER_MUTATION } from "./queries";
import { registerSchema } from "./validations";

const router = express.Router();

router.post("/register", async (req, res, next) => {
  const input = req.body.input.data;

  input.email = input.email.toLowerCase();

  // validasyon iÅŸlemi
  const { error } = registerSchema.validate(input);
  if (error) {
    return next(Boom.badRequest(error.details[0].message));
  }

  try {
    const isExistUser = await Hasura.request(IS_EXIST_USER, {
      email: input.email,
    });

    // user zaten varsa hata ver
    if (isExistUser.users.length > 0) {
      throw Boom.conflict(`user already exist (${input.email})`);
    }

    // Parola ÅŸifreleme iÅŸlemi
    const salt = await bcrypt.genSalt(10);
    const hash = await bcrypt.hash(input.password, salt); // ÅŸifrelenmiÅŸ parola

    // user yoksa user oluÅŸtur
    const user = await Hasura.request(INSERT_USER_MUTATION, {
      input: {
        ...input,
        password: hash,
      },
    });

    res.json({ accessToken: "accessToken" });
  } catch (err) {
    return next(Boom.badRequest(err));
  }
});

export default router;
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraJWTAuthRegister">
                <h1>Hasura JWT Authentication (Register)</h1>
                <p>
                  accessToken ile auth iÅŸlemleri
                </p>
                <p>
                  Ã–ncelikle product ortamÄ±nda gÃ¶rÃ¼nmesini istemediÄŸimiz "HASURA_ADMIN_SECRET" ve bu uygulamada accessToken Ã¼retmek iÃ§in kullanacaÄŸÄ±mÄ±z "JWT_ACCESS_TOKEN_SECRET" key/value Ã§iftlerini backend\.env dosyasÄ±na taÅŸÄ±dÄ±k.
                  <pre class="prettyprint ms-0">
JWT_ACCESS_TOKEN_SECRET=b***4
HASURA_ADMIN_SECRET=t***4
                  </pre>
                  BunlarÄ±n bizim deta.space uygulamamÄ±zda da Ã§alÄ±ÅŸmasÄ± iÃ§in Spacefile dosyasÄ±nÄ± gÃ¼ncelledik.
                  <pre class="prettyprint ms-0">
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: backend
    src: ./
    engine: nodejs16
    primary: true
    public: true
    run: node test/app.js
    presets:
      env:
        - name: JWT_ACCESS_TOKEN_SECRET
          description: JWT access token iÃ§in secret
          default: "b***4"
        - name: HASURA_ADMIN_SECRET
          description: hasura admin secret
          default: "t***4"
                  </pre>
                </p>
                <p>
                  .env dosyasÄ±nÄ±n okunabilmesi iÃ§in <pre class="prettyprint ms-0">npm i dotenv</pre> ile ilgili paket kuruldu. backend\src\app.js iÃ§inde Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
...
import dotenv from "dotenv";

...

dotenv.config();
...
                  </pre>
                  backend\src\clients\hasura.js iÃ§inde de aynÄ± iÅŸlem tekrarlandÄ±.
                  <pre class="prettyprint ms-0">
import { GraphQLClient } from "graphql-request";
import dotenv from "dotenv";

dotenv.config();

const headers = {
  "Content-Type": "application/json",
  "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
};

export default new GraphQLClient(
  "https://meeting-app-server.hasura.app/v1/graphql",
  {
    headers,
  }
);
                  </pre>
                </p>
                <p>
                  accessToken Ã¼retmek iÃ§in <pre class="prettyprint ms-0">npm i jsonwebtoken</pre> ile ilgili paket yÃ¼klendi. backend\src\routes\auth\helpers.js iÃ§ine
                  <pre class="prettyprint ms-0">
import JWT from "jsonwebtoken";
import Boom from "boom";

export const singAccessToken = (user) => {
  return new Promise((resolve, reject) => {
    const payload = {
      "https://hasura.io/jwt/claims": {
        // hasurada kullanabilmemiz iÃ§in gereken tanÄ±mlar.
        "x-hasura-allowed-roles": ["user"],
        "x-hasura-default-role": "user",
        "x-hasura-user-id": user.id.toString(),
      },
      email: user.email,
    };

    const options = {
      expiresIn: "100d", // ne kadar sÃ¼re iÃ§in geÃ§erli
      issuer: "graphql-egitimi", // tokenÄ± kim vermiÅŸ
      audience: user.id.toString(), // token kime verilmiÅŸ
    };

    JWT.sign(
      payload,
      process.env.JWT_ACCESS_TOKEN_SECRET,
      options,
      (err, token) => {
        if (err) {
          return reject(Boom.internal("JWT sing error"));
        }
        resolve(token);
      }
    ); // ilk parametre payload, ikinci parametre access token secret, Ã¼Ã§Ã¼ncÃ¼ parametre options, dÃ¶rdÃ¼ncÃ¼ parametre callback fonksiyon
  });
};
                  </pre>
                </p>
                <p>
                  user tanÄ±mÄ± iÃ§inde email olmasÄ± iÃ§in backend\src\routes\auth\queries.js iÃ§inde gerekli gÃ¼ncelleme yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
// KullanÄ±cÄ±nÄ±n varlÄ±ÄŸÄ±nÄ± sorgulayan query
export const IS_EXIST_USER = `
  query isExist($email: String!) {
    users(where: {email: {_eq: $email}}) {
      id
    }
  }
`;

// KullanÄ±cÄ± ekleyen mutation
export const INSERT_USER_MUTATION = `
  mutation insertUser ($input: users_insert_input!){
    insert_users_one(object: $input) {
      id
      email
    }
  }
`;
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\helpers.js iÃ§inde Ã¼rettiÄŸimiz accessToken Ã¼retme fonksiyonu backend\src\routes\auth\index.js iÃ§inde import edilip kullanÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
import express from "express";
import Boom from "boom";
import bcrypt from "bcryptjs";
import { singAccessToken } from "./helpers"; // accessToken iÃ§in import edildi.

import Hasura from "../../clients/hasura";
import { IS_EXIST_USER, INSERT_USER_MUTATION } from "./queries";
import { registerSchema } from "./validations";

const router = express.Router();

router.post("/register", async (req, res, next) => {
  const input = req.body.input.data;

  input.email = input.email.toLowerCase();

  // validasyon iÅŸlemi
  const { error } = registerSchema.validate(input);
  if (error) {
    return next(Boom.badRequest(error.details[0].message));
  }

  try {
    const isExistUser = await Hasura.request(IS_EXIST_USER, {
      email: input.email,
    });

    // user zaten varsa hata ver
    if (isExistUser.users.length > 0) {
      throw Boom.conflict(`user already exist (${input.email})`);
    }

    // Parola ÅŸifreleme iÅŸlemi
    const salt = await bcrypt.genSalt(10);
    const hash = await bcrypt.hash(input.password, salt); // ÅŸifrelenmiÅŸ parola

    // user yoksa user oluÅŸtur
    const { insert_users_one: user } = await Hasura.request(
      INSERT_USER_MUTATION,
      {
        input: {
          ...input,
          password: hash,
        },
      }
    );

    const accessToken = await singAccessToken(user); // accessToken Ã¼retildi.

    res.json({ accessToken });
  } catch (err) {
    return next(Boom.badRequest(err));
  }
});

export default router;
                  </pre>
                </p>
                <p>
                  <a href="https://jwt.io/">jwt.io</a> sitesinde aldÄ±ÄŸÄ±mÄ±z accesstoken iÃ§inde neyi barÄ±ndÄ±rÄ±yor gÃ¶rebiliriz.
                </p>
                <p>
                  Hasura cloudun accessToken'Ä± tanÄ±masÄ± iÃ§in https://cloud.hasura.io/project iÃ§inde projemize girip "Env vars" alanÄ±na "HASURA_GRAPHQL_JWT_SECRET" adÄ±nda <pre class="prettyprint ms-0">{"key":"buraya_secret_key_yazÄ±yoruz_1234","type":"HS256"}</pre> tanÄ±mÄ±nda bir girdi eklenir. "key" karÅŸÄ±sÄ±na bizim belirlediÄŸimiz "JWT_ACCESS_TOKEN_SECRET" deÄŸeri girildi.
                  AynÄ± alana yetkisiz kullanÄ±cÄ± tanÄ±mÄ± iÃ§in: "HASURA_GRAPHQL_UNAUTHORIZED_ROLE" adÄ±nda <pre class="prettyprint ms-0">anonymous</pre> deÄŸeri girildi
                </p>
                <p>
                  hasura cloud console alanÄ±nda "DATA">users>"Permissions" alanÄ±nda user ve anonymous tanÄ±marÄ± eklendi.
                </p>
                <p>
                  hasura cloud console alanÄ±nda "Request Headers" alanÄ±na "key": "Authorization", "value": "Bearer &lt;acessToken>" yazÄ±lÄ±r ve "x-hasura-admin-secret" tiki kaldÄ±rÄ±lÄ±rsa sadece "user" iÃ§in verilen yetkiyle yapÄ±lacak iÅŸlemler gÃ¶rÃ¼nÃ¼r. DiÄŸer iÅŸlemlere izin vermez.
                </p>
              </div>
              <div class="row" id="hasuraJWTAuthLogin">
                <h1>Hasura JWT Authentication (Login)</h1>
                <p>
                  Login iÃ§in gereken action oluÅŸturulacak.
                </p>
                <p>
                  Hasura Cloud Console > "ACTIONS" > "Create"
                </p>
                <p>
                  Action Definition
                  <pre class="prettyprint ms-0">
type Mutation {
  # Define your action here
  login (data: LoginInput!): LoginOutput!
}
                  </pre>
                  Type Configuration
                  <pre class="prettyprint ms-0">
type LoginOutput {
  accessToken: String!
}

input LoginInput {
  email: String!
  password: String!
}
                  </pre>
                  "Webhook (HTTP/S) Handler": https://backend-1-m7357908.deta.app/auth/login <br>
                  "Forward client headers to webhook" seÃ§ildi. ve "Create Action" tÄ±klandÄ±.
                </p>
                <p>
                  "Actions" > "login" > "Permissions" alanÄ±nda "anonymous" iÃ§in yrtki verildi. "user" bu yetkiye sahip deÄŸil. AynÄ± iÅŸlem register iÃ§in de tekrarlandÄ±.
                </p>
                <p>
                  backend\src\routes\auth\queries.js dosyasÄ±na login iÃ§in gereken query eklendi. 
                  <pre class="prettyprint ms-0">
...
export const LOGIN_QUERY = `
  query login($email: String!) {
    users(
      where: {
        email: {
          _eq: $email
        }
      }
      limit: 1
    ){
      id
      email
      password
    }
  }
`;
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\validations.js dosyasÄ±na login validasyonu eklendi.
                  <pre class="prettyprint ms-0">
...
export const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(6).max(60).required(),
});
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\index.js iÃ§ine login iÅŸlemi tanÄ±mlandÄ±.
                  <pre class="prettyprint ms-0">
...
router.post("/login", async (req, res, next) => {
  const input = req.body.input.data;
  input.email = input.email.toLowerCase();

  const { error } = loginSchema.validate(input);
  if (error) {
    return next(Boom.badRequest(error.details[0].message));
  }

  try {
    const { users } = await Hasura.request(LOGIN_QUERY, {
      email: input.email,
    });

    if (users.length === 0) {
      throw Boom.unauthorized("Email or password is incorrect");
    }

    const user = users[0];

    const isMatch = await bcrypt.compare(input.password, user.password);

    if (!isMatch) {
      throw Boom.unauthorized("Email or password is incorrect");
    }

    const accessToken = await singAccessToken(user);
    return res.json({ accessToken });
  } catch (err) {
    return next(err);
  }
});
...
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraMeQuery">
                <h1>Me Query</h1>
                <p>
                  accessToken Ã¼zerinden kullanÄ±cÄ±yÄ± bulacaÄŸÄ±z.
                </p>
                <p>
                  Hasura Cloud Console alanÄ±da "Actions" > "Create" <br>
                  Action Definition
                  <pre class="prettyprint ms-0">
type Query {
  me: MeOutput
}
                  </pre>
                  Type Configuration
                  <pre class="prettyprint ms-0">
type MeOutput {
  user_id: String!
}
                  </pre>
                  "Webhook (HTTP/S) Handler": https://backend-1-m7357908.deta.app/auth/me <br>
                  "Forward client headers to webhook" seÃ§ildi. ve "Create Action" tÄ±klandÄ±.
                </p>
                <p>
                  Permission alanÄ±nda "user" rolÃ¼ne yetki verildi.
                </p>
                <p>
                  backend\src\routes\auth\helpers.js iÃ§inde token verfy iÅŸlemi iÃ§in fonksiyon yazÄ±ldÄ±. 
                  <pre class="prettyprint ms-0">
...

export const verifyAccessToken = (req, res, next) => {
  const authHeader = req.headers.authorization || req.query.token?.toString();

  if (!authHeader) {
    return next(Boom.unauthorized("No token provided"));
  }

  const bearerToken = authHeader.split(" ");
  const token = bearerToken[bearerToken.length - 1];

  JWT.verify(token, process.env.JWT_ACCESS_TOKEN_SECRET, (err, decoded) => {
    if (err) {
      const message =
        err.name === "JsonWebTokenError" ? "Unouthorized" : err.message;
      return next(Boom.unauthorized(message));
    }
    req.payload = decoded;
    req.token = token;
    next();
  });
};
                  </pre>
                </p>
                <p>
                  Bu fonksiyon backend\src\routes\auth\index.js iÃ§inde import edildi ve "/me" route'u iÃ§inde kullanÄ±ldÄ±. "/me" route'u ve verifyAccessToken fonksiyonu kullanÄ±larak header ile gelen accessToken'Ä±n ait olduÄŸu id dÃ¶nÃ¼ldÃ¼.
                  <pre class="prettyprint ms-0">
...

router.post("/me", verifyAccessToken, async (req, res, next) => {
  const { aud } = req.payload;

  return res.json({
    user_id: aud,
  });
});
...
                  </pre>
                </p>
                <p>
                  "Actions" > "me" > "Relationship" > "Add a relationship"
                </p>
                <p>
                  Gelen formda user_id ile user tablosundaki id eÅŸleÅŸtirildi. Bu sayede me ile elde ettiÄŸimiz user_id ile userÄ±n izin verilen tÃ¼m bilgilerine ulaÅŸabildik.
                </p>
              </div>
              <div class="row" id="hasuraPermissions">
                <h1>hasuraPermissions</h1>
                <p>
                  Ã–nce meeting ile gÃ¶rmek istediÄŸimiz veri iÃ§in bir sorgu yazÄ±yoruz. Ä°zinleri bunun Ã¼zerinden kurgulayacaÄŸÄ±z.
                  <pre class="prettyprint ms-0">
query MyQuery {
  meetings{
    id
    title
    user{
      id
      name
      surname
    }
    participants{
      user{
        id
        name
        surname
      }
    }
  }
}
                  </pre>
                </p>
                <p>
                  "DATA" altÄ±ndan her tablo iÃ§in "Permissions" alanÄ±nda izinler tanÄ±mlanÄ±r.
                </p>
                <p>
                  meetings > permissions alanÄ±nda user iÃ§in "Without any checks" ile tÃ¼m alanlara izin verildi. "Allow role user to make aggregation queries" de seÃ§ildi. aynÄ± iÅŸlem participants > permissions altÄ±nda da yapÄ±ldÄ±.
                </p>
                <p>
                  Bu haliyle kullanÄ±cÄ± kendisinin dahil olmadÄ±ÄŸÄ± meetingleri de gÃ¶rÃ¼r. Bunu engellemek iÃ§in "Without any checks" "With custom check" olarak gÃ¼ncellendi.
                  <pre class="prettyprint ms-0">
{
  "_or":[
    {
      "user_id":{
        "_eq":"X-Hasura-User-Id"
      }
    },
    {
      "participants":{
        "user_id":{
          "_eq":"X-Hasura-User-Id"
        }
      }
    }
  ]
}
                  </pre>
                </p>
                <p>
                  Bu durumda user sadece oluÅŸturduÄŸu veya katÄ±lÄ±mcÄ±sÄ± olduÄŸu meeting'leri gÃ¶rÃ¼ntÃ¼ler.
                </p>
              </div>
              <div class="row" id="hasuraComputedFields">
                <h1>Computed Fields</h1>
                <p>
                  OluÅŸturduÄŸumuz tabloda olmayan ama tablodaki alanlarla hesaplanarak oluÅŸturulabilen alanlardÄ±r. Ã–rneÄŸin user tablosunda name ve surname var. Bunlarla fullname yapÄ±labilir.
                </p>
                <p>
                  "DATA" > "users" > "Modify" > "Computed Fields"
                </p>
                <p>
                  Computed Field Name: fullName <br>
                  Function Schema:public <br>
                  Function Name: "Create New" ile postgreSQL dilinde bir fonksiyon yazÄ±yoruz.
                  <pre class="prettyprint ms-0">
CREATE FUNCTION user_full_name(user_row users)
RETURNS TEXT AS $$
  SELECT user_row.name || ' ' || user_row.surname
$$ LANGUAGE sql STABLE;
                  </pre>
                  fonksiyonu kaydediyoruz. Sonra baÅŸtaki adÄ±mlarÄ± tekrar yapÄ±yoruz. Function Name: kÄ±smÄ±nda az Ã¶nce oluÅŸturduÄŸumuz fonksiyonu seÃ§iyoruz ve kaydediyoruz.
                </p>
                <p>
                  DATA > users > permissions alanÄ±da user iÃ§in bu alana da izin verdikten sonra artÄ±k sorguda fullName diye bir parametremiz de oluyor.
                </p>
              </div>
              <div class="row" id="hasuraEventTrigers">
                <h1>Event Triggers</h1>
                <p>
                  meeting katÄ±lÄ±mcÄ±larÄ±na mail gÃ¶nderme iÅŸlemi. Ã–ncelikle <a href="https://www.mailspons.com/">mailspons.com</a> Ã¼zerinden her user iÃ§in fake mail alÄ±p veri tabanÄ±mÄ±za ekledik. Bu istediÄŸimiz gibi Ã§alÄ±ÅŸmadÄ±ÄŸÄ±ndan (biraz yavaÅŸ) <a href="https://www.tempinbox.xyz/mailbox">tempinbox.xyz</a> Ã¼zerinden tekrar fake mail alÄ±p user'larÄ±mÄ±za tanÄ±mladÄ±k.
                </p>
                <p>
                  Hasura Cloud Console > "EVENT" > "Event Triggers" > "Create"
                </p>
                <p>
                  Trigger Name: meeting_created <br>
                  Database: default <br>
                  Schema/Table: public, meetings <br>
                  Trigger Operations: Insert <br>
                  Webhook (HTTP/S) Handler: https://backend-1-m7357908.deta.app/webhooks/meeting_created <br>
                  "Create Event Triger"
                </p>
                <p>
                  backend\src\app.js iÃ§inde webhooks iÃ§in gereken routing yapÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
...
// routes
...
import webhooks from "./routes/webhooks";
...
                  </pre>
                </p>
                <p>
                  backend\src\routes\webhooks\queries.js iÃ§inde webhook ile weri Ã§ekilecek sorgu yazÄ±ldÄ±.
                  <pre class="prettyprint ms-0">
export const GET_MEETING_PARTICIPANTS = `
query meeting_participant($id: Int!) {
    meetings_by_pk(id: $id) {
      title
      user {
        fullName
      }
      participants {
        user {
          email
        }
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  mail gÃ¶nderebilmek iÃ§in
                  <pre class="prettyprint ms-0">npm i nodemailer</pre>
                  paketi kuruldu.
                </p>
                <p>
                  backend\src\routes\webhooks\index.js iÃ§inde events triger ile gelen veri alÄ±ndÄ±. Bu veri ile sorgu yapÄ±ldÄ±. Sorgudan gelen veriler ile de mail gÃ¶nderildi.
                  <pre class="prettyprint ms-0">
import express from "express";
import nodemailer from "nodemailer";

import Hasura from "../../clients/hasura";
import { GET_MEETING_PARTICIPANTS } from "./queries";

const router = express.Router();

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "myhasurabackendd@gmail.com",
    pass: "efuvzfpjocfdemnc",
  },
});

router.get("/meeting_created", (req, res) => {
  res.send("Hello World");
});

router.post("/meeting_created", async (req, res, next) => {
  const meeting = req.body.event.data.new;

  const { meetings_by_pk } = await Hasura.request(GET_MEETING_PARTICIPANTS, {
    id: meeting.id,
  });

  const title = meeting.title;
  const { fullName } = meetings_by_pk.user;
  const participants = meetings_by_pk.participants
    .map(({ user }) => user.email)
    .toString();

  const mailOptions = {
    from: "myhasurabackendd@gmail.com",
    to: participants,
    subject: `${fullName} sizi bir gÃ¶rÃ¼ÅŸmeye davet etti`,
    text: `${fullName} sizi ${title} adlÄ± gÃ¶rÃ¼ÅŸmeye davet etti.`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      throw new Error(error);
    }

    res.json({ info });
  });
});

export default router;

                  </pre>
                </p>
                <p>
                  Bu dosyada kullanÄ±lan process.env.... kÄ±sÄ±mlarÄ± backend\.env ve backend\Spacefile dosyalarÄ±na eklendi.
                </p>
              </div>
              <div class="row" id="hasuraMeetingApproveInvitation">
                <h1>Meeting Approve Invitation</h1>
                <p>
                  Mail il gelen daveti kabul etmek
                </p>
                <p>
                  "Hasura Cloud Console" > "DATA" > participants kÄ±smÄ±na "is_approved" adÄ±nda "boolean" default deÄŸeri "false" bir sÃ¼tun oluÅŸturduk.
                </p>
                <p>
                  "Hasura Cloud Console" > "DATA" > participants > "Permissions" altÄ±nda user iÃ§in update kÄ±smÄ±na "With custom check" ile <pre class="prettyprint ms-0">{"user_id":{"_eq":"X-Hasura-User-Id"}}</pre> koÅŸulu ile "is_approved" alanÄ±na izin verdik. "is_approved" iÃ§in select izni de verdik
                </p>
              </div>
              <div class="row" id="hasuraOneOffScheduledEvents1">
                <h1>One Off Scheduled Events - 1</h1>
                <p>
                  GÃ¶rÃ¼ÅŸmeye yarÄ±m saat kala katÄ±lÄ±mcÄ±lara mail gÃ¶nder.
                </p>
                <p>
                  "Hasura Cloud Console" > "EVENTS" > One-off Scheduled Events iÃ§inde <a href="https://hasura.io/docs/latest/api-reference/schema-metadata-api/scheduled-triggers/#create-scheduled-event">bu dÃ¶kÃ¼mandan</a> faydalanarak backend\src\routes\webhooks\index.js iÃ§inde bir obje oluÅŸturuyoruz.
                </p>
                <p>
                  zaman tanÄ±mlarÄ± iÃ§in <pre class="prettyprint ms-0">npm i moment</pre> ile kurduÄŸumuz paketi kullanacaÄŸÄ±z. Ä°stek gÃ¶ndermek iÃ§in de <pre class="prettyprint ms-0">npm i axios</pre> kuruldu.
                </p>
                <p>
                  "Hasura Cloud Console" > "DATA" > meeting iÃ§inde "meeting_date" data tipi "timestamp with time zone" olarak gÃ¼ncellendi.
                </p>
                <p>
                  meeting_date bilgisini alabilmek iÃ§in backend\src\routes\webhooks\queries.js iÃ§indeki query gÃ¼ncellendi.
                </p>
                <p>
                  backend\src\routes\webhooks\index.js iÃ§inde Scheduled Events oluÅŸturacak yapÄ± kurgulandÄ±. 
                  <pre class="prettyprint ms-0">
...
import moment from "moment";
import axios from "axios";

...

router.post("/meeting_created", async (req, res, next) => {
  ...

  const schedule_event = {
    // zamanlanmÄ±ÅŸ gÃ¶rev eklemek iÃ§in gereken obje
    type: "create_scheduled_event",
    args: {
      webhook: "https://backend-1-m7357908.deta.app/webhooks/meeting_reminder", //gÃ¶rev baÅŸlatÄ±lÄ±nca Ã§alÄ±ÅŸtÄ±rÄ±lacak webhook
      schedule_at: moment(meetings_by_pk.meeting_date).subtract(2, "min"), // gÃ¶rev baÅŸlangÄ±Ã§ tarihinden 2 dk Ã§Ä±kardÄ±k.
      payload: {
        //webhook tetiklendiÄŸinde gÃ¶nderilecek data
        meeting_id: meeting.id,
      },
    },
  };

  const add_event = await axios(
    "https://meeting-app-server.hasura.app/v1/query",
    {
      // endpoint olarak hasura endpointimizi sonuna qraphql yerine query yazarak kullanÄ±yoruz.
      method: "POST",
      data: JSON.stringify(schedule_event), // ile hazÄ±rladÄ±ÄŸÄ±mÄ±z Scheduled Events gÃ¶nderildi.
      headers: {
        "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
      },
    }
  );

  const event_data = add_event.data;

  ...
});

router.post("/meeting_reminder", async (req, res, next) => {
  // Scheduled Events ile tetiklenecek iÅŸlev.
});

export default router;

                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraOneOffScheduledEvents2">
                <h1>One Off Scheduled Events - 2</h1>
                <p>
                  insert_meeting_one mutation'unu user kullanÄ±cÄ±sÄ± ile kullanamabilmek iÃ§in, "DATA" > "meetings" > "Permissions" alanÄ±nda user > insert iÃ§in "with custom check" <pre>{"user_id":{"_eq":"X-Hasura-User-Id"}}</pre> kontrolÃ¼ ile, "Column insert permissions": "title, meeting_date" seÃ§ili, "Column presets" - "user_id" - "from session variable" -> "X-Hasura-user-id" izin verildi.
                </p>
                <p>
                  participant ekleyebilmesi iÃ§in de "DATA" > "meetings" > "Permissions" alanÄ±nda "with custom check" <pre>{"meeting":{"user_id":{"_eq":"X-Hasura-User-Id"}}}</pre> kontrolÃ¼ ile, "Column insert permissions": "meeting_id, user_id" seÃ§ili izin verildi.
                </p>
                <p>
                  backend\src\routes\webhooks\queries.js iÃ§ine aÅŸaÄŸÄ±daki sorguyu ekledik.
                  <pre>
export const GET_MEETING_PARTICIPANTS_REMINDER = `
  query meeting_participant($id: Int!) {
    meetings_by_pk(id: $id) {
      title
      meeting_date
      user {
        fullName
        email
      }
      participants(
        where: {
          is_approved: {
            _eq: true
          }
        }
      ) {
        user {
          email
        }
      }
    }
  }
`;
                  </pre>
                  bu sorguda bize sadece katÄ±lÄ±mÄ±nÄ± onaylayan katÄ±lÄ±mcÄ±larÄ± verdi.
                </p>
                <p>
                  backend\src\routes\webhooks\index.js iÃ§inde katÄ±lÄ±mcÄ±lara ve meeting oluÅŸturana mail gÃ¶nderecek olan fonksiyonlar yazÄ±ldÄ±. DosyanÄ±n son hali:
                  <pre>
import express from "express";
import nodemailer from "nodemailer";
import moment from "moment";
import axios from "axios";

import Hasura from "../../clients/hasura";
import {
  GET_MEETING_PARTICIPANTS,
  GET_MEETING_PARTICIPANTS_REMINDER,
} from "./queries";

const router = express.Router();

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "myhasurabackendd@gmail.com",
    pass: "efuvzfpjocfdemnc",
  },
});

router.get("/meeting_created", (req, res) => {
  res.send("Hello World");
});

router.post("/meeting_created", async (req, res, next) => {
  const meeting = req.body.event.data.new;

  const { meetings_by_pk } = await Hasura.request(GET_MEETING_PARTICIPANTS, {
    id: meeting.id,
  });

  const title = meeting.title;
  const { fullName } = meetings_by_pk.user;
  const participants = meetings_by_pk.participants
    .map(({ user }) => user.email)
    .toString();

  const schedule_event = {
    // zamanlanmÄ±ÅŸ gÃ¶rev eklemek iÃ§in gereken obje
    type: "create_scheduled_event",
    args: {
      webhook: "https://backend-1-m7357908.deta.app/webhooks/meeting_reminder", //gÃ¶rev baÅŸlatÄ±lÄ±nca Ã§alÄ±ÅŸtÄ±rÄ±lacak webhook
      schedule_at: moment(meetings_by_pk.meeting_date).subtract(2, "min"), // gÃ¶rev baÅŸlangÄ±Ã§ tarihinden 2 dk Ã§Ä±kardÄ±k.
      payload: {
        //webhook tetiklendiÄŸinde gÃ¶nderilecek data
        meeting_id: meeting.id,
      },
    },
  };

  const add_event = await axios(
    "https://meeting-app-server.hasura.app/v1/query",
    {
      // endpoint olarak hasura endpointimizi sonuna qraphql yerine query yazarak kullanÄ±yoruz.
      method: "POST",
      data: JSON.stringify(schedule_event),
      headers: {
        "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
      },
    }
  );

  const event_data = add_event.data;

  const mailOptions = {
    from: "myhasurabackendd@gmail.com",
    to: participants,
    subject: `${fullName} sizi bir gÃ¶rÃ¼ÅŸmeye davet etti`,
    text: `${fullName} sizi ${title} adlÄ± gÃ¶rÃ¼ÅŸmeye davet etti.`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      throw new Error(error);
    }

    res.json({ info });
  });
});

router.post("/meeting_reminder", async (req, res, next) => { // One-off Scheduled Events tetiklendiÄŸinde yÃ¶nleneceÄŸi endpoint route'u
  const { meeting_id } = req.body.payload; // One-off Scheduled Events ile gÃ¶nderilen data

  const { meetings_by_pk } = await Hasura.request(
    GET_MEETING_PARTICIPANTS_REMINDER,
    {
      id: meeting_id,
    }
  );

  const title = meetings_by_pk.title;
  const { email } = meetings_by_pk.user;
  const participants = meetings_by_pk.participants.map(
    ({ user }) => user.email
  );

  participants.push(email);

  const mailOptions = {
    from: "myhasurabackendd@gmail.com",
    to: participants.toString(),
    subject: `"${title}" baÅŸlÄ±klÄ± gÃ¶rÃ¼ÅŸmeniz birazdan baÅŸlayacak`,
    text: `"${title}" baÅŸlÄ±klÄ± gÃ¶rÃ¼ÅŸmeniz iki dakika sonra baÅŸlayacak KatÄ±lmak iÃ§in aÅŸaÄŸÄ±daki baÄŸlantÄ±yÄ± kullanÄ±n`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      throw new Error(error);
    }

    res.json({ info });
  });
});

export default router;
                  </pre>
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>