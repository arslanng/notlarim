<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">GraphQL</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          EÄŸitim NotlarÄ±
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notlarÄ±.html" target="_blank">HTML NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript NotlarÄ±</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notlarÄ±</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- Ä°Ã§erik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yÃ¼kseklik belirtmediÄŸinde kolon en alta kadar indiÄŸinden .sticky-top gÃ¶rÃ¼nÃ¼r bir etki yaratmÄ±yor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#whatIsGraphQL">GiriÅŸ</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsGraphQL">GraphQL Nedir? Ne DeÄŸildir?</a>
                    <a class="nav-link ms-3 my-1" href="#apolloServer">Apollo Server'a GiriÅŸ</a>
                    <a class="nav-link ms-3 my-1" href="#nonNullableFields">Non Nullable Fields</a>
                    <a class="nav-link ms-3 my-1" href="#scalarTypes">Scalar Types</a>
                    <a class="nav-link ms-3 my-1" href="#customTypes">Custom Types</a>
                    <a class="nav-link ms-3 my-1" href="#argumans">ArgÃ¼manlar ile Ã‡alÄ±ÅŸmak</a>
                    <a class="nav-link ms-3 my-1" href="#iliskiselData">Ä°liÅŸkisel Veriler ile Ã‡alÄ±ÅŸmak</a>
                    <a class="nav-link ms-3 my-1" href="#iliskiselDataArgumanlar">Ä°liÅŸkisel Ä°fadelerde ArgÃ¼manlar</a>
                  </nav>
                  <a class="nav-link" href="#whatIsMutation">Mutations (Server)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsMutation">Mutation Nedir? NasÄ±l YazÄ±lÄ±r?</a>
                    <a class="nav-link ms-3 my-1" href="#inputType">Input Type</a>
                    <a class="nav-link ms-3 my-1" href="#updateMutations">Update Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#deleteMutations">Delete Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#deleteAllMutations">Delete All Mutations</a>
                  </nav>
                  <a class="nav-link" href="#subscriptionServerSetup">Subscriptions (Server)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#subscriptionServerSetup">Subscription Server Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#userCRUDsubs">User CRUD Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#postVeCommentCRUDsubs">Post ve Comment CRUD Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#withFilter">withFilter ile Subscription Filtreleme</a>
                    <a class="nav-link ms-3 my-1" href="#redisPubsub">Redis PubSub</a>
                    <a class="nav-link ms-3 my-1" href="#env">Ortam DeÄŸiÅŸkenleri</a>
                  </nav>
                  <a class="nav-link" href="#Folder/Schema Structure - 1">Folder/Schema Structure</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#folderSchemaStructure1">Folder/Schema Structure - 1</a>
                    <a class="nav-link ms-3 my-1" href="#folderSchemaStructure2">Folder/Schema Structure - 2 (File Loader)</a>
                    <a class="nav-link ms-3 my-1" href="#babelComplier">Babel Compiler</a>
                  </nav>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div class="row" id="whatIsGraphQL">
                <h1>GraphQL Nedir? Ne DeÄŸildir?</h1>
                <p>
                  Rest Api yapÄ±sÄ±nÄ±n eksik olduÄŸu yÃ¶nleri kapatmak iÃ§in facebook ekibi tarafÄ±ndan geliÅŸtirilmiÅŸtir.
                </p>
                <p>
                  Api'dan veri Ã§ekerken sadece istediÄŸimiz sorguya uygun veri dÃ¶nmesini saÄŸlar. Bunu tek bir endpoint kullanarak yapar.
                </p>
                <p>
                  Ä°liÅŸkisel verilerle Ã§alÄ±ÅŸmasÄ± Ã§ok daha kolaydÄ±r.
                </p>
                <p>
                  GraphQL dÃ¶kÃ¼mantasyonunu kendisi otomatik olarak yapar. Sorgu sonucunun gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ arayÃ¼z de otomatik olarak oluÅŸur.
                </p>
                <p>
                  Versiyonlama yapmaya gerek yok. Eski ve yeni alanlarÄ± belirtebiliyoruz.
                </p>
                <p>
                  Websoket tanÄ±mlarÄ±nÄ± yapmak daha kolay.
                </p>
                <ul>GraphQL Terminolojisi
                  <li>Query: Bir veri kaynaÄŸÄ±na eriÅŸmek istediÄŸinizde kullanacaÄŸÄ±nÄ±z tanÄ±mdÄ±r.</li>
                  <li>Mutation: Ekleme, silme ve gÃ¼ncelleme iÅŸlemi iÃ§in kullanacaÄŸÄ±nÄ±z tanÄ±mdÄ±r.</li>
                  <li>Subscription: GerÃ§ek zamanlÄ± Ã§alÄ±ÅŸan projeler iÃ§in kullanacaÄŸÄ±nÄ±z tanÄ±mdÄ±r.</li>
                </ul>
            </div>
            <div class="row" id="apolloServer">
              <h1>Apollo Server'a GiriÅŸ</h1>
              <p>
                <a href="https://www.apollographql.com/docs/">Apollo Server</a>, hÄ±zlÄ±ca GraphQL sunucularÄ± oluÅŸturabileceÄŸimiz, oldukÃ§a az baÄŸÄ±mlÄ±lÄ±ÄŸÄ± olan bir kÃ¼tÃ¼phanedir.
              </p>
              <p>
                Apollo server kullanmak iÃ§in NodeJS pc de kurulu olmalÄ±.
              </p>
              <p>
                Bir dosya oluÅŸturup aÃ§Ä±yoruz. AÃ§tÄ±ÄŸÄ±mÄ±z dosyanÄ±n iÃ§inde <pre class="prettyprint ms-0">npm init --yes</pre> yazÄ±yoruz. <code>npm init</code> bizim yeni bir proje oluÅŸturmamÄ±zÄ± saÄŸlar. <code>--yes</code> npm init sonrasÄ± sorulacak tÃ¼m sorularÄ±n default olarak otomatik doldurulmasÄ±nÄ± saÄŸlar.
              </p>
              <p>
                Apollo server iÃ§in 2 tane baÄŸlÄ±lÄ±k gerekiyor. BunlarÄ± yÃ¼klemek iÃ§in terminale <pre class="prettyprint ms-0">npm i @apollo/server graphql</pre> yazÄ±yoruz.
              </p>
              <p>
                ES6 import yapspÄ±nÄ± kullanabilmek iÃ§in package.json dosyasÄ±nda aÅŸaÄŸÄ±daki ekleme yapÄ±lÄ±r.
                <pre class="prettyprint ms-0">
{
  // ...etc.
  "type": "module",
  "scripts": {
    "start": "node index.js"
  }
  // other dependencies
}
                </pre>
              </p>
              <p>
                index.js dosyasÄ± oluÅŸturulur. Ä°Ã§ine: 
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from '@apollo/server/standalone';

// Tip (type) tanÄ±mÄ±:
const typeDefs = `#graphql
  # GraphQL dizelerindeki yorumlar (bunun gibi) kare (#) simgesiyle baÅŸlar.
  # Bu "Book" tÃ¼rÃ¼, veri kaynaÄŸÄ±mÄ±zdaki her kitap iÃ§in sorgulanabilir alanlarÄ± tanÄ±mlar.

  type Book {
    title: String
    author: String
  }


  # "Query" tÃ¼rÃ¼ Ã¶zeldir: istemcilerin yÃ¼rÃ¼tebileceÄŸi tÃ¼m kullanÄ±labilir sorgularÄ± ve her birinin dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼ listeler. Bu durumda, "books" sorgusu sÄ±fÄ±r veya daha fazla Book'tan (yukarÄ±da tanÄ±mlanmÄ±ÅŸtÄ±r) oluÅŸan bir dizi dÃ¶ndÃ¼rÃ¼r.
  type Query {
    books: [Book]
  }
  # data tipi ne ise ona ona uygun dÃ¼zenlenmeli. Bu Ã¶rnekte data tipi array olduÄŸundan "[]" iÃ§ine yazÄ±ldÄ±.
`;
// data:
const books = [
  {
    title: "The Awakening",
    author: "Kate Chopin",
  },
  {
    title: "City of Glass",
    author: "Paul Auster",
  },
  {
    title: "YabancÄ±",
    author: "Albert Camus",
  },
];

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    books: () => books,
  },
};

// apollo server:
const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
              <p>
                terminale <pre class="prettyprint ms-0">npm start</pre> yazdÄ±ÄŸÄ±mÄ±zda terminalde "ğŸš€  Server ready at: http://localhost:4000/" Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶rÃ¼rÃ¼z.
              </p>
              <p>
                http://localhost:4000/ adresine gittiÄŸimizde bizi sorgu yapmak iÃ§in hazÄ±r bir arayÃ¼z ve dÃ¶kÃ¼mantasyon karÅŸÄ±lar.
              </p>
              <p> Bu arayÃ¼ze
                <pre class="prettyprint ms-0">
query ExampleQuery {
  books {
    title
  }
}
                </pre> yazarak datamÄ±zdaki kitap adlarÄ±na ulaÅŸabiliriz.
              </p> 
              <p>
                Bu sayfada gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z arayÃ¼zÃ¼, daha sÄ±k kullanÄ±lan graphql playground arayÃ¼zÃ¼ ile deÄŸiÅŸtirmek iÃ§in <a href="https://www.apollographql.com/docs/apollo-server/api/plugin/landing-pages/#graphql-playground-landing-page">bu yÃ¶nerge</a> takip edilebilir ancak yapÄ±mcÄ±lar bunu Ã¶nermiyor.
              </p>
              <p>
                Kodu her gÃ¼ncellediÄŸimizde serveri manuel restart etmemek iÃ§in nodemon kurduk. Bunun iÃ§in terminale <pre class="prettyprint ms-0">npm i --save-dev nodemon</pre> yazdÄ±k ve package.json>scripts alanÄ±na <pre class="prettyprint ms-0">"dev": "nodemon index.js",</pre> ekledik. Terminale <pre class="prettyprint ms-0">npm run dev</pre> yazarak serveri baÅŸlattÄ±ÄŸÄ±mÄ±zda her gÃ¼ncellemede kendini resetler.
              </p>
            </div>
            <div class="row" id="nonNullableFields">
              <h1>Non Nullable Fields</h1>
              <p>
                GraphQL resolver tanÄ±mlarÄ±nÄ±z Ã¼zerinde null dÃ¶nmemesini istediÄŸiniz bir field veya tip varsa bunun iÃ§in bir tanÄ±m yapabilirsiniz. "!" ile ifade edilir.
              </p>
              <p>
                <pre class="prettyprint ms-0">
...
type Book {
    title: String!
    author: String
  }
...

                </pre>
                ifadesi title alanÄ±nÄ±n null dÃ¶nemeyeceÄŸini ifade eder.
              </p> 
              <p>
                <pre class="prettyprint ms-0">
...
type Query {
  books: [Book]!
}
...
                </pre>
                ifadesi books sorgusunun null dÃ¶nemeyeceÄŸini ifade eder.
              </p>
              <p>
                <pre class="prettyprint ms-0">
...
type Query {
  books: [Book!]!
}
...
                </pre>
                ifadesi books sorgusunu sonucunda gelen array iÃ§inde null eleman olamayacaÄŸÄ±nÄ± ifade eder.
              </p>
            </div>
            <div class="row" id="scalarTypes">
              <h1>Scalar Types</h1>
              <ul>GraphQL'nin varsayÄ±lan skaler tÃ¼rleri ÅŸunlardÄ±r:
                <li>Int</li>
                <li>Float</li>
                <li>String</li>
                <li>Boolean</li>
                <li>ID</li>
              </ul>
              <p> Ã–rnek kullanÄ±m:
                <pre class="prettyprint ms-0">
...
type Book {
  id: ID!
  title: String!
  author: String
  score: Float
  isPublished: Boolean
}
...
                </pre>
                <pre class="prettyprint ms-0">
const books = [
  {
    id: 1,
    title: "The Awakening",
    author: "Kate Chopin",
    score: 6.9,
    isPublished: true
  },
...
                </pre>
              </p>
            </div>
            <div class="row" id="customTypes">
              <h1>Custom Types</h1>
              <p>
                Girilen verinin tipini girerken aÅŸaÄŸÄ±daki gibi tek tek girebiliriz:
                <pre class="prettyprint ms-0">
const typeDefs = `#graphql

  type Query {
    name: String!
    surname: String!
    age: Int
  }
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    name: () => "Murat",
    surname: () => "GÃ¶kduman",
    age: () => 29,
  },
};
                </pre> bunun yerine User iÃ§in bir tip tanÄ±mÄ± oluÅŸturup bunu da geÃ§ebiliriz.
                <pre class="prettyprint ms-0">
const typeDefs = `#graphql

  type User {
    name: String!
    surname: String!
    age: Int
  }
  type Query {
    user: User
  }
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    user: () => ({
      name: "Murat",
      surname: "GÃ¶kduman",
      age: 29,
    }),
  },
};
                </pre> bu yazÄ±mda User bir custom type'dÄ±r. Daha Ã¶nceki Ã¶rneklerdeki Book da bir custom type'dir.
              </p>
              <p>
                Bu durumda yeni bir veri girmek istersek ancak User iÃ§ine dahil etmezsek veri ayrÄ±ca tiplendirilip resorve edilebilir.
                <pre class="prettyprint ms-0">
const typeDefs = `#graphql

  type User {
    name: String!
    surname: String!
    age: Int
  }
  type Query {
    user: User
    hello: String!
  }
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    user: () => ({
      name: "Murat",
      surname: "GÃ¶kduman",
      age: 29,
    }),
    hello: () => "world"
  },
};
                </pre>
              </p>
              <p>
                localhost:4000 iÃ§inde aÅŸaÄŸÄ±daki sorgu yapÄ±ldÄ±ÄŸÄ±nda
                <pre class="prettyprint ms-0">
Query {
  hello
  user {
    name
    surname
  }
}
                </pre>
                AÅŸaÄŸÄ±daki cevap alÄ±nÄ±r.
                <pre class="prettyprint ms-0">
{
  "data": {
    "hello": "world",
    "user": {
      "name": "Murat",
      "surname": "GÃ¶kduman"
    }
  }
}
                </pre>
              </p>
              <p>
                Custom type baÅŸka bir custom type iÃ§inde type olarak da kullanÄ±labilir.
                <pre class="prettyprint ms-0">
const typeDefs = `#graphql

  type Author {
    id: ID!
    name: String!
    score: Float
    age: Int
    books: [Book!]
  }

  type Book {
    id: ID!
    title: String!
    author: Author!
    isPublsihed: Boolean
    score: Float
  }

  type Query {
    book: [Book]
  }
  
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    book: () => books,
  },
};
                </pre>
              </p>
            </div>
            <div class="row" id="argumans">
              <h1>ArgÃ¼manlar ile Ã‡alÄ±ÅŸmak</h1>
              <p>
                HazÄ±rlÄ±k olarak Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z datalarÄ± data.js dosyasÄ±na taÅŸÄ±dÄ±k ve index.js iÃ§ine import ettik.
              </p>
              <p>
                data.js
                <pre class="prettyprint ms-0">
export const authors = [
  {
    id: 3,
    name: "Kate Chopin",
    score: 8,
    books: [],
  },
  {
    id: 2,
    name: "Paul Auster",
    score: 3,
    books: [],
  },
  {
    id: 1,
    name: "Albert Camus",
    score: 5,
    books: [],
  },
];

export const books = [
  {
    id: 1,
    title: "The Awakening",
    author: authors[0],
    score: 6.9,
    isPublished: true,
  },
  {
    id: 2,
    title: "City of Glass",
    author: authors[1],
    score: 7,
  },
  {
    id: 3,
    title: "YabancÄ±",
    author: authors[2],
    isPublished: false,
  },
];
                </pre>
              </p>
              <p>
                id den kitap sorgulama ve id den yazar sorgulama iÃ§in typeQuery alanÄ±na ilgili tip tanÄ±mlarÄ± yapÄ±ldÄ±. SonrasÄ±nda bu tip tanÄ±mlarÄ±na uygun resolve lar tanÄ±mlandÄ±.
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";

// data:
import { books, authors } from "./data.js";

// Tip (type) tanÄ±mÄ±:
const typeDefs = `#graphql

  type Author {
    id: ID!
    name: String!
    score: Float
    age: Int
    books: [Book!]
  }

  type Book {
    id: ID!
    title: String!
    author: Author!
    isPublsihed: Boolean
    score: Float
  }

  type Query {
    books: [Book!]
    book(id: ID!): Book!
    
    authors: [Author!]
    author(id: ID!): Author!
  }
  
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    books: () => books,
    book: (parent, args) => {
      //4 parametre alÄ±r: 1. parent: iliÅŸkisel veri tabanÄ± oluÅŸtururken kullanacaÄŸÄ±z. 2. prametre istemciden gelen argÃ¼manÄ± verir.
      const data = books.find((book) => book.id == args.id);
      return data;
    },

    authors: () => authors,
    author: (parent, args) => {
      const data = authors.find((author) => author.id == args.id);
      return data;
    }
  },
};

// apollo server:
const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
              <p>
                resolver alanÄ±nda alÄ±nan 2. parametre sorguda bize gÃ¶nderilen parametredir. Bundan faydalanarak bir find iÅŸlemi yapÄ±ldÄ± ve gelen veri dÃ¶nÃ¼ldÃ¼.
              </p>
              <p>
                AÅŸaÄŸÄ±daki sorgu yapÄ±ldÄ±ÄŸÄ±nda
                <pre class="prettyprint ms-0">
query{
  author (id: 1){
    name
  }
  book(id: 3) {
    title
    author {
      name
    }
  }
}
                </pre>
                aÅŸaÄŸÄ±daki sonuÃ§ alÄ±nÄ±r
                <pre class="prettyprint ms-0">
{
  "data": {
    "author": {
      "name": "Albert Camus"
    },
    "book": {
      "title": "YabancÄ±",
      "author": {
        "name": "Albert Camus"
      }
    }
  }
}
                </pre>
              </p>
            </div>
            <div class="row" id="iliskiselData">
              <h1>Ä°liÅŸkisel Veriler ile Ã‡alÄ±ÅŸmak</h1>
              <p>
                Sorgu sÄ±rasÄ±nda birbiri ile alakalÄ± iki veriyi birbirine baÄŸlamak mÃ¼mkÃ¼n. Bunun iÃ§in aranacak karÅŸÄ±lÄ±k data alanÄ±ndan silinir. Daha sonra resolvers iÃ§inde iliÅŸkisi kurulur.
              </p>
              <p>
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";

// data:
import { books, authors } from "./data.js";

// Tip (type) tanÄ±mÄ±:
const typeDefs = `#graphql

  type Author {
    id: ID!
    name: String!
    score: Float
    age: Int
    books: [Book!]
  }

  type Book {
    id: ID!
    title: String!
    author: Author
    author_id: ID!
    isPublsihed: Boolean
    score: Float
  }

  type Query {
    books: [Book!]
    book(id: ID!): Book!
    
    authors: [Author!]
    author(id: ID!): Author!
  }
  
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    books: () => books,
    book: (parent, args) => books.find((book) => book.id === args.id),
    
    authors: () => authors,
    author: (parent, args) => authors.find((author) => author.id === args.id),
  },
  Book: {
    // Book tipi altÄ±ndaki author keyi iÃ§in girilen resolver.
    author: (
      parent, // parent sorgunun yapÄ±ldÄ±ÄŸÄ± parent tipin deÄŸerini dÃ¶ner.
      args 
    ) => authors.find((author) => author.id === parent.author_id),
  },
  Author: {
    books: (parent, args) =>
      books.filter((book) => book.author_id === parent.id),
  },
};

// apollo server:
const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
              <p>
                tip alanÄ±nda istenilen veri keyi veri tipi ile baÄŸlantÄ±lanÄ±r.
              </p>
              <p>
                resolver alanÄ±nda hangi tipin altÄ±nda hangi sorgu yapÄ±lÄ±rsa nasÄ±l bir verinin Ã§ekileceÄŸi tanÄ±mlanÄ±r.
              </p>
              <p>
                Book altÄ±nda author sorgulandÄ±ÄŸÄ±nda parent alanÄ±ndan aldÄ±ÄŸÄ± author_id ile authors iÃ§inde data arar.
              </p>
              <p>
                Author altÄ±nda books sorgulandÄ±ÄŸÄ±nda books iÃ§inde author_id deÄŸeri barent.id ile uyumlu olanlarÄ± filtreler.
              </p>
            </div>
            <div class="row" id="iliskiselDataArgumanlar">
              <h1>Ä°liÅŸkisel Ä°fadelerde ArgÃ¼manlar</h1>
              <p>
                Author altÄ±nda books sorgusuna ilk harfe gÃ¶re filtreleme Ã¶zelliÄŸi eklemek iÃ§in aÅŸaÄŸÄ±daki Ã¶rneÄŸi yaptÄ±k.
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";

// data:
import { books, authors } from "./data.js";
                </pre>
                <pre class="prettyprint ms-0">
// Tip (type) tanÄ±mÄ±:
const typeDefs = `#graphql

  type Author {
    id: ID!
    name: String!
    score: Float
    age: Int
    books(filter: String): [Book!] # filtreleme iÅŸlemi iÃ§in
  }
                </pre> books iÃ§in parametre alabilme Ã¶zelliÄŸi ve alacaÄŸÄ± parametrenin veri tipi belirtildi.
                <pre class="prettyprint ms-0">
type Book {
    id: ID!
    title: String!
    author: Author
    author_id: ID!
    isPublsihed: Boolean
    score: Float
  }

  type Query {
    books: [Book!]
    book(id: ID!): Book!
    
    authors: [Author!]
    author(id: ID!): Author!
  }
  
`;

// resolvers (Ã§Ã¶zÃ¼cÃ¼):
const resolvers = {
  Query: {
    books: () => books,
    book: (parent, args) => books.find((book) => book.id === args.id),

    authors: () => authors,
    author: (parent, args) => authors.find((author) => author.id === args.id),
  },
  Book: {
    author: (parent, args) =>
      authors.find((author) => author.id === parent.author_id),
  },
                </pre>
                <pre class="prettyprint ms-0">
Author: {
    books: (parent, args) => {
      let filtered = books.filter((book) => book.author_id === parent.id);

      if (args.filter) { // sorguda filter var ise
        filtered = filtered.filter((book) =>
          book.title.toLowerCase().startsWith(args.filter.toLowerCase()) // args.filter verisine gÃ¶re filtreler.
        );
      }
      return filtered;
    },
  },
};
                </pre> sorguda book iÃ§in filter parametresi geÃ§ildiyse ilk harfe gÃ¶re filtreleme yapÄ±lÄ±r.
                <pre class="prettyprint ms-0">
// apollo server:
const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alÄ±r. 1. tip tanÄ±mlarÄ±, 2. resolvers

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});

console.log(`ğŸš€  Server ready at: ${url}`);
                </pre>
              </p>
            </div>
            <div class="row" id="whatIsMutation">
              <h1>Mutation Nedir? NasÄ±l YazÄ±lÄ±r?</h1>
              <p>
                Mutation tanÄ±mÄ±, GraphQL sunucularÄ± Ã¼zerinde veri ekleme,silme veya gÃ¼ncelleme durumlarÄ±nda kullanÄ±lÄ±r.
              </p>
              <p>
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";
import { nanoid } from "nanoid"; // user id iÃ§in gerekli

import { users, posts, comments } from "./data.js";

const typeDefs = `#graphql
    type User {
        id: ID!
        fullName: String!
        posts: [Post]
        comments: [Comment]
    }

    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }

    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }

    type Query {
        users: [User!]!
        user(id: ID!): User!

        posts: [Post!]
        post(id: ID!): Post!

        comments: [Comment]
        comment(id: ID!): Comment!
    }

    type Mutation {
      createUser(fullName: String!): User! #createUser parametre olarak fullName keyi ile string alÄ±r. response olarak User dÃ¶ner.
      createPost(title: String!, user_id: ID!): Post!
      createComment(text: String!, post_id: ID!, user_id: ID!): Comment!
    }
`;

const resolvers = {
  Mutation: {
    createUser: (parent, args) => {
      // yeni user ekleme
      const user = {
        id: nanoid(),
        fullName: args.fullName,
      };

      users.push(user);

      return user;
    },
    createPost: (parent, args) => {
      // yeni post ekleme
      const post = { id: nanoid(), title: args.title, user_id: args.user_id };

      posts.push(post);

      return post;
    },
    createComment: (parent, { text, post_id, user_id }) => {
      //args destruct edildi
      // yeni comment ekleme
      const comment = {
        id: nanoid(),
        text, // parametre key ve value aynÄ± olduÄŸundan tek kelimeyle yazÄ±labilir.
        post_id,
        user_id,
      };

      comments.push(comment);

      return comment;
    },
  },
  Query: {
    users: () => users,
    user: (parent, args) => {
      const user = users.find((user) => user.id === args.id);
      if (!user) {
        return new Error("User not found");
      }

      return user;
    },

    posts: () => posts,
    post: (parent, args) => posts.find((post) => post.id === args.id),

    comments: () => comments,
    comment: (parent, args) =>
      comments.find((comment) => comment.id === args.id),
  },
  User: {
    posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
    comments: (parent, args) =>
      comments.filter((comment) => comment.user_id === parent.id),
  },
  Post: {
    comments: (parent, args) =>
      comments.filter((comment) => comment.post_id === parent.id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
  Comment: {
    post: (parent, args) => posts.find((post) => post.id === parent.post_id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
            </div>
            <div class="row" id="inputType">
              <h1>Input Type</h1>
              <p>
                Mutation iÃ§in yazÄ±lan parametre tanÄ±mlarÄ±, kdun temiz kalmasÄ± iÃ§in, baÅŸka bir alanda yazÄ±labilir. Bu alan input tanÄ±mÄ± ile baÅŸlar. Parametre iÃ§inde data ketyi ile karÅŸÄ±lanÄ±r.
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";
import { nanoid } from "nanoid"; // user id iÃ§in gerekli

import { users, posts, comments } from "./data.js";

const typeDefs = `#graphql

    type User {
        id: ID!
        fullName: String!
        posts: [Post]
        comments: [Comment]
    }

    input CreateUserInput { # createUser mutationu iÃ§in parametre tanÄ±mlarÄ±.
      fullName: String!
    }

    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { # createPost mutationu iÃ§in parametre tanÄ±mlarÄ±.
      title: String!
      user_id: ID!
    }

    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }

    type Query {
        users: [User!]!
        user(id: ID!): User!

        posts: [Post!]
        post(id: ID!): Post!

        comments: [Comment]
        comment(id: ID!): Comment!
    }

    type Mutation {
      createUser(data: CreateUserInput!): User! #input type tanÄ±mÄ± data keyi ile geÃ§ilir.
      createPost(data: CreatePostInput!): Post!
      createComment(data: CreateCommetInput!): Comment!
    }
`;

const resolvers = {
  Mutation: {
    createUser: (parent, args) => {
      // yeni user ekleme
      const user = {
        id: nanoid(),
        fullName: args.data.fullName, // gelen arguman data altÄ±nda gelir.
      };

      users.push(user);

      return user;
    },
    createPost: (parent, { data: { title, user_id } }) => {
      //args.data destruct edildi
      const post = {
        id: nanoid(),
        title,
        user_id,
      };

      posts.push(post);

      return post;
    },
    createComment: (parent, { data }) => {
      const comment = {
        id: nanoid(),
        ...data, // data iÃ§indeki veri obje olarak tamamen eklendi.
      };

      comments.push(comment);

      return comment;
    },
  },
  Query: {
    users: () => users,
    user: (parent, args) => {
      const user = users.find((user) => user.id === args.id);
      if (!user) {
        return new Error("User not found");
      }

      return user;
    },

    posts: () => posts,
    post: (parent, args) => posts.find((post) => post.id === args.id),

    comments: () => comments,
    comment: (parent, args) =>
      comments.find((comment) => comment.id === args.id),
  },
  User: {
    posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
    comments: (parent, args) =>
      comments.filter((comment) => comment.user_id === parent.id),
  },
  Post: {
    comments: (parent, args) =>
      comments.filter((comment) => comment.post_id === parent.id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
  Comment: {
    post: (parent, args) => posts.find((post) => post.id === parent.post_id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
            </div>
            <div class="row" id="updateMutations">
              <h1>Update Mutations</h1>
              <p>
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const typeDefs = `#graphql
  # User
  type User {
      id: ID!
      fullName: String!
      age: Int!
      posts: [Post]
      comments: [Comment]
  }

  input CreateUserInput { 
    fullName: String!
    age: Int!
  }

  input UpdateUserInput {
    fullName: String
    age: Int
  }

  # Post
  type Post {
      id: ID!
      title: String!
      user_id: ID!
      comments: [Comment!]
      user: User!
  }
  input CreatePostInput { 
    title: String!
    user_id: ID!
  }
  input UpdatePostInput {
    title: String
    user_id: ID
  }

  # Comment
  type Comment {
      id: ID!
      text: String!
      post_id: ID!
      post: Post!
      user: User!
  }
  input CreateCommetInput{
    text: String!
    post_id: ID!
    user_id: ID!
  }
  input UpdateCommentInput{
    text: String
    post_id: ID
    user_id: ID
  }

  type Query {
      users: [User!]!
      user(id: ID!): User!

      posts: [Post!]
      post(id: ID!): Post!

      comments: [Comment]
      comment(id: ID!): Comment!
  }

  type Mutation {
    # User
    createUser(data: CreateUserInput!): User! 
    updateUser(id: ID!, data: UpdateUserInput!): User!
    # Post
    createPost(data: CreatePostInput!): Post!
    updatePost(id: ID!, data: UpdatePostInput!): Post

    # Comment
    createComment(data: CreateCommetInput!): Comment!
    updateComment(id: ID!, data: UpdateCommentInput!): Comment!
  }
`;

const resolvers = {
  Mutation: {
    // User
    createUser: (parent, args) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
      };

      users.push(user);

      return user;
    },
    updateUser: (parent, { id, data }) => {
      const user_index = users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }

      const update_user = (users[user_index] = {
        ...users[user_index], // Ã¶nce mevcut tanÄ±mlarÄ± al
        ...data, // data altÄ±ndan gelenlerle merge et.
      });

      return update_user;
    },
    // Post
    createPost: (parent, { data: { title, user_id } }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };

      posts.push(post);

      return post;
    },
    updatePost: (parent, { id, data }) => {
      const post_index = posts.findIndex((post) => post.id === id);

      if (post_index === -1) {
        throw new Error("Post not found.");
      }

      const updated_post = (posts[post_index] = {
        ...posts[post_index],
        ...data,
      });

      return updated_post;
    },
    // Comment
    createComment: (parent, { data }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };

      comments.push(comment);

      return comment;
    },
    updateComment: (parent, { id, data }) => {
      const comment_index = comments.findIndex((comment) => comment.id === id);

      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }

      const updated_comment = (comments[comment_index] = {
        ...comments[comment_index],
        ...data,
      });

      return updated_comment;
    },
  },
  Query: {
    users: () => users,
    user: (parent, args) => {
      const user = users.find((user) => user.id === args.id);
      if (!user) {
        return new Error("User not found");
      }

      return user;
    },

    posts: () => posts,
    post: (parent, args) => posts.find((post) => post.id === args.id),

    comments: () => comments,
    comment: (parent, args) =>
      comments.find((comment) => comment.id === args.id),
  },
  User: {
    posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
    comments: (parent, args) =>
      comments.filter((comment) => comment.user_id === parent.id),
  },
  Post: {
    comments: (parent, args) =>
      comments.filter((comment) => comment.post_id === parent.id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
  Comment: {
    post: (parent, args) => posts.find((post) => post.id === parent.post_id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
            </div>
            <div class="row" id="deleteMutations">
              <h1>Delete Mutations</h1>
              <p>
                <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const typeDefs = `#graphql
  # User
  type User {
      id: ID!
      fullName: String!
      age: Int!
      posts: [Post]
      comments: [Comment]
  }

  input CreateUserInput { 
    fullName: String!
    age: Int!
  }

  input UpdateUserInput {
    fullName: String
    age: Int
  }

  # Post
  type Post {
      id: ID!
      title: String!
      user_id: ID!
      comments: [Comment!]
      user: User!
  }
  input CreatePostInput { 
    title: String!
    user_id: ID!
  }
  input UpdatePostInput {
    title: String
    user_id: ID
  }

  # Comment
  type Comment {
      id: ID!
      text: String!
      post_id: ID!
      post: Post!
      user: User!
  }
  input CreateCommetInput{
    text: String!
    post_id: ID!
    user_id: ID!
  }
  input UpdateCommentInput{
    text: String
    post_id: ID
    user_id: ID
  }

  type Query {
      users: [User!]!
      user(id: ID!): User!

      posts: [Post!]
      post(id: ID!): Post!

      comments: [Comment]
      comment(id: ID!): Comment!
  }

  type Mutation {
    # User
    createUser(data: CreateUserInput!): User! 
    updateUser(id: ID!, data: UpdateUserInput!): User!
    deleteUser(id: ID!): User!
    # Post
    createPost(data: CreatePostInput!): Post!
    updatePost(id: ID!, data: UpdatePostInput!): Post!
    deletePost(id: ID!): Post!

    # Comment
    createComment(data: CreateCommetInput!): Comment!
    updateComment(id: ID!, data: UpdateCommentInput!): Comment!
    deleteComment(id: ID!): Comment!
  }
`;

const resolvers = {
  Mutation: {
    // User
    createUser: (parent, args) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
      };

      users.push(user);

      return user;
    },
    updateUser: (parent, { id, data }) => {
      const user_index = users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }

      const update_user = (users[user_index] = {
        ...users[user_index],
        ...data,
      });

      return update_user;
    },
    deleteUser: (parent, { id }) => {
      // silme iÅŸlemi iÃ§in: 1. filter metodunda id si parent.id olmayanlarÄ± filtreleyip users'a atayabiliriz. 2. indexini bulup slice ile Ã§Ä±kartabiliriz.
      const user_index = users.findIndex((user) => user.id === id); // bu idye sahip kullanÄ±cÄ± var mÄ±?
      if (user_index === -1) {
        throw new Error("User not found.");
      }

      const deleted_user = users[user_index]; // silinecek olanÄ± ayrÄ± bir yere kaydettik

      users.splice(user_index, 1); //splice iki parametre alÄ±r. Silinecek olanÄ±n indexi ve indexten itibaren kaÃ§ eleman silineceÄŸi. 3 parametre olarak da yerine eklenecek Ã¶geyi alabilir.

      return deleted_user;
    },
    // Post
    createPost: (parent, { data: { title, user_id } }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };

      posts.push(post);

      return post;
    },
    updatePost: (parent, { id, data }) => {
      const post_index = posts.findIndex((post) => post.id === id);

      if (post_index === -1) {
        throw new Error("Post not found.");
      }

      const updated_post = (posts[post_index] = {
        ...posts[post_index],
        ...data,
      });

      return updated_post;
    },
    deletePost: (parent, { id }) => {
      const post_index = posts.findIndex((post) => post.id === id);
      if (post_index === -1) {
        throw new Error("Post not found.");
      }

      const deleted_post = posts[post_index];

      posts.splice(post_index, 1);

      return deleted_post;
    },

    // Comment
    createComment: (parent, { data }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };

      comments.push(comment);

      return comment;
    },
    updateComment: (parent, { id, data }) => {
      const comment_index = comments.findIndex((comment) => comment.id === id);

      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }

      const updated_comment = (comments[comment_index] = {
        ...comments[comment_index],
        ...data,
      });

      return updated_comment;
    },
    deleteComment: (parent, { id }) => {
      const comment_index = comments.findIndex((comment) => comment.id === id);
      if (comment_index === -1) {
        throw new Error("Comment not found");
      }

      const deleted_comment = comments[comment_index];

      comments.splice(comment_index, 1);
      
      return deleted_comment;
    },
  },
  Query: {
    users: () => users,
    user: (parent, args) => {
      const user = users.find((user) => user.id === args.id);
      if (!user) {
        return new Error("User not found");
      }

      return user;
    },

    posts: () => posts,
    post: (parent, args) => posts.find((post) => post.id === args.id),

    comments: () => comments,
    comment: (parent, args) =>
      comments.find((comment) => comment.id === args.id),
  },
  User: {
    posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
    comments: (parent, args) =>
      comments.filter((comment) => comment.user_id === parent.id),
  },
  Post: {
    comments: (parent, args) =>
      comments.filter((comment) => comment.post_id === parent.id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
  Comment: {
    post: (parent, args) => posts.find((post) => post.id === parent.post_id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });

console.log(`ğŸš€  Server ready at: ${url}`);

                </pre>
              </p>
            </div>
            <div class="row" id="deleteAllMutations">
              <h1>Delete All Mutations</h1>
              <pre class="prettyprint ms-0">
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const typeDefs = `#graphql
  # User
  type User {
      id: ID!
      fullName: String!
      age: Int!
      posts: [Post]
      comments: [Comment]
  }

  input CreateUserInput { 
    fullName: String!
    age: Int!
  }

  input UpdateUserInput {
    fullName: String
    age: Int
  }

  # Post
  type Post {
      id: ID!
      title: String!
      user_id: ID!
      comments: [Comment!]
      user: User!
  }
  input CreatePostInput { 
    title: String!
    user_id: ID!
  }
  input UpdatePostInput {
    title: String
    user_id: ID
  }

  # Comment
  type Comment {
      id: ID!
      text: String!
      post_id: ID!
      post: Post!
      user: User!
  }
  input CreateCommetInput{
    text: String!
    post_id: ID!
    user_id: ID!
  }
  input UpdateCommentInput{
    text: String
    post_id: ID
    user_id: ID
  }

  type DeleteAllOutput {
    count: Int!
  }

  type Query {
      users: [User!]!
      user(id: ID!): User!

      posts: [Post!]
      post(id: ID!): Post!

      comments: [Comment]
      comment(id: ID!): Comment!
  }

  type Mutation {
    # User
    createUser(data: CreateUserInput!): User! 
    updateUser(id: ID!, data: UpdateUserInput!): User!
    deleteUser(id: ID!): User!
    deleteAllUsers: DeleteAllOutput!
    # Post
    createPost(data: CreatePostInput!): Post!
    updatePost(id: ID!, data: UpdatePostInput!): Post!
    deletePost(id: ID!): Post!
    deleteAllPosts: DeleteAllOutput!

    # Comment
    createComment(data: CreateCommetInput!): Comment!
    updateComment(id: ID!, data: UpdateCommentInput!): Comment!
    deleteComment(id: ID!): Comment!
    deleteAllComments: DeleteAllOutput!
  }
`;

const resolvers = {
  Mutation: {
    // User
    createUser: (parent, args) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
      };

      users.push(user);

      return user;
    },
    updateUser: (parent, { id, data }) => {
      const user_index = users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }

      const update_user = (users[user_index] = {
        ...users[user_index],
        ...data,
      });

      return update_user;
    },
    deleteUser: (parent, { id }) => {
      const user_index = users.findIndex((user) => user.id === id); 
      if (user_index === -1) {
        throw new Error("User not found.");
      }

      const deleted_user = users[user_index]; 

      users.splice(user_index, 1); 

      return deleted_user;
    },
    deleteAllUsers: () => {
      const length = users.length;
      // users = []; // users tanÄ±mlanÄ±rken const ile tanÄ±mlandÄ±ÄŸÄ±ndan bu method Ã§alÄ±ÅŸmaz. Bunun Ã§alÄ±ÅŸabilmesi iÃ§iin const ifadesi let ile deÄŸiÅŸtirilebilir veya farklÄ± bir metod kullanÄ±labilir.

      users.splice(0, length); // 0 dan baÅŸlayÄ±p tÃ¼m elemanlarÄ± siler

      return {
        count: length,
      };
    },
    // Post
    createPost: (parent, { data: { title, user_id } }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };

      posts.push(post);

      return post;
    },
    updatePost: (parent, { id, data }) => {
      const post_index = posts.findIndex((post) => post.id === id);

      if (post_index === -1) {
        throw new Error("Post not found.");
      }

      const updated_post = (posts[post_index] = {
        ...posts[post_index],
        ...data,
      });

      return updated_post;
    },
    deletePost: (parent, { id }) => {
      const post_index = posts.findIndex((post) => post.id === id);
      if (post_index === -1) {
        throw new Error("Post not found.");
      }

      const deleted_post = posts[post_index];

      posts.splice(post_index, 1);

      return deleted_post;
    },
    deleteAllPosts: () => {
      const length = posts.length;

      posts.splice(0, length);

      return {
        count: length,
      };
    },

    // Comment
    createComment: (parent, { data }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };

      comments.push(comment);

      return comment;
    },
    updateComment: (parent, { id, data }) => {
      const comment_index = comments.findIndex((comment) => comment.id === id);

      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }

      const updated_comment = (comments[comment_index] = {
        ...comments[comment_index],
        ...data,
      });

      return updated_comment;
    },
    deleteComment: (parent, { id }) => {
      const comment_index = comments.findIndex((comment) => comment.id === id);
      if (comment_index === -1) {
        throw new Error("Comment not found");
      }

      const deleted_comment = comments[comment_index];

      comments.splice(comment_index, 1);

      return deleted_comment;
    },
    deleteAllComments: () => {
      const length = comments.length;
      comments.splice(0, length);
      return {
        count: length,
      };
    },
  },
  Query: {
    users: () => users,
    user: (parent, args) => {
      const user = users.find((user) => user.id === args.id);
      if (!user) {
        return new Error("User not found");
      }

      return user;
    },

    posts: () => posts,
    post: (parent, args) => posts.find((post) => post.id === args.id),

    comments: () => comments,
    comment: (parent, args) =>
      comments.find((comment) => comment.id === args.id),
  },
  User: {
    posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
    comments: (parent, args) =>
      comments.filter((comment) => comment.user_id === parent.id),
  },
  Post: {
    comments: (parent, args) =>
      comments.filter((comment) => comment.post_id === parent.id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
  Comment: {
    post: (parent, args) => posts.find((post) => post.id === parent.post_id),
    user: (parent, args) => users.find((user) => user.id === parent.user_id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });

console.log(`ğŸš€  Server ready at: ${url}`);

              </pre>
            </div>
            <div class="row" id="subscriptionServerSetup">
              <h1>Subscription Server Kurulumu</h1>
              <p>
                Subscription tanÄ±mÄ± gerÃ§ekleÅŸen olaylardan(ekleme,silme,gÃ¼ncelleme vb.) gerÃ§ek zamanlÄ± olarak haberdar olabileceÄŸimiz WebSocket tabanlÄ± bir yapÄ±dÄ±r.
              </p>
              <p>
                Apollo Server'Ä±n 3. versiyonu ile birlikte Subscription yapÄ±sÄ± core Ã¼zerinden kaldÄ±rÄ±ldÄ± ancak ek kÃ¼tÃ¼phaneler ekleyerek bunu yeniden aktifleÅŸtirebilirsiniz. Bu iÅŸlem sÄ±rasÄ±nda birden fazla kÃ¼tÃ¼phanenin kurulmasÄ± gerekiyor ve kod biraz daha karmaÅŸÄ±k gÃ¶rÃ¼nÃ¼yor. Bundan kurtulmak iÃ§in <a href="https://github.com/dotansimha/graphql-yoga">graphql yoga</a> adÄ±nda bir kÃ¼tÃ¼phaneden faydalanacaÄŸÄ±z.
              </p>
              <p>
                Terminale <pre class="prettyprint ms-0">npm i graphql-yoga</pre> yazÄ±yoruz
              </p>
              <p>
                Dersin videosu gÃ¼ncel deÄŸil. Biz kendi yolumuzu bulacaÄŸÄ±z. <a href="https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions">Bunu</a> uyguladÄ±k.
              </p>
              <p>
                <a href="https://github.com/dotansimha/graphql-yoga/blob/main/examples/subscriptions/src/index.ts">Bu</a> da kullanÄ±labilir. AynÄ± methodun farklÄ± yazÄ±lmÄ±ÅŸÄ±.
              </p>
              <p>
                <pre class="prettyprint ms-0">
import { createYoga, createSchema, createPubSub } from "graphql-yoga"; //graphql-yoga iÃ§inden gerekenler import edildi.
import { createServer } from "node:http";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const pubSub = createPubSub(); // YayÄ±n iÃ§in gereken middleware

const yoga = createYoga({
  // ÅemayÄ± sarmala
  schema: createSchema({
    typeDefs: `#graphql
      # User
      type User {
          id: ID!
          fullName: String!
          age: Int!
          posts: [Post]
          comments: [Comment]
      }

      input CreateUserInput { 
        fullName: String!
        age: Int!
      }

      input UpdateUserInput {
        fullName: String
        age: Int
      }

      # Post
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
      input CreatePostInput { 
        title: String!
        user_id: ID!
      }
      input UpdatePostInput {
        title: String
        user_id: ID
      }

      # Comment
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
      input CreateCommetInput{
        text: String!
        post_id: ID!
        user_id: ID!
      }
      input UpdateCommentInput{
        text: String
        post_id: ID
        user_id: ID
      }

      type DeleteAllOutput {
        count: Int!
      }

      type Query {
          users: [User!]!
          user(id: ID!): User!

          posts: [Post!]
          post(id: ID!): Post!

          comments: [Comment]
          comment(id: ID!): Comment!
      }

      type Mutation {
        # User
        createUser(data: CreateUserInput!): User! 
        updateUser(id: ID!, data: UpdateUserInput!): User!
        deleteUser(id: ID!): User!
        deleteAllUsers: DeleteAllOutput!
        # Post
        createPost(data: CreatePostInput!): Post!
        updatePost(id: ID!, data: UpdatePostInput!): Post!
        deletePost(id: ID!): Post!
        deleteAllPosts: DeleteAllOutput!

        # Comment
        createComment(data: CreateCommetInput!): Comment!
        updateComment(id: ID!, data: UpdateCommentInput!): Comment!
        deleteComment(id: ID!): Comment!
        deleteAllComments: DeleteAllOutput!
      }

      type Subscription {
        # count: Int! # Ã–rnek iÃ§in
        userCreated: User!
      }
    `,
    resolvers: {
      Subscription: {
        // count: { // Ã–rnek
        //   subscribe: () => { // Her saniye deÄŸeri 1 arttÄ±rÄ±p iletir
        //     let count = 0;

        //     setInterval(() => {
        //       count++;
        //       pubSub.publish("count", {count});
        //     }, 1000);

        //     return pubSub.subscribe("count")
        //   }
        // }
        userCreated: {
          subscribe: () => pubSub.subscribe("userCreated"), // kanala abone olduk.
        },
      },
      Mutation: {
        // User
        createUser: (parent, args) => {
          const user = {
            id: nanoid(),
            fullName: args.data.fullName,
            age: args.data.age
          };

          users.push(user);
          pubSub.publish("userCreated", {"userCreated": user}); // yayÄ±n yapÄ±ldÄ±.

          return user;
        },
        updateUser: (parent, { id, data }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const update_user = (users[user_index] = {
            ...users[user_index],
            ...data,
          });

          return update_user;
        },
        deleteUser: (parent, { id }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const deleted_user = users[user_index];

          users.splice(user_index, 1);

          return deleted_user;
        },
        deleteAllUsers: () => {
          const length = users.length;

          users.splice(0, length); 

          return {
            count: length,
          };
        },
        // Post
        createPost: (parent, { data: { title, user_id } }) => {
          const post = {
            id: nanoid(),
            title,
            user_id,
          };

          posts.push(post);

          return post;
        },
        updatePost: (parent, { id, data }) => {
          const post_index = posts.findIndex((post) => post.id === id);

          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const updated_post = (posts[post_index] = {
            ...posts[post_index],
            ...data,
          });

          return updated_post;
        },
        deletePost: (parent, { id }) => {
          const post_index = posts.findIndex((post) => post.id === id);
          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const deleted_post = posts[post_index];

          posts.splice(post_index, 1);

          return deleted_post;
        },
        deleteAllPosts: () => {
          const length = posts.length;

          posts.splice(0, length);

          return {
            count: length,
          };
        },

        // Comment
        createComment: (parent, { data }) => {
          const comment = {
            id: nanoid(),
            ...data,
          };

          comments.push(comment);

          return comment;
        },
        updateComment: (parent, { id, data }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );

          if (comment_index === -1) {
            throw new Error("Comment not found.");
          }

          const updated_comment = (comments[comment_index] = {
            ...comments[comment_index],
            ...data,
          });

          return updated_comment;
        },
        deleteComment: (parent, { id }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );
          if (comment_index === -1) {
            throw new Error("Comment not found");
          }

          const deleted_comment = comments[comment_index];

          comments.splice(comment_index, 1);

          return deleted_comment;
        },
        deleteAllComments: () => {
          const length = comments.length;
          comments.splice(0, length);
          return {
            count: length,
          };
        },
      },
      Query: {
        users: () => users,
        user: (parent, args) => {
          const user = users.find((user) => user.id === args.id);
          if (!user) {
            return new Error("User not found");
          }

          return user;
        },

        posts: () => posts,
        post: (parent, args) => posts.find((post) => post.id === args.id),

        comments: () => comments,
        comment: (parent, args) =>
          comments.find((comment) => comment.id === args.id),
      },
      User: {
        posts: (parent, args) =>
          posts.filter((post) => post.user_id === parent.id),
        comments: (parent, args) =>
          comments.filter((comment) => comment.user_id === parent.id),
      },
      Post: {
        comments: (parent, args) =>
          comments.filter((comment) => comment.post_id === parent.id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
      Comment: {
        post: (parent, args) =>
          posts.find((post) => post.id === parent.post_id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
    },
  }),
});

const server = createServer(yoga); // server kur

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});

                </pre>
              </p>
            </div>
            <div class="row" id="userCRUDsubs">
              <h1>User CRUD Subscriptions</h1>
              <p>
                YukarÄ±daki iÅŸlemleri diÄŸer user Crud iÅŸlemlerine uyarladÄ±k.
                <pre class="prettyprint ms-0">
import { createYoga, createSchema, createPubSub } from "graphql-yoga";
import { createServer } from "node:http";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const pubSub = createPubSub();

const yoga = createYoga({
  // ÅemayÄ± sarmala
  schema: createSchema({
    typeDefs: `#graphql
      # User
      type User {
          id: ID!
          fullName: String!
          age: Int!
          posts: [Post]
          comments: [Comment]
      }

      input CreateUserInput { 
        fullName: String!
        age: Int!
      }

      input UpdateUserInput {
        fullName: String
        age: Int
      }

      # Post
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
      input CreatePostInput { 
        title: String!
        user_id: ID!
      }
      input UpdatePostInput {
        title: String
        user_id: ID
      }

      # Comment
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
      input CreateCommetInput{
        text: String!
        post_id: ID!
        user_id: ID!
      }
      input UpdateCommentInput{
        text: String
        post_id: ID
        user_id: ID
      }

      type DeleteAllOutput {
        count: Int!
      }

      type Query {
          users: [User!]!
          user(id: ID!): User!

          posts: [Post!]
          post(id: ID!): Post!

          comments: [Comment]
          comment(id: ID!): Comment!
      }

      type Mutation {
        # User
        createUser(data: CreateUserInput!): User! 
        updateUser(id: ID!, data: UpdateUserInput!): User!
        deleteUser(id: ID!): User!
        deleteAllUsers: DeleteAllOutput!
        # Post
        createPost(data: CreatePostInput!): Post!
        updatePost(id: ID!, data: UpdatePostInput!): Post!
        deletePost(id: ID!): Post!
        deleteAllPosts: DeleteAllOutput!

        # Comment
        createComment(data: CreateCommetInput!): Comment!
        updateComment(id: ID!, data: UpdateCommentInput!): Comment!
        deleteComment(id: ID!): Comment!
        deleteAllComments: DeleteAllOutput!
      }

      type Subscription {
        # count: Int! # Ã–rnek iÃ§in

        # User
        userCreated: User!
        userUpdated: User!
        userDeleted: User!

      }
    `,
    resolvers: {
      Subscription: {
        userCreated: {
          subscribe: () => pubSub.subscribe("userCreated"),
        },
        userUpdated: {
          subscribe: () => pubSub.subscribe("userUpdated"), // yayÄ±na abone olundu
        },
        userDeleted: {
          subscribe: () => pubSub.subscribe("userDeleted"), // yayÄ±na abone olundu
        },
      },
      Mutation: {
        // User
        createUser: (parent, args) => {
          const user = {
            id: nanoid(),
            fullName: args.data.fullName,
            age: args.data.age,
          };

          users.push(user);
          pubSub.publish("userCreated", { userCreated: user });

          return user;
        },
        updateUser: (parent, { id, data }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const update_user = (users[user_index] = {
            ...users[user_index],
            ...data,
          });
          pubSub.publish("userUpdated", { userUpdated: update_user, }); //yayÄ±n yapÄ±ldÄ±
          return update_user;
        },
        deleteUser: (parent, { id }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const deleted_user = users[user_index];

          users.splice(user_index, 1);

          pubSub.publish("userDeleted", { userDeleted: deleted_user }); // yayÄ±n yapÄ±ldÄ±
          return deleted_user;
        },
        deleteAllUsers: () => {
          const length = users.length;

          users.splice(0, length);

          return {
            count: length,
          };
        },
        // Post
        createPost: (parent, { data: { title, user_id } }) => {
          const post = {
            id: nanoid(),
            title,
            user_id,
          };

          posts.push(post);

          return post;
        },
        updatePost: (parent, { id, data }) => {
          const post_index = posts.findIndex((post) => post.id === id);

          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const updated_post = (posts[post_index] = {
            ...posts[post_index],
            ...data,
          });

          return updated_post;
        },
        deletePost: (parent, { id }) => {
          const post_index = posts.findIndex((post) => post.id === id);
          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const deleted_post = posts[post_index];

          posts.splice(post_index, 1);

          return deleted_post;
        },
        deleteAllPosts: () => {
          const length = posts.length;

          posts.splice(0, length);

          return {
            count: length,
          };
        },

        // Comment
        createComment: (parent, { data }) => {
          const comment = {
            id: nanoid(),
            ...data,
          };

          comments.push(comment);

          return comment;
        },
        updateComment: (parent, { id, data }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );

          if (comment_index === -1) {
            throw new Error("Comment not found.");
          }

          const updated_comment = (comments[comment_index] = {
            ...comments[comment_index],
            ...data,
          });

          return updated_comment;
        },
        deleteComment: (parent, { id }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );
          if (comment_index === -1) {
            throw new Error("Comment not found");
          }

          const deleted_comment = comments[comment_index];

          comments.splice(comment_index, 1);

          return deleted_comment;
        },
        deleteAllComments: () => {
          const length = comments.length;
          comments.splice(0, length);
          return {
            count: length,
          };
        },
      },
      Query: {
        users: () => users,
        user: (parent, args) => {
          const user = users.find((user) => user.id === args.id);
          if (!user) {
            return new Error("User not found");
          }

          return user;
        },

        posts: () => posts,
        post: (parent, args) => posts.find((post) => post.id === args.id),

        comments: () => comments,
        comment: (parent, args) =>
          comments.find((comment) => comment.id === args.id),
      },
      User: {
        posts: (parent, args) =>
          posts.filter((post) => post.user_id === parent.id),
        comments: (parent, args) =>
          comments.filter((comment) => comment.user_id === parent.id),
      },
      Post: {
        comments: (parent, args) =>
          comments.filter((comment) => comment.post_id === parent.id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
      Comment: {
        post: (parent, args) =>
          posts.find((post) => post.id === parent.post_id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
    },
  }),
});

const server = createServer(yoga); // server kur

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});

                </pre>
              </p>
            </div>
            <div class="row" id="postVeCommentCRUDsubs">
              <h1>Post ve Comment CRUD Subscriptions</h1>
              <p>
                YukarÄ±daki iÅŸlemi post ve comment iÃ§in tekrarlÄ±yoruz.
                <pre class="prettyprint ms-0">
import { createYoga, createSchema, createPubSub } from "graphql-yoga";
import { createServer } from "node:http";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const pubSub = createPubSub();

const yoga = createYoga({
  // ÅemayÄ± sarmala
  schema: createSchema({
    typeDefs: `#graphql
      # User
      type User {
          id: ID!
          fullName: String!
          age: Int!
          posts: [Post]
          comments: [Comment]
      }

      input CreateUserInput { 
        fullName: String!
        age: Int!
      }

      input UpdateUserInput {
        fullName: String
        age: Int
      }

      # Post
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
      input CreatePostInput { 
        title: String!
        user_id: ID!
      }
      input UpdatePostInput {
        title: String
        user_id: ID
      }

      # Comment
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
      input CreateCommetInput{
        text: String!
        post_id: ID!
        user_id: ID!
      }
      input UpdateCommentInput{
        text: String
        post_id: ID
        user_id: ID
      }

      type DeleteAllOutput {
        count: Int!
      }

      type Query {
          users: [User!]!
          user(id: ID!): User!

          posts: [Post!]
          post(id: ID!): Post!

          comments: [Comment]
          comment(id: ID!): Comment!
      }

      type Mutation {
        # User
        createUser(data: CreateUserInput!): User! 
        updateUser(id: ID!, data: UpdateUserInput!): User!
        deleteUser(id: ID!): User!
        deleteAllUsers: DeleteAllOutput!
        # Post
        createPost(data: CreatePostInput!): Post!
        updatePost(id: ID!, data: UpdatePostInput!): Post!
        deletePost(id: ID!): Post!
        deleteAllPosts: DeleteAllOutput!

        # Comment
        createComment(data: CreateCommetInput!): Comment!
        updateComment(id: ID!, data: UpdateCommentInput!): Comment!
        deleteComment(id: ID!): Comment!
        deleteAllComments: DeleteAllOutput!
      }

      type Subscription {
        # count: Int! # Ã–rnek iÃ§in

        # User
        userCreated: User!
        userUpdated: User!
        userDeleted: User!

        # Post
        postCreated: Post!
        postUpdated: Post!
        postDeleted: Post!
        postsCount: Int!

        # Comment
        commentCreated: Comment!
        commentUpdated: Comment!
        commentDeleted: Comment!
      }
    `,
    resolvers: {
      Subscription: {
        // User
        userCreated: {
          subscribe: () => pubSub.subscribe("userCreated"),
        },
        userUpdated: {
          subscribe: () => pubSub.subscribe("userUpdated"),
        },
        userDeleted: {
          subscribe: () => pubSub.subscribe("userDeleted"),
        },

        // Post
        postCreated: {
          subscribe: () => pubSub.subscribe("postCreated"),
        },
        postUpdated: {
          subscribe: () => pubSub.subscribe("postUpdated"),
        },
        postDeleted: {
          subscribe: () => pubSub.subscribe("postDeleted"),
        },
        postsCount: {
          subscribe: () => {
            setTimeout(() => {
              pubSub.publish("postsCount", { postsCount: posts.length })
            }); // publish iÅŸlemi subscribe iÅŸleminden sonra olmalÄ±. Bu nedenle geÃ§ikme koyduk
            return pubSub.subscribe("postsCount");
          },
        },

        // Comment
        commentCreated: {
          subscribe: () => pubSub.subscribe("commentCreated"),
        },
        commentUpdated: {
          subscribe: () => pubSub.subscribe("commentUpdated"),
        },
        commentDeleted: {
          subscribe: () => pubSub.subscribe("commentDeleted"),
        },
      },
      Mutation: {
        // User
        createUser: (parent, args) => {
          const user = {
            id: nanoid(),
            fullName: args.data.fullName,
            age: args.data.age,
          };

          users.push(user);
          pubSub.publish("userCreated", { userCreated: user });

          return user;
        },
        updateUser: (parent, { id, data }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const update_user = (users[user_index] = {
            ...users[user_index],
            ...data,
          });
          pubSub.publish("userUpdated", { userUpdated: update_user }); //yayÄ±n yapÄ±ldÄ±
          return update_user;
        },
        deleteUser: (parent, { id }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const deleted_user = users[user_index];

          users.splice(user_index, 1);

          pubSub.publish("userDeleted", { userDeleted: deleted_user }); // yayÄ±n yapÄ±ldÄ±
          return deleted_user;
        },
        deleteAllUsers: () => {
          const length = users.length;

          users.splice(0, length);

          return {
            count: length,
          };
        },
        // Post
        createPost: (parent, { data: { title, user_id } }) => {
          const post = {
            id: nanoid(),
            title,
            user_id,
          };

          posts.push(post);

          pubSub.publish("postCreated", { postCreated: post });
          pubSub.publish("postsCount", { postsCount: posts.length });
          return post;
        },
        updatePost: (parent, { id, data }) => {
          const post_index = posts.findIndex((post) => post.id === id);

          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const updated_post = (posts[post_index] = {
            ...posts[post_index],
            ...data,
          });

          pubSub.publish("postUpdated", { postUpdated: updated_post });
          return updated_post;
        },
        deletePost: (parent, { id }) => {
          const post_index = posts.findIndex((post) => post.id === id);
          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const deleted_post = posts[post_index];

          posts.splice(post_index, 1);
          pubSub.publish("postDeleted", { postDeleted: deleted_post });
          pubSub.publish("postsCount", { postsCount: posts.length });

          return deleted_post;
        },
        deleteAllPosts: () => {
          const length = posts.length;

          posts.splice(0, length);
          pubSub.publish("postsCount", { postsCount: posts.length });
          return {
            count: length,
          };
        },

        // Comment
        createComment: (parent, { data }) => {
          const comment = {
            id: nanoid(),
            ...data,
          };

          comments.push(comment);

          pubSub.publish("commentCreated", { commentCreated: comment });
          return comment;
        },
        updateComment: (parent, { id, data }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );

          if (comment_index === -1) {
            throw new Error("Comment not found.");
          }

          const updated_comment = (comments[comment_index] = {
            ...comments[comment_index],
            ...data,
          });
          pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
          return updated_comment;
        },
        deleteComment: (parent, { id }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );
          if (comment_index === -1) {
            throw new Error("Comment not found");
          }

          const deleted_comment = comments[comment_index];

          comments.splice(comment_index, 1);

          pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
          return deleted_comment;
        },
        deleteAllComments: () => {
          const length = comments.length;
          comments.splice(0, length);
          return {
            count: length,
          };
        },
      },
      Query: {
        users: () => users,
        user: (parent, args) => {
          const user = users.find((user) => user.id === args.id);
          if (!user) {
            return new Error("User not found");
          }

          return user;
        },

        posts: () => posts,
        post: (parent, args) => posts.find((post) => post.id === args.id),

        comments: () => comments,
        comment: (parent, args) =>
          comments.find((comment) => comment.id === args.id),
      },
      User: {
        posts: (parent, args) =>
          posts.filter((post) => post.user_id === parent.id),
        comments: (parent, args) =>
          comments.filter((comment) => comment.user_id === parent.id),
      },
      Post: {
        comments: (parent, args) =>
          comments.filter((comment) => comment.post_id === parent.id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
      Comment: {
        post: (parent, args) =>
          posts.find((post) => post.id === parent.post_id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
    },
  }),
});

const server = createServer(yoga); // server kur

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});

                </pre>
              </p>
            </div>
            <div class="row" id="withFilter">
              <h1>withFilter ile Subscription Filtreleme</h1>
              <p>
                Subscription sÄ±rasÄ±nda paraametre ile filtreleme yapacaÄŸÄ±z.
              </p>
              <p>
                biz v4 kullanÄ±yoruz. hocanÄ±n methodu bizde iÅŸe yaramÄ±yor. Bu nedenle dÃ¶kÃ¼mantasyondan <a href="https://the-guild.dev/graphql/yoga-server/docs/migration/migration-from-yoga-v1">buradan</a> ve <a href="https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions#filter-and-map-values">buradan</a> faydalanarak kendi kodumuzu yazÄ±yoruz.
              </p>
              <p>
                <pre class="prettyprint ms-0">
import {
  createYoga,
  createSchema,
  createPubSub,
  filter,
  pipe,
  map,
} from "graphql-yoga"; //filter ve pipe subscription filtreleme iÃ§in import edildi.
import { createServer } from "node:http";
import { nanoid } from "nanoid";

import { users, posts, comments } from "./data.js";

const pubSub = createPubSub();

const yoga = createYoga({
  // ÅemayÄ± sarmala
  schema: createSchema({
    typeDefs: `#graphql
      # User
      type User {
          id: ID!
          fullName: String!
          age: Int!
          posts: [Post]
          comments: [Comment]
      }

      input CreateUserInput { 
        fullName: String!
        age: Int!
      }

      input UpdateUserInput {
        fullName: String
        age: Int
      }

      # Post
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
      input CreatePostInput { 
        title: String!
        user_id: ID!
      }
      input UpdatePostInput {
        title: String
        user_id: ID
      }

      # Comment
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
      input CreateCommetInput{
        text: String!
        post_id: ID!
        user_id: ID!
      }
      input UpdateCommentInput{
        text: String
        post_id: ID
        user_id: ID
      }

      type DeleteAllOutput {
        count: Int!
      }

      type Query {
          users: [User!]!
          user(id: ID!): User!

          posts: [Post!]
          post(id: ID!): Post!

          comments: [Comment]
          comment(id: ID!): Comment!
      }

      type Mutation {
        # User
        createUser(data: CreateUserInput!): User! 
        updateUser(id: ID!, data: UpdateUserInput!): User!
        deleteUser(id: ID!): User!
        deleteAllUsers: DeleteAllOutput!
        # Post
        createPost(data: CreatePostInput!): Post!
        updatePost(id: ID!, data: UpdatePostInput!): Post!
        deletePost(id: ID!): Post!
        deleteAllPosts: DeleteAllOutput!

        # Comment
        createComment(data: CreateCommetInput!): Comment!
        updateComment(id: ID!, data: UpdateCommentInput!): Comment!
        deleteComment(id: ID!): Comment!
        deleteAllComments: DeleteAllOutput!
      }

      type Subscription {
        # count: Int! # Ã–rnek iÃ§in

        # User
        userCreated: User!
        userUpdated: User!
        userDeleted: User!

        # Post
        postCreated(user_id: ID): Post! #postCreated parametre alacak ÅŸekilde dÃ¼zenlendi.
        postUpdated: Post!
        postDeleted: Post!
        postsCount: Int!

        # Comment
        commentCreated(post_id: ID): Comment!
        commentUpdated: Comment!
        commentDeleted: Comment!
      }
    `,
    resolvers: {
      Subscription: {
        // User
        userCreated: {
          subscribe: () => pubSub.subscribe("userCreated"),
        },
        userUpdated: {
          subscribe: () => pubSub.subscribe("userUpdated"),
        },
        userDeleted: {
          subscribe: () => pubSub.subscribe("userDeleted"),
        },

        // Post
        postCreated: {
          subscribe: (parent, args) => {
            return pipe(
              // pipe 2 parametre alÄ±r.
              pubSub.subscribe("postCreated"), // 1. parametre yayÄ±na abone olmak iÃ§in kullanÄ±lan fonksiyon.
              filter((value) => // 2 parametre filter. iÃ§i true dÃ¶nerse deÄŸeri yakalar. yoksa es geÃ§er.
                args.user_id // args.user_id varsa 
                ? value.postCreated.user_id === args.user_id // bu kÄ±yaslama yapÄ±lÄ±r. 
                : true // args.user_id yoksa parametre geÃ§ilmemiÅŸtir. true dÃ¶ner.
              )
            );
          },
        },
        postUpdated: {
          subscribe: () => pubSub.subscribe("postUpdated"),
        },
        postDeleted: {
          subscribe: () => pubSub.subscribe("postDeleted"),
        },
        postsCount: {
          subscribe: () => {
            setTimeout(() => {
              pubSub.publish("postsCount", { postsCount: posts.length });
            });
            return pubSub.subscribe("postsCount");
          },
        },

        // Comment
        commentCreated: {
          subscribe: (parent, args) => {
            return pipe( // YukarÄ±daki Ã¶rneÄŸin tekrarÄ±.
              pubSub.subscribe("commentCreated"),
              filter((value) =>
                args.post_id
                  ? value.commentCreated.post_id === args.post_id
                  : true
              )
            );
          },
        },
        commentUpdated: {
          subscribe: () => pubSub.subscribe("commentUpdated"),
        },
        commentDeleted: {
          subscribe: () => pubSub.subscribe("commentDeleted"),
        },
      },
      Mutation: {
        // User
        createUser: (parent, args) => {
          const user = {
            id: nanoid(),
            fullName: args.data.fullName,
            age: args.data.age,
          };

          users.push(user);
          pubSub.publish("userCreated", { userCreated: user });

          return user;
        },
        updateUser: (parent, { id, data }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const update_user = (users[user_index] = {
            ...users[user_index],
            ...data,
          });
          pubSub.publish("userUpdated", { userUpdated: update_user });
          return update_user;
        },
        deleteUser: (parent, { id }) => {
          const user_index = users.findIndex((user) => user.id === id);
          if (user_index === -1) {
            throw new Error("User not found.");
          }

          const deleted_user = users[user_index];

          users.splice(user_index, 1);

          pubSub.publish("userDeleted", { userDeleted: deleted_user });
          return deleted_user;
        },
        deleteAllUsers: () => {
          const length = users.length;

          users.splice(0, length);

          return {
            count: length,
          };
        },
        // Post
        createPost: (parent, { data: { title, user_id } }) => {
          const post = {
            id: nanoid(),
            title,
            user_id,
          };

          posts.push(post);

          pubSub.publish("postCreated", { postCreated: post });
          pubSub.publish("postsCount", { postsCount: posts.length });
          return post;
        },
        updatePost: (parent, { id, data }) => {
          const post_index = posts.findIndex((post) => post.id === id);

          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const updated_post = (posts[post_index] = {
            ...posts[post_index],
            ...data,
          });

          pubSub.publish("postUpdated", { postUpdated: updated_post });
          return updated_post;
        },
        deletePost: (parent, { id }) => {
          const post_index = posts.findIndex((post) => post.id === id);
          if (post_index === -1) {
            throw new Error("Post not found.");
          }

          const deleted_post = posts[post_index];

          posts.splice(post_index, 1);
          pubSub.publish("postDeleted", { postDeleted: deleted_post });
          pubSub.publish("postsCount", { postsCount: posts.length });

          return deleted_post;
        },
        deleteAllPosts: () => {
          const length = posts.length;

          posts.splice(0, length);
          pubSub.publish("postsCount", { postsCount: posts.length });
          return {
            count: length,
          };
        },

        // Comment
        createComment: (parent, { data }) => {
          const comment = {
            id: nanoid(),
            ...data,
          };

          comments.push(comment);

          pubSub.publish("commentCreated", { commentCreated: comment });
          return comment;
        },
        updateComment: (parent, { id, data }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );

          if (comment_index === -1) {
            throw new Error("Comment not found.");
          }

          const updated_comment = (comments[comment_index] = {
            ...comments[comment_index],
            ...data,
          });
          pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
          return updated_comment;
        },
        deleteComment: (parent, { id }) => {
          const comment_index = comments.findIndex(
            (comment) => comment.id === id
          );
          if (comment_index === -1) {
            throw new Error("Comment not found");
          }

          const deleted_comment = comments[comment_index];

          comments.splice(comment_index, 1);

          pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
          return deleted_comment;
        },
        deleteAllComments: () => {
          const length = comments.length;
          comments.splice(0, length);
          return {
            count: length,
          };
        },
      },
      Query: {
        users: () => users,
        user: (parent, args) => {
          const user = users.find((user) => user.id === args.id);
          if (!user) {
            return new Error("User not found");
          }

          return user;
        },

        posts: () => posts,
        post: (parent, args) => posts.find((post) => post.id === args.id),

        comments: () => comments,
        comment: (parent, args) =>
          comments.find((comment) => comment.id === args.id),
      },
      User: {
        posts: (parent, args) =>
          posts.filter((post) => post.user_id === parent.id),
        comments: (parent, args) =>
          comments.filter((comment) => comment.user_id === parent.id),
      },
      Post: {
        comments: (parent, args) =>
          comments.filter((comment) => comment.post_id === parent.id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
      Comment: {
        post: (parent, args) =>
          posts.find((post) => post.id === parent.post_id),
        user: (parent, args) =>
          users.find((user) => user.id === parent.user_id),
      },
    },
  }),
});

const server = createServer(yoga); // server kur

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});

                </pre>
              </p>
            </div>
            <div class="row" id="redisPubsub">
              <h1>Redis PubSub (Konu Ã§Ã¶zÃ¼lemedi.)</h1>
              <p>
                Birden fazla sunucu kullanÄ±lmasÄ± gereken durumlarda pubSub iÅŸlemlerinin sunucuda olmasÄ± diÄŸer sunucularda yapÄ±lan iÅŸlemleri okuyamamasÄ±na neden olur. Bu nedenle pubSub iÅŸlemleri sunucu dÄ±ÅŸÄ±nda redis Ã¼zerinde tutulabilir.
              </p>
              <p>
                <b>Redis:</b> bir veri yapÄ±sÄ± sunucusudur. AÃ§Ä±k kaynak, bellek kullanÄ±mlÄ±, anahtar-deÄŸer deposudur. Redis "Uzak SÃ¶zlÃ¼k Sunucusu" (Ä°ngilizce: "REmote DIctionary Server") anlamÄ±na gelmektedir. Ã‡eÅŸitli kaynaklara gÃ¶re en Ã§ok kullanÄ±lan anahtar-deÄŸer veritabanÄ±dÄ±r.
              </p>
              <p>
                Bunun iÃ§in <a href="https://github.com/davidyaha/graphql-redis-subscriptions">graphql-redis-subscriptions</a> kullanacaÄŸÄ±z. <a href="https://github.com/davidyaha/graphql-redis-subscriptions#creating-a-redis-client">buradaki</a> Ã¶rneÄŸi baz alÄ±yoruz.
              </p>
              <p>
                terminale: <pre class="prettyprint ms-0">npm i graphql-redis-subscriptions</pre> ve <pre class="prettyprint ms-0">npm i ioredis</pre> yazÄ±yoruz.
              </p>
              <p>
                Hoca redis iÃ§in heroku kullanmÄ±ÅŸ. heruko artÄ±k free deÄŸil. Biz <a href="https://dashboard.render.com/">render</a> kullanacaÄŸÄ±z.
              </p>
              <p>
                new > redis > create redis
              </p>
              <p>
                projemizin kÃ¶k dizinine pubsub.js dosyasÄ± oluÅŸturulur. Ä°Ã§ine <a href="https://github.com/davidyaha/graphql-redis-subscriptions#creating-a-redis-client">buradaki</a> Ã¶rneÄŸi yapÄ±ÅŸtÄ±rÄ±yoruz. Ä°lgili alanlarÄ± da oluÅŸturduÄŸumuz redis serverÄ±na gÃ¶re dolduruyoruz. External redis url <pre class="prettyprint ms-0">rediss://username:password@host:port</pre> kalÄ±bÄ±na gÃ¶re oluÅŸturulmuÅŸtur. Buradaki veriler Ã¶rneÄŸe uygun olarak ayrÄ±ÅŸtÄ±rÄ±lÄ±r.
              </p>
              <p>
                KullanÄ±lan teknolojilerde Ã§akÄ±ÅŸma var. Son sÃ¼rÃ¼mler Ã§alÄ±ÅŸmÄ±yor. Daha sonra tekrar denenecek.
              </p>
              <p style="color: rgb(6, 194, 6); background-color: black; padding: 10px; font-family: monospace;">
                birden fazla metod denendi. 5. saatin sonunda konu daha sonra irdelenmek Ã¼zere bÄ±rakÄ±ldÄ±. KullanÄ±lan iki pakette Ã§akÄ±ÅŸma mevcut. 
              </p>
            </div>
            <div class="row" id="env">
              <h1>Ortam DeÄŸiÅŸkenleri</h1>
              <p>
                Kaynak kodumuzda gÃ¶rÃ¼nmesini istemediÄŸimiz bilgiler iÃ§in .env adÄ±nda bir dosya oluÅŸturuyoruz. Bunun iÃ§inde <pre class="prettyprint ms-0">PASS="password1234"</pre> gibi tanÄ±mÄ±mÄ±zÄ± yapÄ±yoruz. Bu bilgileri kullanmak iÃ§in terminale <pre class="prettyprint ms-0">npm i dotenv</pre> yazarak ilgili paketi kuruyoruz.
              </p>
              <p>
                Bu bilgiyi kullanmak istediÄŸimiz dosyada <code>dotenv</code> paketini import edip Ã§alÄ±ÅŸtÄ±rÄ±yoruz.
                <pre class="prettyprint ms-0">
import dotenv from "dotenv"
dotenv.config()
                </pre>
                ArtÄ±k .env iÃ§indeki veriyi kullanabiliriz.
                <pre class="prettyprint ms-0">
...
password: process.env.PASS
...
                </pre>
              </p>
            </div>
            <div class="row" id="folderSchemaStructure1">
              <h1>Folder/Schema Structure - 1</h1>
              <p>
                Bu ksÄ±mda index.js iÃ§indeki kodun daha dÃ¼zenli ve okunaklÄ± gÃ¶rÃ¼nmesi iÃ§in bazÄ± kÄ±sÄ±mlarÄ± baÅŸka dosyalara yÃ¼kleyip import ettik. index.js ve data.js src klasÃ¶rÃ¼ne taÅŸÄ±ndÄ±. <br>
                Son durumda: <br>
                index.js:
                <pre class="prettyprint ms-0">
import { createYoga, createSchema, createPubSub } from "graphql-yoga";
import { createServer } from "node:http";

import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

import db from "./data.js"; // veriler import edildi
import resolvers from "./graphql/resolvers/index.js"; // resolvers import edildi

const pubSub = createPubSub();

const yoga = createYoga({
  // ÅemayÄ± sarmala
  schema: createSchema({
    typeDefs: fs.readFileSync( // datanÄ±n olduÄŸu dosyanÄ±n okunmasÄ±
      path.join(
        path.dirname(fileURLToPath(import.meta.url)), // data yolunun ifade edilmesi
        "graphql/schema.graphql"
      ),
      "utf-8"
    ),
    resolvers,
  }),
  context: {
    pubSub,
    db, // database context iÃ§inde geÃ§ildi.
  },
});

const server = createServer(yoga); // server kur

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});

                </pre>
              </p>
              <p>
                typeDefs iÃ§in graphql/schema.qraphql dosyasÄ± oluÅŸturuldu.
                <pre class="prettyprint ms-0">
# User
type User {
  id: ID!
  fullName: String!
  age: Int!
  posts: [Post]
  comments: [Comment]
}

input CreateUserInput {
  fullName: String!
  age: Int!
}

input UpdateUserInput {
  fullName: String
  age: Int
}

# Post
type Post {
  id: ID!
  title: String!
  user_id: ID!
  comments: [Comment!]
  user: User!
}
input CreatePostInput {
  title: String!
  user_id: ID!
}
input UpdatePostInput {
  title: String
  user_id: ID
}

# Comment
type Comment {
  id: ID!
  text: String!
  post_id: ID!
  post: Post!
  user: User!
}
input CreateCommetInput {
  text: String!
  post_id: ID!
  user_id: ID!
}
input UpdateCommentInput {
  text: String
  post_id: ID
  user_id: ID
}

type DeleteAllOutput {
  count: Int!
}

type Query {
  users: [User!]!
  user(id: ID!): User!

  posts: [Post!]
  post(id: ID!): Post!

  comments: [Comment]
  comment(id: ID!): Comment!
}

type Mutation {
  # User
  createUser(data: CreateUserInput!): User!
  updateUser(id: ID!, data: UpdateUserInput!): User!
  deleteUser(id: ID!): User!
  deleteAllUsers: DeleteAllOutput!
  # Post
  createPost(data: CreatePostInput!): Post!
  updatePost(id: ID!, data: UpdatePostInput!): Post!
  deletePost(id: ID!): Post!
  deleteAllPosts: DeleteAllOutput!

  # Comment
  createComment(data: CreateCommetInput!): Comment!
  updateComment(id: ID!, data: UpdateCommentInput!): Comment!
  deleteComment(id: ID!): Comment!
  deleteAllComments: DeleteAllOutput!
}

type Subscription {
  # count: Int! # Ã–rnek iÃ§in

  # User
  userCreated: User!
  userUpdated: User!
  userDeleted: User!

  # Post
  postCreated(user_id: ID): Post! #postCreated parametre alacak ÅŸekilde dÃ¼zenlendi.
  postUpdated: Post!
  postDeleted: Post!
  postsCount: Int!

  # Comment
  commentCreated(post_id: ID): Comment!
  commentUpdated: Comment!
  commentDeleted: Comment!
}

                </pre>
              </p>
              <p>
                data.js db adÄ±yla import edildi ve pubSub ile birlikte context iÃ§inde geÃ§ildi. Bu sayede her resolver iÃ§in ulaÅŸÄ±labilir kÄ±lÄ±ndÄ±.
              </p>
              <p>
                src/graphql/resolvers dosyasÄ±nda tÃ¼m resolver iÅŸlemleri ayrÄ± ayrÄ± tanÄ±mlandÄ±. TanÄ±mlarda data.js den gelen veri context.db Ã¼zerinden alÄ±ndÄ±. pubSub iÅŸlemleri contex.pubSub a gÃ¶re dÃ¼zenlendi. resolvers/index.js iÃ§ine import edilip oradan topluca export edildi. <br>
                Ã¶rnek resolvers iÃ§in: <br>
                src/graphql/resolvers/Mutation.js
                <pre class="prettyprint ms-0">
import { nanoid } from "nanoid";

const Mutation = {
  // User
  createUser: (_, args, { pubSub, db }) => {
    const user = {
      id: nanoid(),
      fullName: args.data.fullName,
      age: args.data.age,
    };

    db.users.push(user);
    pubSub.publish("userCreated", { userCreated: user });

    return user;
  },
  updateUser: (_, { id, data }, { pubSub, db }) => {
    const user_index = db.users.findIndex((user) => user.id === id);
    if (user_index === -1) {
      throw new Error("User not found.");
    }

    const update_user = (db.users[user_index] = {
      ...db.users[user_index],
      ...data,
    });
    pubSub.publish("userUpdated", { userUpdated: update_user });
    return update_user;
  },
  deleteUser: (_, __, { pubSub, db }) => {
    const user_index = db.users.findIndex((user) => user.id === id);
    if (user_index === -1) {
      throw new Error("User not found.");
    }

    const deleted_user = db.users[user_index];

    db.users.splice(user_index, 1);

    pubSub.publish("userDeleted", { userDeleted: deleted_user });
    return deleted_user;
  },
  deleteAllUsers: (_, __, { db }) => {
    const length = db.users.length;

    db.users.splice(0, length);

    return {
      count: length,
    };
  },
  // Post
  createPost: (_, { data: { title, user_id } }, { pubSub, db }) => {
    const post = {
      id: nanoid(),
      title,
      user_id,
    };

    db.posts.push(post);

    pubSub.publish("postCreated", { postCreated: post });
    pubSub.publish("postsCount", { postsCount: db.posts.length });
    return post;
  },
  updatePost: (_, { id, data }, { pubSub, db }) => {
    const post_index = db.posts.findIndex((post) => post.id === id);

    if (post_index === -1) {
      throw new Error("Post not found.");
    }

    const updated_post = (db.posts[post_index] = {
      ...db.posts[post_index],
      ...data,
    });

    pubSub.publish("postUpdated", { postUpdated: updated_post });
    return updated_post;
  },
  deletePost: (_, { id }, { pubSub, db }) => {
    const post_index = db.posts.findIndex((post) => post.id === id);
    if (post_index === -1) {
      throw new Error("Post not found.");
    }

    const deleted_post = db.posts[post_index];

    db.posts.splice(post_index, 1);
    pubSub.publish("postDeleted", { postDeleted: deleted_post });
    pubSub.publish("postsCount", { postsCount: posts.length });

    return deleted_post;
  },
  deleteAllPosts: (_, __, { pubSub, db }) => {
    const length = db.posts.length;

    db.posts.splice(0, length);
    pubSub.publish("postsCount", { postsCount: db.posts.length });
    return {
      count: length,
    };
  },

  // Comment
  createComment: (_, { data }, { pubSub, db }) => {
    const comment = {
      id: nanoid(),
      ...data,
    };

    db.comments.push(comment);

    pubSub.publish("commentCreated", { commentCreated: comment });
    return comment;
  },
  updateComment: (_, { id, data }, { pubSub, db }) => {
    const comment_index = db.comments.findIndex((comment) => comment.id === id);

    if (comment_index === -1) {
      throw new Error("Comment not found.");
    }

    const updated_comment = (db.comments[comment_index] = {
      ...db.comments[comment_index],
      ...data,
    });
    pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
    return updated_comment;
  },
  deleteComment: (_, { id }, { pubSub, db }) => {
    const comment_index = db.comments.findIndex((comment) => comment.id === id);
    if (comment_index === -1) {
      throw new Error("Comment not found");
    }

    const deleted_comment = db.comments[comment_index];

    db.comments.splice(comment_index, 1);

    pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
    return deleted_comment;
  },
  deleteAllComments: (_, __, { db }) => {
    const length = db.comments.length;
    db.comments.splice(0, length);
    return {
      count: length,
    };
  },
};

export default Mutation;

                </pre>
                index.js:
                <pre class="prettyprint ms-0">
import Comment from "./Comment.js"
import Mutation from "./Mutation.js"
import Post from "./Post.js"
import Query from "./Query.js"
import Subscription from "./Subscription.js"
import User from "./User.js"

export default {
    Mutation,
    Comment,
    Post,
    Query,
    Subscription,
    User
}
                </pre>
              </p>
            </div>
            <div class="row" id="folderSchemaStructure2">
              <h1>Folder/Schema Structure - 2 (File Loader)</h1>
              <p>
                Bu kÄ±sÄ±mda tip tanÄ±mlarÄ±mÄ±zÄ± otomatik merge edeceÄŸiz. <a href="https://the-guild.dev/graphql/tools/docs/schema-merging">doc</a>
              </p>
              <p>
                resolver iÃ§in de dÃ¶kÃ¼manda merge uygulamasÄ± var ancak es6 iÃ§in uygulanamÄ±yor. Babeli kurduktan sonraki kÄ±sÄ±mda resolver merge iÅŸlemini tekrar yaptÄ±k ğŸ˜„
              </p>
              <p>
                terminale <pre class="prettyprint ms-0">npm i @graphql-tools/load-files @graphql-tools/merge</pre> yazÄ±p gereken paketleri yÃ¼klÃ¼yoruz.
              </p>
              <p>
                dÃ¶kÃ¼mantasyondaki <code>__dir</code> ifadesi ES6 da Ã§alÄ±ÅŸmÄ±yor. <code>path.join(__dirname)</code> yerine <code>path.dirname(fileURLToPath(import.meta.url))</code> ifadesini kullanÄ±yoruz. Bunun Ã§alÄ±ÅŸmasÄ± iÃ§in ise 
                <pre class="prettyprint ms-0">
import * as path from "path";
import { fileURLToPath } from "url";
                </pre> 
                import iÅŸlemlerinin yapÄ±lmasÄ± gerekiyor.
              </p>
              <p>
                tip tanÄ±mlarÄ±nÄ± src/graphql/type-defs klasÃ¶rÃ¼nÃ¼n iÃ§ine yerleÅŸtirdik ve her bir veri tipi iÃ§in ilgili tip tanÄ±mÄ±nÄ± kendine ait bir dosyaya taÅŸÄ±dÄ±k.
                <ul>
                  <li>User.graphql</li>
                  <li>Post.graphql</li>
                  <li>Comment.graphql</li>
                  <li>global.graphql</li>
                </ul>
              </p>
              <p>
                Ã–rnek olarak User.graphql
                <pre class="prettyprint ms-0">
type Query {
  users: [User!]!
  user(id: ID!): User!
}

type Mutation {
  createUser(data: CreateUserInput!): User!
  updateUser(id: ID!, data: UpdateUserInput!): User!
  deleteUser(id: ID!): User!
  deleteAllUsers: DeleteAllOutput!
}

type Subscription {
  userCreated: User!
  userUpdated: User!
  userDeleted: User!
}

type User {
  id: ID!
  fullName: String!
  age: Int!
  posts: [Post]
  comments: [Comment]
}

input CreateUserInput {
  fullName: String!
  age: Int!
}

input UpdateUserInput {
  fullName: String
  age: Int
}
                </pre>
              </p>
              <p>
                Bu tanÄ±mlarÄ± birleÅŸtirmesi (merge) iÃ§ib src/type-defs/index.js iÃ§ine:
                <pre class="prettyprint ms-0">
import * as path from "path";
import { fileURLToPath } from "url";
import { loadFilesSync } from '@graphql-tools/load-files'
import { mergeTypeDefs } from '@graphql-tools/merge'
 
const typesArray = loadFilesSync(path.dirname(fileURLToPath(import.meta.url)), { extensions: ['graphql'] })
 
export default mergeTypeDefs(typesArray)
                </pre>
              </p>
              <p>
                src index.js iÃ§inde import edilir ve kullanÄ±lÄ±r.
                <pre class="prettyprint ms-0">
import { createYoga, createSchema, createPubSub } from "graphql-yoga";
import { createServer } from "node:http";

import db from "./data.js";
import resolvers from "./graphql/resolvers/index.js";
import typeDefs from "./graphql/type-defs/index.js";

const pubSub = createPubSub();

const yoga = createYoga({
  schema: createSchema({
    typeDefs,
    resolvers,
  }),
  context: {
    pubSub,
    db,
  },
});

const server = createServer(yoga); // server kur

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});

                </pre>
              </p>
            </div>
            <div class="row" id="babelComplier">
              <h1>Babel Compiler </h1>
              <p>
                Build iÅŸlemini gerÃ§ekleÅŸtireceÄŸiz. Bunun iÃ§in <a href="https://babeljs.io/">babel</a> kullanacaÄŸÄ±z.
              </p>
              <p>
                <strong>Babel nedir?</strong> Babel, ECMAScript 2015+ kodunu mevcut ve eski tarayÄ±cÄ±larda veya ortamlarda geriye dÃ¶nÃ¼k olarak uyumlu bir JavaScript sÃ¼rÃ¼mÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lan bir araÃ§tÄ±r.
              </p>
              <p>
                Babel sayesinde daha Ã¶nce ES6 da Ã§alÄ±ÅŸmayan sÃ¶z dizimleri ile ES6 bir arada yazÄ±labilir. 
              </p>
              <p>
                <a href="https://babeljs.io/">Babeljs.io</a> iÃ§inde setup>nodemon
              </p>
              <p>
                terminale <pre class="prettyprint ms-0">npm install @babel/core @babel/node --save-dev</pre> ve <pre class="prettyprint ms-0">npm install @babel/preset-env --save-dev</pre> ve build iÃ§in:<pre class="prettyprint ms-0">npm install --save-dev @babel/cli</pre> 
              </p>
              <p>
                package.json dosyasÄ±nda scripts>dev alanÄ± aÅŸaÄŸÄ±daki gibi gÃ¼ncellendi ve "type": "module" ifadesi kaldÄ±rÄ±ldÄ±.
                <pre class="prettyprint ms-0">
"scripts": {
    ...
    "dev": "nodemon --exec babel-node ./src/index.js",
    ...
  },
                </pre>
              </p>
              <p>
                kÃ¶k dizine .babelrc adÄ±nda bir dosya oluÅŸturuldu ve iÃ§ine:
                <pre class="prettyprint ms-0">
{
    "presets": ["@babel/preset-env"]
}
                </pre> eklendi.
              </p>
              <p>
                son nanoid versiyonu ES6 dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸmÄ±yor. Bu nedenle Ã¶nceki bir sÃ¼rÃ¼m yoklendi.
                <pre class="prettyprint ms-0">
npm uninstall nanoid
npm install nanoid@3.3.4
                </pre>
              </p>
              <p>
                ES6 dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸmayan kodlardan kurtulmak iÃ§in graphql/type-defs/index.js dÃ¼zenlendi.
                <pre class="prettyprint ms-0">
import * as path from "path";
import { loadFilesSync } from '@graphql-tools/load-files'
import { mergeTypeDefs } from '@graphql-tools/merge'
 
// const typesArray = loadFilesSync(path.dirname(fileURLToPath(import.meta.url)), { extensions: ['graphql'] })
const typesArray = loadFilesSync(path.join(__dirname), { extensions: ['graphql'] }) // dir ifadesi babel sayesinde Ã§alÄ±ÅŸÄ±yor.

export default mergeTypeDefs(typesArray)
                </pre>
              </p>
              <p>
                package.json script alanÄ± dÃ¼zenlendi. package.json son hali:
                <pre class="prettyprint ms-0">
{
  "name": "comment-challenge",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node ./dist/index.js",
    "dev": "nodemon --exec babel-node ./src/index.js",
    "build": "babel ./src --out-dir dist --minified --copy-files"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@apollo/server": "^4.7.1",
    "@graphql-tools/load-files": "^7.0.0",
    "@graphql-tools/merge": "^9.0.0",
    "@graphql-yoga/node": "^3.9.1",
    "@graphql-yoga/redis-event-target": "2.0.0",
    "graphql": "^16.6.0",
    "graphql-redis-subscriptions": "^2.6.0",
    "graphql-subscriptions": "^2.0.0",
    "graphql-ws": "^5.13.1",
    "graphql-yoga": "^3.9.2-rc-20230524133912-835c7e3d",
    "ioredis": "5.3.2",
    "nanoid": "^3.3.4",
    "redis": "^4.6.7"
  },
  "devDependencies": {
    "@babel/cli": "^7.22.5",
    "@babel/core": "^7.22.5",
    "@babel/node": "^7.22.5",
    "@babel/preset-env": "^7.22.5",
    "babel-plugin-module-resolver": "^5.0.0",
    "nodemon": "^2.0.22"
  }
}
                </pre>
              </p>
              <p>
                <code>"build": "babel ./src --out-dir dist --minified --copy-files"</code> kodunda <code>--minified</code> build edilen tÃ¼m dosyalarda kodu tek satÄ±ra toplar. <code>--copy-files</code> ise o olmadan kopyalanmayan nonjs dosyalarÄ± da build iÃ§ine kopyalar
              </p>
              <p>
                build iÅŸlemi ile developer tarafÄ±ndaki Ã¼rÃ¼n product tarafÄ±na hazÄ±r hale getirilir. Bu iÅŸlem iÃ§in terminale <pre class="prettyprint ms-0">npm run build</pre> yazÄ±lÄ±r. disc adÄ±nda bir klasÃ¶re build oluÅŸturulur.
              </p>

              <h2>babel-plugin-module-resolver</h2>
              <p>
                import sÄ±rasÄ±nda dosya dizini bulmayÄ± kolaylaÅŸtÄ±rmak iÃ§in dosya yollarÄ±na takma ad vermek  iÃ§in <a href="https://www.npmjs.com/package/babel-plugin-module-resolver">babel-plugin-module-resolver</a> kullanÄ±labilir. bunun iÃ§in terminale <pre class="prettyprint ms-0">npm install --save-dev babel-plugin-module-resolver</pre>
              </p>
              <p>
                .babelrc iÃ§ine kÄ±sayollar tanÄ±mlanÄ±r. .babelrc son hali:
                <pre class="prettyprint ms-0">
{
    "presets": ["@babel/preset-env"],
    "plugins": [
        ["module-resolver", {
        "root": ["./src"],
        "alias": {
            "@graphql": "./src/graphql",
            "@resolvers": "./src/graphql/resolvers",
            "@type-defs": "./src/graphql/type-defs"
        }
        }]
    ]
}
                </pre>
              </p>
              <p>
                Buna gÃ¶re src/index.js:
                <pre class="prettyprint ms-0">
import { createYoga, createSchema, createPubSub } from "graphql-yoga";
import { createServer } from "node:http";

import db from "./data.js";
import resolvers from "@resolvers"; //
import typeDefs from "@type-defs"; //

const pubSub = createPubSub();

const yoga = createYoga({
  schema: createSchema({
    typeDefs,
    resolvers,
  }),
  context: {
    pubSub,
    db,
  },
});

const server = createServer(yoga); 
server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});
                </pre>
              </p>

              <h2>Babel SonrasÄ± Resolver Merge</h2>
              <p>graphql/resolvers altÄ±na bir resolvers klasÃ¶rÃ¼ daha aÃ§Ä±lÄ±r ve index.js harici dosyalaor oraya taÅŸÄ±nÄ±r.</p>
              <p>
                graphql/resolvers/index.js aÅŸaÄŸÄ±daki gibi dÃ¼zenlenir.
                <pre class="prettyprint ms-0">
import path from "path";
import { mergeResolvers } from "@graphql-tools/merge";
import { loadFilesSync } from "@graphql-tools/load-files";

const resolversArray = loadFilesSync(path.join(__dirname, "/resolvers"), {
  extensions: ["js"],
  extractExports: (fileExport) => { // bu kod index.js ile aynÄ± dizinde resolverler olmasÄ± durumunda index.js dosyasÄ±nÄ± merge dÄ±ÅŸÄ±nda tutmak iÃ§in yazÄ±ldÄ± ama Ã§alÄ±ÅŸmÄ±yor. Bu nedenle resolverlar baÅŸka bir klasÃ¶re taÅŸÄ±ndÄ±.
    if (typeof fileExport === "function") {
      return fileExport("query_root");
    }
    return fileExport;
  },
});

export default mergeResolvers(resolversArray);

                </pre>
              </p>
              <p>
                merge iÅŸleminin dÃ¼zgÃ¼n yapÄ±labilmesi iÃ§in <code>export default ...</code> ifadesi yerine <code>export const ...</code> kalÄ±bÄ± kullanÄ±lÄ±r. Ã¶rnek: src/graphql/resolvers/resolvers/Mutation.js
                <pre class="prettyprint ms-0">
import { nanoid } from "nanoid";

export const Mutation = {
  // User
  createUser: (_, args, { pubSub, db }) => {
    const user = {
      id: nanoid(),
      fullName: args.data.fullName,
      age: args.data.age,
    };

    db.users.push(user);
    pubSub.publish("userCreated", { userCreated: user });

    return user;
  },
  updateUser: (_, { id, data }, { pubSub, db }) => {
    const user_index = db.users.findIndex((user) => user.id === id);
    if (user_index === -1) {
      throw new Error("User not found.");
    }

    const update_user = (db.users[user_index] = {
      ...db.users[user_index],
      ...data,
    });
    pubSub.publish("userUpdated", { userUpdated: update_user });
    return update_user;
  },
  deleteUser: (_, __, { pubSub, db }) => {
    const user_index = db.users.findIndex((user) => user.id === id);
    if (user_index === -1) {
      throw new Error("User not found.");
    }

    const deleted_user = db.users[user_index];

    db.users.splice(user_index, 1);

    pubSub.publish("userDeleted", { userDeleted: deleted_user });
    return deleted_user;
  },
  deleteAllUsers: (_, __, { db }) => {
    const length = db.users.length;

    db.users.splice(0, length);

    return {
      count: length,
    };
  },
  // Post
  createPost: (_, { data: { title, user_id } }, { pubSub, db }) => {
    const post = {
      id: nanoid(),
      title,
      user_id,
    };

    db.posts.push(post);

    pubSub.publish("postCreated", { postCreated: post });
    pubSub.publish("postsCount", { postsCount: db.posts.length });
    return post;
  },
  updatePost: (_, { id, data }, { pubSub, db }) => {
    const post_index = db.posts.findIndex((post) => post.id === id);

    if (post_index === -1) {
      throw new Error("Post not found.");
    }

    const updated_post = (db.posts[post_index] = {
      ...db.posts[post_index],
      ...data,
    });

    pubSub.publish("postUpdated", { postUpdated: updated_post });
    return updated_post;
  },
  deletePost: (_, { id }, { pubSub, db }) => {
    const post_index = db.posts.findIndex((post) => post.id === id);
    if (post_index === -1) {
      throw new Error("Post not found.");
    }

    const deleted_post = db.posts[post_index];

    db.posts.splice(post_index, 1);
    pubSub.publish("postDeleted", { postDeleted: deleted_post });
    pubSub.publish("postsCount", { postsCount: posts.length });

    return deleted_post;
  },
  deleteAllPosts: (_, __, { pubSub, db }) => {
    const length = db.posts.length;

    db.posts.splice(0, length);
    pubSub.publish("postsCount", { postsCount: db.posts.length });
    return {
      count: length,
    };
  },

  // Comment
  createComment: (_, { data }, { pubSub, db }) => {
    const comment = {
      id: nanoid(),
      ...data,
    };

    db.comments.push(comment);

    pubSub.publish("commentCreated", { commentCreated: comment });
    return comment;
  },
  updateComment: (_, { id, data }, { pubSub, db }) => {
    const comment_index = db.comments.findIndex((comment) => comment.id === id);

    if (comment_index === -1) {
      throw new Error("Comment not found.");
    }

    const updated_comment = (db.comments[comment_index] = {
      ...db.comments[comment_index],
      ...data,
    });
    pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
    return updated_comment;
  },
  deleteComment: (_, { id }, { pubSub, db }) => {
    const comment_index = db.comments.findIndex((comment) => comment.id === id);
    if (comment_index === -1) {
      throw new Error("Comment not found");
    }

    const deleted_comment = db.comments[comment_index];

    db.comments.splice(comment_index, 1);

    pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
    return deleted_comment;
  },
  deleteAllComments: (_, __, { db }) => {
    const length = db.comments.length;
    db.comments.splice(0, length);
    return {
      count: length,
    };
  },
};


                </pre> 
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>